// this file has been generated by github.com/fasterthanlime/wizardry
// from a set of magic rules. you probably don't want to edit it by hand

package wizbook

import (
  "fmt"
  "encoding/binary"
  "github.com/fasterthanlime/wizardry/wizardry"
)

// silence import errors, if we don't use string/search etc.
var _ wizardry.StringTestFlags
var _ fmt.State
var le binary.ByteOrder = binary.LittleEndian
var be binary.ByteOrder = binary.BigEndian
type i8 int8
type u8 uint8
type i16 int16
type u16 uint16
type i32 int32
type u32 uint32
type i64 int64
type u64 uint64

func readU8le(tb []byte, off i64) (u8, bool) {
  if i64(len(tb)) < off+1 {
    return 0, false
  }
  pi := u8(tb[off])
  return u8(pi), true
}

func readU8be(tb []byte, off i64) (u8, bool) {
  if i64(len(tb)) < off+1 {
    return 0, false
  }
  pi := u8(tb[off])
  return u8(pi), true
}

func readU16le(tb []byte, off i64) (u16, bool) {
  if i64(len(tb)) < off+2 {
    return 0, false
  }
  pi := le.Uint16(tb[off:])
  return u16(pi), true
}

func readU16be(tb []byte, off i64) (u16, bool) {
  if i64(len(tb)) < off+2 {
    return 0, false
  }
  pi := be.Uint16(tb[off:])
  return u16(pi), true
}

func readU32le(tb []byte, off i64) (u32, bool) {
  if i64(len(tb)) < off+4 {
    return 0, false
  }
  pi := le.Uint32(tb[off:])
  return u32(pi), true
}

func readU32be(tb []byte, off i64) (u32, bool) {
  if i64(len(tb)) < off+4 {
    return 0, false
  }
  pi := be.Uint32(tb[off:])
  return u32(pi), true
}

func readU64le(tb []byte, off i64) (u64, bool) {
  if i64(len(tb)) < off+8 {
    return 0, false
  }
  pi := le.Uint64(tb[off:])
  return u64(pi), true
}

func readU64be(tb []byte, off i64) (u64, bool) {
  if i64(len(tb)) < off+8 {
    return 0, false
  }
  pi := be.Uint64(tb[off:])
  return u64(pi), true
}

func Identify(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f0 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  // >4	belong		>30		compiled Java class data,
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x1e)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tbelong\t\t>30\t\tcompiled Java class data,")
  out = append(out, "compiled Java class data,")
  // >>6	beshort		x	        version %d.
  off = pageOff + 0x6
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>6\tbeshort\t\tx\t        version %d.")
  out = append(out, "version %d.")
  goto s1
  // >>4	beshort		x       	\b%d
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tbeshort\t\tx       \t\\b%d")
  out = append(out, "\\b%d")
  goto s1
  // >>4	belong		0x002e		(Java 1.2)
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x2e)) { goto f4 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x002e\t\t(Java 1.2)")
  out = append(out, "(Java 1.2)")
  goto s1
f4:
  // >>4	belong		0x002f		(Java 1.3)
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x2f)) { goto f5 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x002f\t\t(Java 1.3)")
  out = append(out, "(Java 1.3)")
  goto s1
f5:
  // >>4	belong		0x0030		(Java 1.4)
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x30)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x0030\t\t(Java 1.4)")
  out = append(out, "(Java 1.4)")
  goto s1
f6:
  // >>4	belong		0x0031		(Java 1.5)
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x31)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x0031\t\t(Java 1.5)")
  out = append(out, "(Java 1.5)")
  goto s1
f7:
  // >>4	belong		0x0032		(Java 1.6)
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x32)) { goto f8 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x0032\t\t(Java 1.6)")
  out = append(out, "(Java 1.6)")
  goto s1
f8:
s1:
  goto s0
f1:
s0:
  goto end
f0:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  out = append(out, "JAR compressed with pack200,")
  // >5	byte		x		version %d.
  off = pageOff + 0x5
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\tx\t\tversion %d.")
  out = append(out, "version %d.")
  goto s9
  // >4	byte		x		\b%d
  off = pageOff + 0x4
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\tx\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s9
s9:
  goto end
f9:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f12 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  out = append(out, "JAR compressed with pack200,")
  // >5	byte		x		version %d.
  off = pageOff + 0x5
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\tx\t\tversion %d.")
  out = append(out, "version %d.")
  goto s12
  // >4	byte		x		\b%d
  off = pageOff + 0x4
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\tx\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s12
s12:
  goto end
f12:
  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f15 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  // >4	belong		1		Mach-O universal binary with 1 architecture:
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f16 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tbelong\t\t1\t\tMach-O universal binary with 1 architecture:")
  out = append(out, "Mach-O universal binary with 1 architecture:")
  // >>8	use		mach-o		\b
  off = pageOff + 0x8
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>8\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s16
s16:
  goto s15
f16:
  // >4	belong		>1
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x1)) { goto f18 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tbelong\t\t>1")
  // >>4	belong		<20		Mach-O universal binary with %ld architectures:
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) < 0x14)) { goto f19 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t<20\t\tMach-O universal binary with %ld architectures:")
  out = append(out, "Mach-O universal binary with %ld architectures:")
  // >>>8	use		mach-o		\b
  off = pageOff + 0x8
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>8\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s19
  // >>>28	use		mach-o		\b
  off = pageOff + 0x1c
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>28\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s19
s19:
  goto s18
f19:
  // >>4	belong		>2
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x2)) { goto f22 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t>2")
  // >>>48	use		mach-o		\b
  off = pageOff + 0x30
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>48\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s22
s22:
  goto s18
f22:
  // >>4	belong		>3
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x3)) { goto f24 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t>3")
  // >>>68	use		mach-o		\b
  off = pageOff + 0x44
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>68\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s24
s24:
  goto s18
f24:
s18:
  goto s15
f18:
s15:
  goto end
f15:
  // 0	string/wt	#!\ /bin/sh		POSIX shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f26 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/sh\t\tPOSIX shell script text executable")
  out = append(out, "POSIX shell script text executable")
  goto end
f26:
  // 0	string/wb	#!\ /bin/sh		POSIX shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f27 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/sh\t\tPOSIX shell script executable (binary data)")
  out = append(out, "POSIX shell script executable (binary data)")
  goto end
f27:
  // 0	string/wt	#!\ /bin/csh		C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f28 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/csh\t\tC shell script text executable")
  out = append(out, "C shell script text executable")
  goto end
f28:
  // 0	string/wt	#!\ /bin/ksh		Korn shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f29 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/ksh\t\tKorn shell script text executable")
  out = append(out, "Korn shell script text executable")
  goto end
f29:
  // 0	string/wb	#!\ /bin/ksh		Korn shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f30 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/ksh\t\tKorn shell script executable (binary data)")
  out = append(out, "Korn shell script executable (binary data)")
  goto end
f30:
  // 0	string/wt 	#!\ /bin/tcsh		Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f31 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /bin/tcsh\t\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f31:
  // 0	string/wt	#!\ /usr/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f32 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/tcsh\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f32:
  // 0	string/wt 	#!\ /usr/local/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f33 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /usr/local/tcsh\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f33:
  // 0	string/wt	#!\ /usr/local/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f34 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/tcsh\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f34:
  // 0	string/wt	#!\ /bin/zsh		Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f35 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/zsh\t\tPaul Falstad's zsh script text executable")
  out = append(out, "Paul Falstad's zsh script text executable")
  goto end
f35:
  // 0	string/wt	#!\ /usr/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f36 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/zsh\tPaul Falstad's zsh script text executable")
  out = append(out, "Paul Falstad's zsh script text executable")
  goto end
f36:
  // 0	string/wt	#!\ /usr/local/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f37 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/zsh\tPaul Falstad's zsh script text executable")
  out = append(out, "Paul Falstad's zsh script text executable")
  goto end
f37:
  // 0	string/wt	#!\ /usr/local/bin/ash	Neil Brown's ash script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f38 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ash\tNeil Brown's ash script text executable")
  out = append(out, "Neil Brown's ash script text executable")
  goto end
f38:
  // 0	string/wt	#!\ /usr/local/bin/ae	Neil Brown's ae script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f39 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ae\tNeil Brown's ae script text executable")
  out = append(out, "Neil Brown's ae script text executable")
  goto end
f39:
  // 0	string/wt	#!\ /bin/nawk		new awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f40 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/nawk\t\tnew awk script text executable")
  out = append(out, "new awk script text executable")
  goto end
f40:
  // 0	string/wt	#!\ /usr/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f41 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/nawk\tnew awk script text executable")
  out = append(out, "new awk script text executable")
  goto end
f41:
  // 0	string/wt	#!\ /usr/local/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f42 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/nawk\tnew awk script text executable")
  out = append(out, "new awk script text executable")
  goto end
f42:
  // 0	string/wt	#!\ /bin/gawk		GNU awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f43 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/gawk\t\tGNU awk script text executable")
  out = append(out, "GNU awk script text executable")
  goto end
f43:
  // 0	string/wt	#!\ /usr/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f44 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/gawk\tGNU awk script text executable")
  out = append(out, "GNU awk script text executable")
  goto end
f44:
  // 0	string/wt	#!\ /usr/local/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f45 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/gawk\tGNU awk script text executable")
  out = append(out, "GNU awk script text executable")
  goto end
f45:
  // 0	string/wt	#!\ /bin/awk		awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f46 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/awk\t\tawk script text executable")
  out = append(out, "awk script text executable")
  goto end
f46:
  // 0	string/wt	#!\ /usr/bin/awk	awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f47 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/awk\tawk script text executable")
  out = append(out, "awk script text executable")
  goto end
f47:
  // 0	string/wt	#!\ /bin/rc	Plan 9 rc shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f48 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/rc\tPlan 9 rc shell script text executable")
  out = append(out, "Plan 9 rc shell script text executable")
  goto end
f48:
  // 0	string/wt	#!\ /bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f49 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f49:
  // 0	string/wb	#!\ /bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f50 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f50:
  // 0	string/wt	#!\ /usr/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f51 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f51:
  // 0	string/wb	#!\ /usr/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f52 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/bin/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f52:
  // 0	string/wt	#!\ /usr/local/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f53 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f53:
  // 0	string/wb	#!\ /usr/local/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f54 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f54:
  // 0	string/wt	#!\ /usr/local/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f55 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f55:
  // 0	string/wb	#!\ /usr/local/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f56 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bin/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f56:
  // 0	search/1/c	=<?php			PHP script text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?php"))
    if ml < 0 { goto f57 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/c\t=<?php\t\t\tPHP script text")
  out = append(out, "PHP script text")
  goto end
f57:
  // 0	search/1	=<?\n			PHP script text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\n"))
    if ml < 0 { goto f58 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\n\t\t\tPHP script text")
  out = append(out, "PHP script text")
  goto end
f58:
  // 0	search/1	=<?\r			PHP script text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\r"))
    if ml < 0 { goto f59 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\r\t\t\tPHP script text")
  out = append(out, "PHP script text")
  goto end
f59:
  // 0	search/1/w	#!\ /usr/local/bin/php	PHP script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/local/bin/php"))
    if ml < 0 { goto f60 }
    gof = off + ml + 0x15
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/local/bin/php\tPHP script text executable")
  out = append(out, "PHP script text executable")
  goto end
f60:
  // 0	search/1/w	#!\ /usr/bin/php	PHP script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/bin/php"))
    if ml < 0 { goto f61 }
    gof = off + ml + 0xf
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/bin/php\tPHP script text executable")
  out = append(out, "PHP script text executable")
  goto end
f61:
  // 0	string	=<?php\ /*\ Smarty\ version	Smarty compiled template
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x3c, 0x3f, 0x70, 0x68, 0x70, 0x20, 0x2f, 0x2a, 0x20, 0x53, 0x6d, 0x61, 0x72, 0x74, 0x79, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f62 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t=<?php\\ /*\\ Smarty\\ version\tSmarty compiled template")
  out = append(out, "Smarty compiled template")
  goto end
f62:
  // 0	string		Zend\x00		PHP script Zend Optimizer data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x65, 0x6e, 0x64, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f63 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tZend\\x00\t\tPHP script Zend Optimizer data")
  out = append(out, "PHP script Zend Optimizer data")
  goto end
f63:
  // 0	string/t	$!			DCL command file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f64 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t$!\t\t\tDCL command file")
  out = append(out, "DCL command file")
  goto end
f64:
  // 0	string		#!/usr/bin/pdmenu	Pdmenu configuration file text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x70, 0x64, 0x6d, 0x65, 0x6e, 0x75}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f65 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t#!/usr/bin/pdmenu\tPdmenu configuration file text")
  out = append(out, "Pdmenu configuration file text")
  goto end
f65:
  // 0	string		\177ELF		ELF
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x7f, 0x45, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f66 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t\\177ELF\t\tELF")
  out = append(out, "ELF")
  // >4	byte		0		invalid class
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f67 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\t0\t\tinvalid class")
  out = append(out, "invalid class")
  goto s66
f67:
  // >4	byte		1		32-bit
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f68 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\t1\t\t32-bit")
  out = append(out, "32-bit")
  goto s66
f68:
  // >4	byte		2		64-bit
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f69 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\t2\t\t64-bit")
  out = append(out, "64-bit")
  goto s66
f69:
  // >5	byte		0		invalid byte order
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f70 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\t0\t\tinvalid byte order")
  out = append(out, "invalid byte order")
  goto s66
f70:
  // >5	byte		1		LSB
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f71 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\t1\t\tLSB")
  out = append(out, "LSB")
  // >>0	use		elf-le
  off = pageOff + 0x0
  {
    ss, _ := IdentifyElfLe(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0\tuse\t\telf-le")
  goto s71
s71:
  goto s66
f71:
  // >5	byte		2		MSB
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f73 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\t2\t\tMSB")
  out = append(out, "MSB")
  // >>0	use		\^elf-le
  off = pageOff + 0x0
  {
    ss, _ := IdentifyElfLe__Swapped(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0\tuse\t\t\\^elf-le")
  goto s73
s73:
  goto s66
f73:
  // >4      byte            <0x80
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) < 0x80)) { goto f75 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4      byte            <0x80")
  // >>8	string		>\0		(%s)
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f76 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>8\tstring\t\t>\\0\t\t(%s)")
  out = append(out, "(%s)")
  goto s75
f76:
s75:
  goto s66
f75:
  // >8	string		\0
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f77 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">8\tstring\t\t\\0")
  // >>7	byte		0		(SYSV)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f78 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t0\t\t(SYSV)")
  out = append(out, "(SYSV)")
  goto s77
f78:
  // >>7	byte		1		(HP-UX)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f79 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t1\t\t(HP-UX)")
  out = append(out, "(HP-UX)")
  goto s77
f79:
  // >>7	byte		2		(NetBSD)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f80 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t2\t\t(NetBSD)")
  out = append(out, "(NetBSD)")
  goto s77
f80:
  // >>7	byte		3		(GNU/Linux)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f81 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t3\t\t(GNU/Linux)")
  out = append(out, "(GNU/Linux)")
  goto s77
f81:
  // >>7	byte		4		(GNU/Hurd)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f82 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t4\t\t(GNU/Hurd)")
  out = append(out, "(GNU/Hurd)")
  goto s77
f82:
  // >>7	byte		5		(86Open)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f83 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t5\t\t(86Open)")
  out = append(out, "(86Open)")
  goto s77
f83:
  // >>7	byte		6		(Solaris)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f84 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t6\t\t(Solaris)")
  out = append(out, "(Solaris)")
  goto s77
f84:
  // >>7	byte		7		(Monterey)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f85 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t7\t\t(Monterey)")
  out = append(out, "(Monterey)")
  goto s77
f85:
  // >>7	byte		8		(IRIX)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f86 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t8\t\t(IRIX)")
  out = append(out, "(IRIX)")
  goto s77
f86:
  // >>7	byte		9		(FreeBSD)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f87 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t9\t\t(FreeBSD)")
  out = append(out, "(FreeBSD)")
  goto s77
f87:
  // >>7	byte		10		(Tru64)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f88 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t10\t\t(Tru64)")
  out = append(out, "(Tru64)")
  goto s77
f88:
  // >>7	byte		11		(Novell Modesto)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f89 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t11\t\t(Novell Modesto)")
  out = append(out, "(Novell Modesto)")
  goto s77
f89:
  // >>7	byte		12		(OpenBSD)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f90 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t12\t\t(OpenBSD)")
  out = append(out, "(OpenBSD)")
  goto s77
f90:
s77:
  goto s66
f77:
  // >8      string          \2
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f91 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">8      string          \\2")
  // >>7     byte            13              (OpenVMS)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xd)) { goto f92 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7     byte            13              (OpenVMS)")
  out = append(out, "(OpenVMS)")
  goto s91
f92:
  // >>7	byte		97		(ARM)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x61)) { goto f93 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t97\t\t(ARM)")
  out = append(out, "(ARM)")
  goto s91
f93:
  // >>7	byte		255		(embedded)
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f94 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t255\t\t(embedded)")
  out = append(out, "(embedded)")
  goto s91
f94:
s91:
  goto s66
f91:
s66:
  goto end
f66:
  // 0	lelong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f95 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong&0xfffffffe\t0xfeedface\tMach-O")
  out = append(out, "Mach-O")
  // >0	use	\^mach-o-be
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMachOBe__Swapped(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\\^mach-o-be")
  goto s95
s95:
  goto end
f95:
  // 0	belong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f97 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong&0xfffffffe\t0xfeedface\tMach-O")
  out = append(out, "Mach-O")
  // >0	use	mach-o-be
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMachOBe(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\tmach-o-be")
  goto s97
s97:
  goto end
f97:
  // 0	string/t	@
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x40}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f99 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t@")
  // >1	string/cW	\ echo\ off	DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x6f, 0x66, 0x66}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f100 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\t\\ echo\\ off\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f100:
  // >1	string/cW	echo\ off	DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x65, 0x63, 0x68, 0x6f, 0x20, 0x6f, 0x66, 0x66}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f101 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\techo\\ off\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f101:
  // >1	string/cW	rem		DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x72, 0x65, 0x6d}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f102 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\trem\t\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f102:
  // >1	string/cW	set\ 		DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x73, 0x65, 0x74, 0x20}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f103 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\tset\\ \t\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f103:
s99:
  goto end
f99:
  // 100	search/0xffff   rxfuncadd
  off = pageOff + 0x64
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xffff, "rxfuncadd"))
    if ml < 0 { goto f104 }
    gof = off + ml + 0x9
  }
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   rxfuncadd")
  goto end
f104:
  // 100	search/0xffff   say
  off = pageOff + 0x64
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xffff, "say"))
    if ml < 0 { goto f105 }
    gof = off + ml + 0x3
  }
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   say")
  goto end
f105:
  // 0	leshort		0x166	MS Windows COFF MIPS R4000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x166)) { goto f106 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x166\tMS Windows COFF MIPS R4000 object file")
  out = append(out, "MS Windows COFF MIPS R4000 object file")
  goto end
f106:
  // 0	leshort		0x184	MS Windows COFF Alpha object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x184)) { goto f107 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x184\tMS Windows COFF Alpha object file")
  out = append(out, "MS Windows COFF Alpha object file")
  goto end
f107:
  // 0	leshort		0x268	MS Windows COFF Motorola 68000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x268)) { goto f108 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x268\tMS Windows COFF Motorola 68000 object file")
  out = append(out, "MS Windows COFF Motorola 68000 object file")
  goto end
f108:
  // 0	leshort		0x1f0	MS Windows COFF PowerPC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1f0)) { goto f109 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x1f0\tMS Windows COFF PowerPC object file")
  out = append(out, "MS Windows COFF PowerPC object file")
  goto end
f109:
  // 0	leshort		0x290	MS Windows COFF PA-RISC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x290)) { goto f110 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x290\tMS Windows COFF PA-RISC object file")
  out = append(out, "MS Windows COFF PA-RISC object file")
  goto end
f110:
  // 0	string/b	MZ
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f111 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMZ")
  // >0x18	leshort <0x40 MS-DOS executable
  off = pageOff + 0x18
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) < 0x40)) { goto f112 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">0x18\tleshort <0x40 MS-DOS executable")
  out = append(out, "MS-DOS executable")
  goto s111
f112:
  // >0x18  leshort >0x3f
  off = pageOff + 0x18
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x3f)) { goto f113 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">0x18  leshort >0x3f")
  // >>(0x3c.l) string PE\0\0 PE
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f114 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x45, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f114 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l) string PE\\0\\0 PE")
  out = append(out, "PE")
  // >>>(0x3c.l+24)	leshort		0x010b	\b32 executable
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f115 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x10b)) { goto f115 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x010b\t\\b32 executable")
  out = append(out, "\\b32 executable")
  goto s114
f115:
  // >>>(0x3c.l+24)	leshort		0x020b	\b32+ executable
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f116 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x20b)) { goto f116 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x020b\t\\b32+ executable")
  out = append(out, "\\b32+ executable")
  goto s114
f116:
  // >>>(0x3c.l+24)	leshort		0x0107	ROM image
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f117 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x107)) { goto f117 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x0107\tROM image")
  out = append(out, "ROM image")
  goto s114
f117:
  // >>>(0x3c.l+24)	default		x	Unknown PE signature
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f118 }
    off = i64(ra)
    off = off + 0x18
  }
  // uh oh unhandled kind default
  goto f118
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tdefault\t\tx\tUnknown PE signature")
  out = append(out, "Unknown PE signature")
  // >>>>&0 		leshort		x	0x%x
  off = pageOff + gof + 0x0
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>&0 \t\tleshort\t\tx\t0x%x")
  out = append(out, "0x%x")
  goto s118
s118:
  goto s114
f118:
  // >>>(0x3c.l+22)	leshort&0x2000	>0	(DLL)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f120 }
    off = i64(ra)
    off = off + 0x16
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0x2000 > 0x0)) { goto f120 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+22)\tleshort&0x2000\t>0\t(DLL)")
  out = append(out, "(DLL)")
  goto s114
f120:
  // >>>(0x3c.l+92)	leshort		1	(native)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f121 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f121 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t1\t(native)")
  out = append(out, "(native)")
  goto s114
f121:
  // >>>(0x3c.l+92)	leshort		2	(GUI)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f122 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f122 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t2\t(GUI)")
  out = append(out, "(GUI)")
  goto s114
f122:
  // >>>(0x3c.l+92)	leshort		3	(console)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f123 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f123 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t3\t(console)")
  out = append(out, "(console)")
  goto s114
f123:
  // >>>(0x3c.l+92)	leshort		7	(POSIX)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f124 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f124 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t7\t(POSIX)")
  out = append(out, "(POSIX)")
  goto s114
f124:
  // >>>(0x3c.l+92)	leshort		9	(Windows CE)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f125 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f125 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t9\t(Windows CE)")
  out = append(out, "(Windows CE)")
  goto s114
f125:
  // >>>(0x3c.l+92)	leshort		10	(EFI application)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f126 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f126 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t10\t(EFI application)")
  out = append(out, "(EFI application)")
  goto s114
f126:
  // >>>(0x3c.l+92)	leshort		11	(EFI boot service driver)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f127 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f127 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t11\t(EFI boot service driver)")
  out = append(out, "(EFI boot service driver)")
  goto s114
f127:
  // >>>(0x3c.l+92)	leshort		12	(EFI runtime driver)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f128 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f128 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t12\t(EFI runtime driver)")
  out = append(out, "(EFI runtime driver)")
  goto s114
f128:
  // >>>(0x3c.l+92)	leshort		13	(EFI ROM)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f129 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xd)) { goto f129 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t13\t(EFI ROM)")
  out = append(out, "(EFI ROM)")
  goto s114
f129:
  // >>>(0x3c.l+92)	leshort		14	(XBOX)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f130 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xe)) { goto f130 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t14\t(XBOX)")
  out = append(out, "(XBOX)")
  goto s114
f130:
  // >>>(0x3c.l+92)	leshort		15	(Windows boot application)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f131 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xf)) { goto f131 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t15\t(Windows boot application)")
  out = append(out, "(Windows boot application)")
  goto s114
f131:
  // >>>(0x3c.l+92)	default		x	(Unknown subsystem
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f132 }
    off = i64(ra)
    off = off + 0x5c
  }
  // uh oh unhandled kind default
  goto f132
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tdefault\t\tx\t(Unknown subsystem")
  out = append(out, "(Unknown subsystem")
  // >>>>&0		leshort		x	0x%x)
  off = pageOff + gof + 0x0
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>&0\t\tleshort\t\tx\t0x%x)")
  out = append(out, "0x%x)")
  goto s132
s132:
  goto s114
f132:
  // >>>(0x3c.l+4)	leshort		0x14c	Intel 80386
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f134 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x14c)) { goto f134 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x14c\tIntel 80386")
  out = append(out, "Intel 80386")
  goto s114
f134:
  // >>>(0x3c.l+4)	leshort		0x166	MIPS R4000
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f135 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x166)) { goto f135 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x166\tMIPS R4000")
  out = append(out, "MIPS R4000")
  goto s114
f135:
  // >>>(0x3c.l+4)	leshort		0x168	MIPS R10000
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f136 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x168)) { goto f136 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x168\tMIPS R10000")
  out = append(out, "MIPS R10000")
  goto s114
f136:
  // >>>(0x3c.l+4)	leshort		0x184	Alpha
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f137 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x184)) { goto f137 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x184\tAlpha")
  out = append(out, "Alpha")
  goto s114
f137:
  // >>>(0x3c.l+4)	leshort		0x1a2	Hitachi SH3
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f138 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1a2)) { goto f138 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1a2\tHitachi SH3")
  out = append(out, "Hitachi SH3")
  goto s114
f138:
  // >>>(0x3c.l+4)	leshort		0x1a6	Hitachi SH4
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f139 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1a6)) { goto f139 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1a6\tHitachi SH4")
  out = append(out, "Hitachi SH4")
  goto s114
f139:
  // >>>(0x3c.l+4)	leshort		0x1c0	ARM
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f140 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1c0)) { goto f140 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1c0\tARM")
  out = append(out, "ARM")
  goto s114
f140:
  // >>>(0x3c.l+4)	leshort		0x1c2	ARM Thumb
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f141 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1c2)) { goto f141 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1c2\tARM Thumb")
  out = append(out, "ARM Thumb")
  goto s114
f141:
  // >>>(0x3c.l+4)	leshort		0x1c4	ARMv7 Thumb
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f142 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1c4)) { goto f142 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1c4\tARMv7 Thumb")
  out = append(out, "ARMv7 Thumb")
  goto s114
f142:
  // >>>(0x3c.l+4)	leshort		0x1f0	PowerPC
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f143 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1f0)) { goto f143 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1f0\tPowerPC")
  out = append(out, "PowerPC")
  goto s114
f143:
  // >>>(0x3c.l+4)	leshort		0x200	Intel Itanium
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f144 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f144 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x200\tIntel Itanium")
  out = append(out, "Intel Itanium")
  goto s114
f144:
  // >>>(0x3c.l+4)	leshort		0x266	MIPS16
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f145 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x266)) { goto f145 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x266\tMIPS16")
  out = append(out, "MIPS16")
  goto s114
f145:
  // >>>(0x3c.l+4)	leshort		0x268	Motorola 68000
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f146 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x268)) { goto f146 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x268\tMotorola 68000")
  out = append(out, "Motorola 68000")
  goto s114
f146:
  // >>>(0x3c.l+4)	leshort		0x290	PA-RISC
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f147 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x290)) { goto f147 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x290\tPA-RISC")
  out = append(out, "PA-RISC")
  goto s114
f147:
  // >>>(0x3c.l+4)	leshort		0x366	MIPSIV
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f148 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x366)) { goto f148 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x366\tMIPSIV")
  out = append(out, "MIPSIV")
  goto s114
f148:
  // >>>(0x3c.l+4)	leshort		0x466	MIPS16 with FPU
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f149 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x466)) { goto f149 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x466\tMIPS16 with FPU")
  out = append(out, "MIPS16 with FPU")
  goto s114
f149:
  // >>>(0x3c.l+4)	leshort		0xebc	EFI byte code
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f150 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xebc)) { goto f150 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0xebc\tEFI byte code")
  out = append(out, "EFI byte code")
  goto s114
f150:
  // >>>(0x3c.l+4)	leshort		0x8664	x86-64
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f151 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8664)) { goto f151 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x8664\tx86-64")
  out = append(out, "x86-64")
  goto s114
f151:
  // >>>(0x3c.l+4)	leshort		0xc0ee	MSIL
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f152 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xc0ee)) { goto f152 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0xc0ee\tMSIL")
  out = append(out, "MSIL")
  goto s114
f152:
  // >>>(0x3c.l+4)	default		x	Unknown processor type
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f153 }
    off = i64(ra)
    off = off + 0x4
  }
  // uh oh unhandled kind default
  goto f153
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tdefault\t\tx\tUnknown processor type")
  out = append(out, "Unknown processor type")
  // >>>>&0		leshort		x	0x%x
  off = pageOff + gof + 0x0
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>&0\t\tleshort\t\tx\t0x%x")
  out = append(out, "0x%x")
  goto s153
s153:
  goto s114
f153:
  // >>>(0x3c.l+22)	leshort&0x0200	>0	(stripped to external PDB)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f155 }
    off = i64(ra)
    off = off + 0x16
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0x200 > 0x0)) { goto f155 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+22)\tleshort&0x0200\t>0\t(stripped to external PDB)")
  out = append(out, "(stripped to external PDB)")
  goto s114
f155:
  // >>>(0x3c.l+22)	leshort&0x1000	>0	system file
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f156 }
    off = i64(ra)
    off = off + 0x16
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0x1000 > 0x0)) { goto f156 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+22)\tleshort&0x1000\t>0\tsystem file")
  out = append(out, "system file")
  goto s114
f156:
  // >>>(0x3c.l+24)	leshort		0x010b
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f157 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x10b)) { goto f157 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x010b")
  // >>>>(0x3c.l+232) lelong	>0	Mono/.Net assembly
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f158 }
    off = i64(ra)
    off = off + 0xe8
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f158 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+232) lelong\t>0\tMono/.Net assembly")
  out = append(out, "Mono/.Net assembly")
  goto s157
f158:
s157:
  goto s114
f157:
  // >>>(0x3c.l+24)	leshort		0x020b
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f159 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x20b)) { goto f159 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x020b")
  // >>>>(0x3c.l+248) lelong	>0	Mono/.Net assembly
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f160 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f160 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+248) lelong\t>0\tMono/.Net assembly")
  out = append(out, "Mono/.Net assembly")
  goto s159
f160:
s159:
  goto s114
f159:
  // >>>(8.s*16)		string		32STUB	\b, 32rtm DOS extender
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f161 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x33, 0x32, 0x53, 0x54, 0x55, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f161 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s*16)\t\tstring\t\t32STUB\t\\b, 32rtm DOS extender")
  out = append(out, "\\b, 32rtm DOS extender")
  goto s114
f161:
  // >>>(8.s*16)		string		!32STUB	\b, for MS Windows
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f162 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x33, 0x32, 0x53, 0x54, 0x55, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f162 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s*16)\t\tstring\t\t!32STUB\t\\b, for MS Windows")
  out = append(out, "\\b, for MS Windows")
  goto s114
f162:
  // >>>(0x3c.l+0xf8)	string		UPX0 \b, UPX compressed
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f163 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f163 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tstring\t\tUPX0 \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s114
f163:
  // >>>(0x3c.l+0xf8)	search/0x140	PEC2 \b, PECompact2 compressed
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f164 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, "PEC2"))
    if ml < 0 { goto f164 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\tPEC2 \\b, PECompact2 compressed")
  out = append(out, "\\b, PECompact2 compressed")
  goto s114
f164:
  // >>>(0x3c.l+0xf8)	search/0x140	UPX2
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f165 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, "UPX2"))
    if ml < 0 { goto f165 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\tUPX2")
  // >>>>(&0x10.l+(-4))	string		PK\3\4 \b, ZIP self-extracting archive (Info-Zip)
  {
    ra, ok := readU32le(tb, (gof + 0x10))
    if !ok { goto f166 }
    rb, ok := readU32le(tb, (gof + 0x10) + -4)
    if !ok { goto f166 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x3, 0x4}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f166 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x10.l+(-4))\tstring\t\tPK\\3\\4 \\b, ZIP self-extracting archive (Info-Zip)")
  out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
  goto s165
f166:
s165:
  goto s114
f165:
  // >>>(0x3c.l+0xf8)	search/0x140	.idata
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f167 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".idata"))
    if ml < 0 { goto f167 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.idata")
  // >>>>(&0xe.l+(-4))	string		PK\3\4 \b, ZIP self-extracting archive (Info-Zip)
  {
    ra, ok := readU32le(tb, (gof + 0xe))
    if !ok { goto f168 }
    rb, ok := readU32le(tb, (gof + 0xe) + -4)
    if !ok { goto f168 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x3, 0x4}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f168 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0xe.l+(-4))\tstring\t\tPK\\3\\4 \\b, ZIP self-extracting archive (Info-Zip)")
  out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
  goto s167
f168:
  // >>>>(&0xe.l+(-4))	string		ZZ0 \b, ZZip self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xe))
    if !ok { goto f169 }
    rb, ok := readU32le(tb, (gof + 0xe) + -4)
    if !ok { goto f169 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x5a, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f169 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0xe.l+(-4))\tstring\t\tZZ0 \\b, ZZip self-extracting archive")
  out = append(out, "\\b, ZZip self-extracting archive")
  goto s167
f169:
  // >>>>(&0xe.l+(-4))	string		ZZ1 \b, ZZip self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xe))
    if !ok { goto f170 }
    rb, ok := readU32le(tb, (gof + 0xe) + -4)
    if !ok { goto f170 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x5a, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f170 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0xe.l+(-4))\tstring\t\tZZ1 \\b, ZZip self-extracting archive")
  out = append(out, "\\b, ZZip self-extracting archive")
  goto s167
f170:
s167:
  goto s114
f167:
  // >>>(0x3c.l+0xf8)	search/0x140	.rsrc
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f171 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".rsrc"))
    if ml < 0 { goto f171 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.rsrc")
  // >>>>(&0x0f.l+(-4))	string		a\\\4\5 \b, WinHKI self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xf))
    if !ok { goto f172 }
    rb, ok := readU32le(tb, (gof + 0xf) + -4)
    if !ok { goto f172 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x61, 0x5c, 0x4, 0x5}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f172 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tstring\t\ta\\\\\\4\\5 \\b, WinHKI self-extracting archive")
  out = append(out, "\\b, WinHKI self-extracting archive")
  goto s171
f172:
  // >>>>(&0x0f.l+(-4))	string		Rar! \b, RAR self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xf))
    if !ok { goto f173 }
    rb, ok := readU32le(tb, (gof + 0xf) + -4)
    if !ok { goto f173 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x61, 0x72, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f173 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tstring\t\tRar! \\b, RAR self-extracting archive")
  out = append(out, "\\b, RAR self-extracting archive")
  goto s171
f173:
  // >>>>(&0x0f.l+(-4))	search/0x3000	MSCF \b, InstallShield self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xf))
    if !ok { goto f174 }
    rb, ok := readU32le(tb, (gof + 0xf) + -4)
    if !ok { goto f174 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x3000, "MSCF"))
    if ml < 0 { goto f174 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tsearch/0x3000\tMSCF \\b, InstallShield self-extracting archive")
  out = append(out, "\\b, InstallShield self-extracting archive")
  goto s171
f174:
  // >>>>(&0x0f.l+(-4))	search/32	Nullsoft \b, Nullsoft Installer self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xf))
    if !ok { goto f175 }
    rb, ok := readU32le(tb, (gof + 0xf) + -4)
    if !ok { goto f175 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x20, "Nullsoft"))
    if ml < 0 { goto f175 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tsearch/32\tNullsoft \\b, Nullsoft Installer self-extracting archive")
  out = append(out, "\\b, Nullsoft Installer self-extracting archive")
  goto s171
f175:
s171:
  goto s114
f171:
  // >>>(0x3c.l+0xf8)	search/0x140	.data
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f176 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".data"))
    if ml < 0 { goto f176 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.data")
  // >>>>(&0x0f.l)		string		WEXTRACT \b, MS CAB-Installer self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0xf))
    if !ok { goto f177 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x45, 0x58, 0x54, 0x52, 0x41, 0x43, 0x54}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f177 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l)\t\tstring\t\tWEXTRACT \\b, MS CAB-Installer self-extracting archive")
  out = append(out, "\\b, MS CAB-Installer self-extracting archive")
  goto s176
f177:
s176:
  goto s114
f176:
  // >>>(0x3c.l+0xf8)	search/0x140	.petite\0 \b, Petite compressed
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f178 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".petite\x00"))
    if ml < 0 { goto f178 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.petite\\0 \\b, Petite compressed")
  out = append(out, "\\b, Petite compressed")
  // >>>>(0x3c.l+0xf7)	byte		x
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f179 }
    off = i64(ra)
    off = off + 0xf7
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+0xf7)\tbyte\t\tx")
  // >>>>>(&0x104.l+(-4))	string		=!sfx! \b, ACE self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0x104))
    if !ok { goto f180 }
    rb, ok := readU32le(tb, (gof + 0x104) + -4)
    if !ok { goto f180 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x73, 0x66, 0x78, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f180 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>(&0x104.l+(-4))\tstring\t\t=!sfx! \\b, ACE self-extracting archive")
  out = append(out, "\\b, ACE self-extracting archive")
  goto s179
f180:
s179:
  goto s178
f179:
s178:
  goto s114
f178:
  // >>>(0x3c.l+0xf8)	search/0x140	.WISE \b, WISE installer self-extracting archive
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f181 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".WISE"))
    if ml < 0 { goto f181 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.WISE \\b, WISE installer self-extracting archive")
  out = append(out, "\\b, WISE installer self-extracting archive")
  goto s114
f181:
  // >>>(0x3c.l+0xf8)	search/0x140	.dz\0\0\0 \b, Dzip self-extracting archive
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f182 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".dz\x00\x00\x00"))
    if ml < 0 { goto f182 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.dz\\0\\0\\0 \\b, Dzip self-extracting archive")
  out = append(out, "\\b, Dzip self-extracting archive")
  goto s114
f182:
  // >>>&(0x3c.l+0xf8)	search/0x100	_winzip_ \b, ZIP self-extracting archive (WinZip)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f183 }
    off = i64(ra)
    off = off + 0xf8
    off += gof
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "_winzip_"))
    if ml < 0 { goto f183 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>&(0x3c.l+0xf8)\tsearch/0x100\t_winzip_ \\b, ZIP self-extracting archive (WinZip)")
  out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
  goto s114
f183:
  // >>>&(0x3c.l+0xf8)	search/0x100	SharedD \b, Microsoft Installer self-extracting archive
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f184 }
    off = i64(ra)
    off = off + 0xf8
    off += gof
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "SharedD"))
    if ml < 0 { goto f184 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>&(0x3c.l+0xf8)\tsearch/0x100\tSharedD \\b, Microsoft Installer self-extracting archive")
  out = append(out, "\\b, Microsoft Installer self-extracting archive")
  goto s114
f184:
  // >>>0x30			string		Inno \b, InnoSetup self-extracting archive
  off = pageOff + 0x30
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x6e, 0x6e, 0x6f}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f185 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>0x30\t\t\tstring\t\tInno \\b, InnoSetup self-extracting archive")
  out = append(out, "\\b, InnoSetup self-extracting archive")
  goto s114
f185:
s114:
  goto s113
f114:
  // >>(0x3c.l) string !PE\0\0 MS-DOS executable
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f186 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x45, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f186 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l) string !PE\\0\\0 MS-DOS executable")
  out = append(out, "MS-DOS executable")
  goto s113
f186:
  // >>(0x3c.l)		string		NE \b, NE
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f187 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f187 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tNE \\b, NE")
  out = append(out, "\\b, NE")
  // >>>(0x3c.l+0x36)	byte		1 for OS/2 1.x
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f188 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f188 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t1 for OS/2 1.x")
  out = append(out, "for OS/2 1.x")
  goto s187
f188:
  // >>>(0x3c.l+0x36)	byte		2 for MS Windows 3.x
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f189 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f189 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t2 for MS Windows 3.x")
  out = append(out, "for MS Windows 3.x")
  goto s187
f189:
  // >>>(0x3c.l+0x36)	byte		3 for MS-DOS
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f190 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f190 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t3 for MS-DOS")
  out = append(out, "for MS-DOS")
  goto s187
f190:
  // >>>(0x3c.l+0x36)	byte		4 for Windows 386
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f191 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f191 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t4 for Windows 386")
  out = append(out, "for Windows 386")
  goto s187
f191:
  // >>>(0x3c.l+0x36)	byte		5 for Borland Operating System Services
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f192 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f192 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t5 for Borland Operating System Services")
  out = append(out, "for Borland Operating System Services")
  goto s187
f192:
  // >>>(0x3c.l+0x36)	default		x
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f193 }
    off = i64(ra)
    off = off + 0x36
  }
  // uh oh unhandled kind default
  goto f193
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tdefault\t\tx")
  // >>>>(0x3c.l+0x36)	byte		x (unknown OS %x)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f194 }
    off = i64(ra)
    off = off + 0x36
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+0x36)\tbyte\t\tx (unknown OS %x)")
  out = append(out, "(unknown OS %x)")
  goto s193
f194:
s193:
  goto s187
f193:
  // >>>(0x3c.l+0x36)	byte		0x81 for MS-DOS, Phar Lap DOS extender
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f195 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x81)) { goto f195 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t0x81 for MS-DOS, Phar Lap DOS extender")
  out = append(out, "for MS-DOS, Phar Lap DOS extender")
  goto s187
f195:
  // >>>(0x3c.l+0x0c)	leshort&0x8003	0x8002 (DLL)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f196 }
    off = i64(ra)
    off = off + 0xc
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8003 == 0x8002)) { goto f196 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0c)\tleshort&0x8003\t0x8002 (DLL)")
  out = append(out, "(DLL)")
  goto s187
f196:
  // >>>(0x3c.l+0x0c)	leshort&0x8003	0x8001 (driver)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f197 }
    off = i64(ra)
    off = off + 0xc
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8003 == 0x8001)) { goto f197 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0c)\tleshort&0x8003\t0x8001 (driver)")
  out = append(out, "(driver)")
  goto s187
f197:
  // >>>&(&0x24.s-1)		string		ARJSFX \b, ARJ self-extracting archive
  {
    ra, ok := readU16le(tb, (gof + 0x24))
    if !ok { goto f198 }
    off = i64(ra)
    off = off * 0x1
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x41, 0x52, 0x4a, 0x53, 0x46, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f198 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&(&0x24.s-1)\t\tstring\t\tARJSFX \\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s187
f198:
  // >>>(0x3c.l+0x70)	search/0x80	WinZip(R)\ Self-Extractor \b, ZIP self-extracting archive (WinZip)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f199 }
    off = i64(ra)
    off = off + 0x70
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x80, "WinZip(R) Self-Extractor"))
    if ml < 0 { goto f199 }
    gof = off + ml + 0x18
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x70)\tsearch/0x80\tWinZip(R)\\ Self-Extractor \\b, ZIP self-extracting archive (WinZip)")
  out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
  goto s187
f199:
s187:
  goto s113
f187:
  // >>(0x3c.l)		string		LX\0\0 \b, LX
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f200 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x58, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f200 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tLX\\0\\0 \\b, LX")
  out = append(out, "\\b, LX")
  // >>>(0x3c.l+0x0a)	leshort		<1 (unknown OS)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f201 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) < 0x1)) { goto f201 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t<1 (unknown OS)")
  out = append(out, "(unknown OS)")
  goto s200
f201:
  // >>>(0x3c.l+0x0a)	leshort		1 for OS/2
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f202 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f202 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t1 for OS/2")
  out = append(out, "for OS/2")
  goto s200
f202:
  // >>>(0x3c.l+0x0a)	leshort		2 for MS Windows
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f203 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f203 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t2 for MS Windows")
  out = append(out, "for MS Windows")
  goto s200
f203:
  // >>>(0x3c.l+0x0a)	leshort		3 for DOS
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f204 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f204 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t3 for DOS")
  out = append(out, "for DOS")
  goto s200
f204:
  // >>>(0x3c.l+0x0a)	leshort		>3 (unknown OS)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f205 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x3)) { goto f205 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t>3 (unknown OS)")
  out = append(out, "(unknown OS)")
  goto s200
f205:
  // >>>(0x3c.l+0x10)	lelong&0x28000	=0x8000 (DLL)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f206 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x28000 == 0x8000)) { goto f206 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x28000\t=0x8000 (DLL)")
  out = append(out, "(DLL)")
  goto s200
f206:
  // >>>(0x3c.l+0x10)	lelong&0x20000	>0 (device driver)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f207 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0x20000 > 0x0)) { goto f207 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x20000\t>0 (device driver)")
  out = append(out, "(device driver)")
  goto s200
f207:
  // >>>(0x3c.l+0x10)	lelong&0x300	0x300 (GUI)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f208 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x300 == 0x300)) { goto f208 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x300\t0x300 (GUI)")
  out = append(out, "(GUI)")
  goto s200
f208:
  // >>>(0x3c.l+0x10)	lelong&0x28300	<0x300 (console)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f209 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0x28300 < 0x300)) { goto f209 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x28300\t<0x300 (console)")
  out = append(out, "(console)")
  goto s200
f209:
  // >>>(0x3c.l+0x08)	leshort		1 i80286
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f210 }
    off = i64(ra)
    off = off + 0x8
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f210 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x08)\tleshort\t\t1 i80286")
  out = append(out, "i80286")
  goto s200
f210:
  // >>>(0x3c.l+0x08)	leshort		2 i80386
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f211 }
    off = i64(ra)
    off = off + 0x8
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f211 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x08)\tleshort\t\t2 i80386")
  out = append(out, "i80386")
  goto s200
f211:
  // >>>(0x3c.l+0x08)	leshort		3 i80486
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f212 }
    off = i64(ra)
    off = off + 0x8
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f212 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x08)\tleshort\t\t3 i80486")
  out = append(out, "i80486")
  goto s200
f212:
  // >>>(8.s*16)		string		emx \b, emx
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f213 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x65, 0x6d, 0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f213 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s*16)\t\tstring\t\temx \\b, emx")
  out = append(out, "\\b, emx")
  // >>>>&1			string		x %s
  off = pageOff + gof + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f214 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&1\t\t\tstring\t\tx %s")
  out = append(out, "%s")
  goto s213
f214:
s213:
  goto s200
f213:
  // >>>&(&0x54.l-3)		string		arjsfx \b, ARJ self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0x54))
    if !ok { goto f215 }
    off = i64(ra)
    off = off * 0x3
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x61, 0x72, 0x6a, 0x73, 0x66, 0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f215 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&(&0x54.l-3)\t\tstring\t\tarjsfx \\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s200
f215:
s200:
  goto s113
f200:
  // >>(0x3c.l)		string		W3 \b, W3 for MS Windows
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f216 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x33}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f216 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tW3 \\b, W3 for MS Windows")
  out = append(out, "\\b, W3 for MS Windows")
  goto s113
f216:
  // >>(0x3c.l)		string		LE\0\0 \b, LE executable
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f217 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x45, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f217 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tLE\\0\\0 \\b, LE executable")
  out = append(out, "\\b, LE executable")
  // >>>(0x3c.l+0x0a)	leshort		1
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f218 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f218 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t1")
  // >>>>0x240		search/0x100	DOS/4G for MS-DOS, DOS4GW DOS extender
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "DOS/4G"))
    if ml < 0 { goto f219 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x240\t\tsearch/0x100\tDOS/4G for MS-DOS, DOS4GW DOS extender")
  out = append(out, "for MS-DOS, DOS4GW DOS extender")
  goto s218
f219:
  // >>>>0x240		search/0x200	WATCOM\ C/C++ for MS-DOS, DOS4GW DOS extender
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x200, "WATCOM C/C++"))
    if ml < 0 { goto f220 }
    gof = off + ml + 0xc
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x240\t\tsearch/0x200\tWATCOM\\ C/C++ for MS-DOS, DOS4GW DOS extender")
  out = append(out, "for MS-DOS, DOS4GW DOS extender")
  goto s218
f220:
  // >>>>0x440		search/0x100	CauseWay\ DOS\ Extender for MS-DOS, CauseWay DOS extender
  off = pageOff + 0x440
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "CauseWay DOS Extender"))
    if ml < 0 { goto f221 }
    gof = off + ml + 0x15
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x440\t\tsearch/0x100\tCauseWay\\ DOS\\ Extender for MS-DOS, CauseWay DOS extender")
  out = append(out, "for MS-DOS, CauseWay DOS extender")
  goto s218
f221:
  // >>>>0x40		search/0x40	PMODE/W for MS-DOS, PMODE/W DOS extender
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x40, "PMODE/W"))
    if ml < 0 { goto f222 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x40\tPMODE/W for MS-DOS, PMODE/W DOS extender")
  out = append(out, "for MS-DOS, PMODE/W DOS extender")
  goto s218
f222:
  // >>>>0x40		search/0x40	STUB/32A for MS-DOS, DOS/32A DOS extender (stub)
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x40, "STUB/32A"))
    if ml < 0 { goto f223 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x40\tSTUB/32A for MS-DOS, DOS/32A DOS extender (stub)")
  out = append(out, "for MS-DOS, DOS/32A DOS extender (stub)")
  goto s218
f223:
  // >>>>0x40		search/0x80	STUB/32C for MS-DOS, DOS/32A DOS extender (configurable stub)
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x80, "STUB/32C"))
    if ml < 0 { goto f224 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x80\tSTUB/32C for MS-DOS, DOS/32A DOS extender (configurable stub)")
  out = append(out, "for MS-DOS, DOS/32A DOS extender (configurable stub)")
  goto s218
f224:
  // >>>>0x40		search/0x80	DOS/32A for MS-DOS, DOS/32A DOS extender (embedded)
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x80, "DOS/32A"))
    if ml < 0 { goto f225 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x80\tDOS/32A for MS-DOS, DOS/32A DOS extender (embedded)")
  out = append(out, "for MS-DOS, DOS/32A DOS extender (embedded)")
  goto s218
f225:
  // >>>>&0x24		lelong		<0x50
  off = pageOff + gof + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) < 0x50)) { goto f226 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>&0x24\t\tlelong\t\t<0x50")
  // >>>>>(&0x4c.l)		string		\xfc\xb8WATCOM
  {
    ra, ok := readU32le(tb, (gof + 0x4c))
    if !ok { goto f227 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0xb8, 0x57, 0x41, 0x54, 0x43, 0x4f, 0x4d}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f227 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>(&0x4c.l)\t\tstring\t\t\\xfc\\xb8WATCOM")
  // >>>>>>&0		search/8	3\xdbf\xb9 \b, 32Lite compressed
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x8, "3\xdbf\xb9"))
    if ml < 0 { goto f228 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>>>>&0\t\tsearch/8\t3\\xdbf\\xb9 \\b, 32Lite compressed")
  out = append(out, "\\b, 32Lite compressed")
  goto s227
f228:
s227:
  goto s226
f227:
s226:
  goto s218
f226:
s218:
  goto s217
f218:
  // >>>(0x3c.l+0x0a)	leshort		2 for MS Windows
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f229 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f229 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t2 for MS Windows")
  out = append(out, "for MS Windows")
  goto s217
f229:
  // >>>(0x3c.l+0x0a)	leshort		3 for DOS
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f230 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f230 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t3 for DOS")
  out = append(out, "for DOS")
  goto s217
f230:
  // >>>(0x3c.l+0x0a)	leshort		4 for MS Windows (VxD)
  {
    ra, ok := readU32le(tb, 0x3c)
    if !ok { goto f231 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f231 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t4 for MS Windows (VxD)")
  out = append(out, "for MS Windows (VxD)")
  goto s217
f231:
  // >>>(&0x7c.l+0x26)	string		UPX \b, UPX compressed
  {
    ra, ok := readU32le(tb, (gof + 0x7c))
    if !ok { goto f232 }
    off = i64(ra)
    off = off + 0x26
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f232 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(&0x7c.l+0x26)\tstring\t\tUPX \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s217
f232:
  // >>>&(&0x54.l-3)		string		UNACE \b, ACE self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0x54))
    if !ok { goto f233 }
    off = i64(ra)
    off = off * 0x3
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x4e, 0x41, 0x43, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f233 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&(&0x54.l-3)\t\tstring\t\tUNACE \\b, ACE self-extracting archive")
  out = append(out, "\\b, ACE self-extracting archive")
  goto s217
f233:
s217:
  goto s113
f217:
  // >>0x3c		lelong	>0x20000000
  off = pageOff + 0x3c
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x20000000)) { goto f234 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0x3c\t\tlelong\t>0x20000000")
  // >>>(4.s*512)	leshort !0x014c \b, MZ for MS-DOS
  {
    ra, ok := readU16le(tb, 0x4)
    if !ok { goto f235 }
    off = i64(ra)
    off = off * 0x200
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) != 0x14c)) { goto f235 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(4.s*512)\tleshort !0x014c \\b, MZ for MS-DOS")
  out = append(out, "\\b, MZ for MS-DOS")
  goto s234
f235:
s234:
  goto s113
f234:
s113:
  goto s111
f113:
  // >2		long	!0
  off = pageOff + 0x2
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f236 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">2\t\tlong\t!0")
  // >>0x18		leshort <0x40
  off = pageOff + 0x18
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) < 0x40)) { goto f237 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>0x18\t\tleshort <0x40")
  // >>>(4.s*512)	leshort !0x014c
  {
    ra, ok := readU16le(tb, 0x4)
    if !ok { goto f238 }
    off = i64(ra)
    off = off * 0x200
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) != 0x14c)) { goto f238 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(4.s*512)\tleshort !0x014c")
  // >>>>&(2.s-514)	string	!LE
  {
    ra, ok := readU16le(tb, 0x2)
    if !ok { goto f239 }
    off = i64(ra)
    off = off * 0x202
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f239 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&(2.s-514)\tstring\t!LE")
  // >>>>>&-2	string	!BW \b, MZ for MS-DOS
  off = pageOff + gof + -2
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x57}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f240 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>&-2\tstring\t!BW \\b, MZ for MS-DOS")
  out = append(out, "\\b, MZ for MS-DOS")
  goto s239
f240:
s239:
  goto s238
f239:
  // >>>>&(2.s-514)	string	LE \b, LE
  {
    ra, ok := readU16le(tb, 0x2)
    if !ok { goto f241 }
    off = i64(ra)
    off = off * 0x202
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f241 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&(2.s-514)\tstring\tLE \\b, LE")
  out = append(out, "\\b, LE")
  // >>>>>0x240	search/0x100	DOS/4G for MS-DOS, DOS4GW DOS extender
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "DOS/4G"))
    if ml < 0 { goto f242 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x240\tsearch/0x100\tDOS/4G for MS-DOS, DOS4GW DOS extender")
  out = append(out, "for MS-DOS, DOS4GW DOS extender")
  goto s241
f242:
s241:
  goto s238
f241:
  // >>>>&(2.s-514)	string	BW
  {
    ra, ok := readU16le(tb, 0x2)
    if !ok { goto f243 }
    off = i64(ra)
    off = off * 0x202
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x57}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f243 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&(2.s-514)\tstring\tBW")
  // >>>>>0x240	search/0x100	DOS/4G	\b, LE for MS-DOS, DOS4GW DOS extender (embedded)
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "DOS/4G"))
    if ml < 0 { goto f244 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x240\tsearch/0x100\tDOS/4G\t\\b, LE for MS-DOS, DOS4GW DOS extender (embedded)")
  out = append(out, "\\b, LE for MS-DOS, DOS4GW DOS extender (embedded)")
  goto s243
f244:
  // >>>>>0x240	search/0x100	!DOS/4G	\b, BW collection for MS-DOS
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "!DOS/4G"))
    if ml < 0 { goto f245 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x240\tsearch/0x100\t!DOS/4G\t\\b, BW collection for MS-DOS")
  out = append(out, "\\b, BW collection for MS-DOS")
  goto s243
f245:
s243:
  goto s238
f243:
s238:
  goto s237
f238:
s237:
  goto s236
f237:
s236:
  goto s111
f236:
  // >(4.s*512)	leshort		0x014c \b, COFF
  {
    ra, ok := readU16le(tb, 0x4)
    if !ok { goto f246 }
    off = i64(ra)
    off = off * 0x200
  }
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x14c)) { goto f246 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">(4.s*512)\tleshort\t\t0x014c \\b, COFF")
  out = append(out, "\\b, COFF")
  // >>(8.s*16)	string		go32stub for MS-DOS, DJGPP go32 DOS extender
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f247 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x67, 0x6f, 0x33, 0x32, 0x73, 0x74, 0x75, 0x62}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f247 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(8.s*16)\tstring\t\tgo32stub for MS-DOS, DJGPP go32 DOS extender")
  out = append(out, "for MS-DOS, DJGPP go32 DOS extender")
  goto s246
f247:
  // >>(8.s*16)	string		emx
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f248 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x65, 0x6d, 0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f248 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(8.s*16)\tstring\t\temx")
  // >>>&1		string		x for DOS, Win or OS/2, emx %s
  off = pageOff + gof + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f249 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&1\t\tstring\t\tx for DOS, Win or OS/2, emx %s")
  out = append(out, "for DOS, Win or OS/2, emx %s")
  goto s248
f249:
s248:
  goto s246
f248:
  // >>&(&0x42.l-3)	byte		x
  {
    ra, ok := readU32le(tb, (gof + 0x42))
    if !ok { goto f250 }
    off = i64(ra)
    off = off * 0x3
    off += gof
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&(&0x42.l-3)\tbyte\t\tx")
  // >>>&0x26	string		UPX \b, UPX compressed
  off = pageOff + gof + 0x26
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f251 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0x26\tstring\t\tUPX \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s250
f251:
s250:
  goto s246
f250:
  // >>&0x2c		search/0xa0	.text
  off = pageOff + gof + 0x2c
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xa0, ".text"))
    if ml < 0 { goto f252 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>&0x2c\t\tsearch/0xa0\t.text")
  // >>>&0x0b	lelong		<0x2000
  off = pageOff + gof + 0xb
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) < 0x2000)) { goto f253 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>&0x0b\tlelong\t\t<0x2000")
  // >>>>&0		lelong		>0x6000 \b, 32lite compressed
  off = pageOff + gof + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x6000)) { goto f254 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>&0\t\tlelong\t\t>0x6000 \\b, 32lite compressed")
  out = append(out, "\\b, 32lite compressed")
  goto s253
f254:
s253:
  goto s252
f253:
s252:
  goto s246
f252:
s246:
  goto s111
f246:
  // >(8.s*16) string $WdX \b, WDos/X DOS extender
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f255 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x57, 0x64, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f255 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">(8.s*16) string $WdX \\b, WDos/X DOS extender")
  out = append(out, "\\b, WDos/X DOS extender")
  goto s111
f255:
  // >0x35	string	\x8e\xc0\xb9\x08\x00\xf3\xa5\x4a\x75\xeb\x8e\xc3\x8e\xd8\x33\xff\xbe\x30\x00\x05 \b, aPack compressed
  off = pageOff + 0x35
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x8e, 0xc0, 0xb9, 0x8, 0x0, 0xf3, 0xa5, 0x4a, 0x75, 0xeb, 0x8e, 0xc3, 0x8e, 0xd8, 0x33, 0xff, 0xbe, 0x30, 0x0, 0x5}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f256 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x35\tstring\t\\x8e\\xc0\\xb9\\x08\\x00\\xf3\\xa5\\x4a\\x75\\xeb\\x8e\\xc3\\x8e\\xd8\\x33\\xff\\xbe\\x30\\x00\\x05 \\b, aPack compressed")
  out = append(out, "\\b, aPack compressed")
  goto s111
f256:
  // >0xe7	string	LH/2\ 	Self-Extract \b, %s
  off = pageOff + 0xe7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x48, 0x2f, 0x32, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f257 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0xe7\tstring\tLH/2\\ \tSelf-Extract \\b, %s")
  out = append(out, "Self-Extract \\b, %s")
  goto s111
f257:
  // >0x1c	string	UC2X	\b, UCEXE compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x43, 0x32, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f258 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tUC2X\t\\b, UCEXE compressed")
  out = append(out, "\\b, UCEXE compressed")
  goto s111
f258:
  // >0x1c	string	WWP\ 	\b, WWPACK compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x57, 0x50, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f259 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tWWP\\ \t\\b, WWPACK compressed")
  out = append(out, "\\b, WWPACK compressed")
  goto s111
f259:
  // >0x1c	string	RJSX 	\b, ARJ self-extracting archive
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x4a, 0x53, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f260 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tRJSX \t\\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s111
f260:
  // >0x1c	string	diet 	\b, diet compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x64, 0x69, 0x65, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f261 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tdiet \t\\b, diet compressed")
  out = append(out, "\\b, diet compressed")
  goto s111
f261:
  // >0x1c	string	LZ09 	\b, LZEXE v0.90 compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a, 0x30, 0x39}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f262 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tLZ09 \t\\b, LZEXE v0.90 compressed")
  out = append(out, "\\b, LZEXE v0.90 compressed")
  goto s111
f262:
  // >0x1c	string	LZ91 	\b, LZEXE v0.91 compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a, 0x39, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f263 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tLZ91 \t\\b, LZEXE v0.91 compressed")
  out = append(out, "\\b, LZEXE v0.91 compressed")
  goto s111
f263:
  // >0x1c	string	tz 	\b, TinyProg compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x74, 0x7a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f264 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\ttz \t\\b, TinyProg compressed")
  out = append(out, "\\b, TinyProg compressed")
  goto s111
f264:
  // >0x1e	string	Copyright\ 1989-1990\ PKWARE\ Inc.	Self-extracting PKZIP archive
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x31, 0x39, 0x38, 0x39, 0x2d, 0x31, 0x39, 0x39, 0x30, 0x20, 0x50, 0x4b, 0x57, 0x41, 0x52, 0x45, 0x20, 0x49, 0x6e, 0x63, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f265 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1e\tstring\tCopyright\\ 1989-1990\\ PKWARE\\ Inc.\tSelf-extracting PKZIP archive")
  out = append(out, "Self-extracting PKZIP archive")
  goto s111
f265:
  // >0x1e	string	PKLITE\ Copr.	Self-extracting PKZIP archive
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x4c, 0x49, 0x54, 0x45, 0x20, 0x43, 0x6f, 0x70, 0x72, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f266 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1e\tstring\tPKLITE\\ Copr.\tSelf-extracting PKZIP archive")
  out = append(out, "Self-extracting PKZIP archive")
  goto s111
f266:
  // >0x20	search/0xe0	aRJsfX \b, ARJ self-extracting archive
  off = pageOff + 0x20
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xe0, "aRJsfX"))
    if ml < 0 { goto f267 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">0x20\tsearch/0xe0\taRJsfX \\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s111
f267:
  // >0x20	string AIN
  off = pageOff + 0x20
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x41, 0x49, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f268 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x20\tstring AIN")
  // >>0x23	string 2	\b, AIN 2.x compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x32}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f269 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x23\tstring 2\t\\b, AIN 2.x compressed")
  out = append(out, "\\b, AIN 2.x compressed")
  goto s268
f269:
  // >>0x23	string <2	\b, AIN 1.x compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x32}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f270 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x23\tstring <2\t\\b, AIN 1.x compressed")
  out = append(out, "\\b, AIN 1.x compressed")
  goto s268
f270:
  // >>0x23	string >2	\b, AIN 1.x compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x32}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f271 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x23\tstring >2\t\\b, AIN 1.x compressed")
  out = append(out, "\\b, AIN 1.x compressed")
  goto s268
f271:
s268:
  goto s111
f268:
  // >0x24	string	LHa's\ SFX \b, LHa self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x48, 0x61, 0x27, 0x73, 0x20, 0x53, 0x46, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f272 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\tLHa's\\ SFX \\b, LHa self-extracting archive")
  out = append(out, "\\b, LHa self-extracting archive")
  goto s111
f272:
  // >0x24	string	LHA's\ SFX \b, LHa self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x48, 0x41, 0x27, 0x73, 0x20, 0x53, 0x46, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f273 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\tLHA's\\ SFX \\b, LHa self-extracting archive")
  out = append(out, "\\b, LHa self-extracting archive")
  goto s111
f273:
  // >0x24	string	\ $ARX \b, ARX self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x41, 0x52, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f274 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\t\\ $ARX \\b, ARX self-extracting archive")
  out = append(out, "\\b, ARX self-extracting archive")
  goto s111
f274:
  // >0x24	string	\ $LHarc \b, LHarc self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x4c, 0x48, 0x61, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f275 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\t\\ $LHarc \\b, LHarc self-extracting archive")
  out = append(out, "\\b, LHarc self-extracting archive")
  goto s111
f275:
  // >0x20	string	SFX\ by\ LARC \b, LARC self-extracting archive
  off = pageOff + 0x20
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x46, 0x58, 0x20, 0x62, 0x79, 0x20, 0x4c, 0x41, 0x52, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f276 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x20\tstring\tSFX\\ by\\ LARC \\b, LARC self-extracting archive")
  out = append(out, "\\b, LARC self-extracting archive")
  goto s111
f276:
  // >0x40	string aPKG \b, aPackage self-extracting archive
  off = pageOff + 0x40
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x61, 0x50, 0x4b, 0x47}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f277 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x40\tstring aPKG \\b, aPackage self-extracting archive")
  out = append(out, "\\b, aPackage self-extracting archive")
  goto s111
f277:
  // >0x64	string	W\ Collis\0\0 \b, Compack compressed
  off = pageOff + 0x64
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f278 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x64\tstring\tW\\ Collis\\0\\0 \\b, Compack compressed")
  out = append(out, "\\b, Compack compressed")
  goto s111
f278:
  // >0x7a	string		Windows\ self-extracting\ ZIP	\b, ZIP self-extracting archive
  off = pageOff + 0x7a
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x73, 0x65, 0x6c, 0x66, 0x2d, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x5a, 0x49, 0x50}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f279 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x7a\tstring\t\tWindows\\ self-extracting\\ ZIP\t\\b, ZIP self-extracting archive")
  out = append(out, "\\b, ZIP self-extracting archive")
  // >>&0xf4 search/0x140 \x0\x40\x1\x0
  off = pageOff + gof + 0xf4
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, "\x00@\x01\x00"))
    if ml < 0 { goto f280 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>&0xf4 search/0x140 \\x0\\x40\\x1\\x0")
  // >>>(&0.l+(4)) string MSCF \b, WinHKI CAB self-extracting archive
  {
    ra, ok := readU32le(tb, (gof + 0x0))
    if !ok { goto f281 }
    rb, ok := readU32le(tb, (gof + 0x0) + 0x4)
    if !ok { goto f281 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f281 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(&0.l+(4)) string MSCF \\b, WinHKI CAB self-extracting archive")
  out = append(out, "\\b, WinHKI CAB self-extracting archive")
  goto s280
f281:
s280:
  goto s279
f280:
s279:
  goto s111
f279:
  // >1638	string	-lh5- \b, LHa self-extracting archive v2.13S
  off = pageOff + 0x666
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x2d, 0x6c, 0x68, 0x35, 0x2d}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f282 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1638\tstring\t-lh5- \\b, LHa self-extracting archive v2.13S")
  out = append(out, "\\b, LHa self-extracting archive v2.13S")
  goto s111
f282:
  // >0x17888 string Rar! \b, RAR self-extracting archive
  off = pageOff + 0x17888
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x61, 0x72, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f283 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x17888 string Rar! \\b, RAR self-extracting archive")
  out = append(out, "\\b, RAR self-extracting archive")
  goto s111
f283:
  // >(4.s*512)	long	x
  {
    ra, ok := readU16le(tb, 0x4)
    if !ok { goto f284 }
    off = i64(ra)
    off = off * 0x200
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(4.s*512)\tlong\tx")
  // >>&(2.s-517)	byte	x
  {
    ra, ok := readU16le(tb, 0x2)
    if !ok { goto f285 }
    off = i64(ra)
    off = off * 0x205
    off += gof
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&(2.s-517)\tbyte\tx")
  // >>>&0	string		PK\3\4 \b, ZIP self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x3, 0x4}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f286 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\tPK\\3\\4 \\b, ZIP self-extracting archive")
  out = append(out, "\\b, ZIP self-extracting archive")
  goto s285
f286:
  // >>>&0	string		Rar! \b, RAR self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x61, 0x72, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f287 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\tRar! \\b, RAR self-extracting archive")
  out = append(out, "\\b, RAR self-extracting archive")
  goto s285
f287:
  // >>>&0	string		=!\x11 \b, AIN 2.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x11}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f288 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x11 \\b, AIN 2.x self-extracting archive")
  out = append(out, "\\b, AIN 2.x self-extracting archive")
  goto s285
f288:
  // >>>&0	string		=!\x12 \b, AIN 2.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x12}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f289 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x12 \\b, AIN 2.x self-extracting archive")
  out = append(out, "\\b, AIN 2.x self-extracting archive")
  goto s285
f289:
  // >>>&0	string		=!\x17 \b, AIN 1.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x17}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f290 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x17 \\b, AIN 1.x self-extracting archive")
  out = append(out, "\\b, AIN 1.x self-extracting archive")
  goto s285
f290:
  // >>>&0	string		=!\x18 \b, AIN 1.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x18}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f291 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x18 \\b, AIN 1.x self-extracting archive")
  out = append(out, "\\b, AIN 1.x self-extracting archive")
  goto s285
f291:
  // >>>&7	search/400	**ACE** \b, ACE self-extracting archive
  off = pageOff + gof + 0x7
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x190, "**ACE**"))
    if ml < 0 { goto f292 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>&7\tsearch/400\t**ACE** \\b, ACE self-extracting archive")
  out = append(out, "\\b, ACE self-extracting archive")
  goto s285
f292:
  // >>>&0	search/0x480	UC2SFX\ Header \b, UC2 self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x480, "UC2SFX Header"))
    if ml < 0 { goto f293 }
    gof = off + ml + 0xd
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tsearch/0x480\tUC2SFX\\ Header \\b, UC2 self-extracting archive")
  out = append(out, "\\b, UC2 self-extracting archive")
  goto s285
f293:
s285:
  goto s284
f285:
s284:
  goto s111
f284:
  // >(8.s*16)	search/0x20	PKSFX \b, ZIP self-extracting archive (PKZIP)
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f294 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x20, "PKSFX"))
    if ml < 0 { goto f294 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">(8.s*16)\tsearch/0x20\tPKSFX \\b, ZIP self-extracting archive (PKZIP)")
  out = append(out, "\\b, ZIP self-extracting archive (PKZIP)")
  goto s111
f294:
  // >49801	string	\x79\xff\x80\xff\x76\xff	\b, CODEC archive v3.21
  off = pageOff + 0xc289
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x79, 0xff, 0x80, 0xff, 0x76, 0xff}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f295 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">49801\tstring\t\\x79\\xff\\x80\\xff\\x76\\xff\t\\b, CODEC archive v3.21")
  out = append(out, "\\b, CODEC archive v3.21")
  // >>49824 leshort		=1			\b, 1 file
  off = pageOff + 0xc2a0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f296 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>49824 leshort\t\t=1\t\t\t\\b, 1 file")
  out = append(out, "\\b, 1 file")
  goto s295
f296:
  // >>49824 leshort		>1			\b, %u files
  off = pageOff + 0xc2a0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f297 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>49824 leshort\t\t>1\t\t\t\\b, %u files")
  out = append(out, "\\b, %u files")
  goto s295
f297:
s295:
  goto s111
f295:
s111:
  goto end
f111:
  // 0	string/b	KCF		FreeDOS KEYBoard Layout collection
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x43, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f298 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKCF\t\tFreeDOS KEYBoard Layout collection")
  out = append(out, "FreeDOS KEYBoard Layout collection")
  // >3	uleshort	x		\b, version 0x%x
  off = pageOff + 0x3
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">3\tuleshort\tx\t\t\\b, version 0x%x")
  out = append(out, "\\b, version 0x%x")
  goto s298
  // >6	ubyte		>0
  off = pageOff + 0x6
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f300 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">6\tubyte\t\t>0")
  // >>7	string		>\0		\b, author=%-.14s
  off = pageOff + 0x7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f301 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>7\tstring\t\t>\\0\t\t\\b, author=%-.14s")
  out = append(out, "\\b, author=%-.14s")
  goto s300
f301:
  // >>7	search/254	\xff		\b, info=
  off = pageOff + 0x7
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xfe, "\xff"))
    if ml < 0 { goto f302 }
    gof = off + ml + 0x1
  }
  fmt.Printf("matched rule: %s\n", ">>7\tsearch/254\t\\xff\t\t\\b, info=")
  out = append(out, "\\b, info=")
  // >>>&0	string		x		\b%-.15s
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f303 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\tx\t\t\\b%-.15s")
  out = append(out, "\\b%-.15s")
  goto s302
f303:
s302:
  goto s300
f302:
s300:
  goto s298
f300:
s298:
  goto end
f298:
  // 0	string/b	KLF		FreeDOS KEYBoard Layout file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f304 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKLF\t\tFreeDOS KEYBoard Layout file")
  out = append(out, "FreeDOS KEYBoard Layout file")
  // >3	uleshort	x		\b, version 0x%x
  off = pageOff + 0x3
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">3\tuleshort\tx\t\t\\b, version 0x%x")
  out = append(out, "\\b, version 0x%x")
  goto s304
  // >5	ubyte		>0
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f306 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tubyte\t\t>0")
  // >>8	string		x		\b, name=%-.2s
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f307 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>8\tstring\t\tx\t\t\\b, name=%-.2s")
  out = append(out, "\\b, name=%-.2s")
  goto s306
f307:
s306:
  goto s304
f306:
s304:
  goto end
f304:
  // 0	string	\xffKEYB\ \ \ \0\0\0\0
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xff, 0x4b, 0x45, 0x59, 0x42, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f308 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xffKEYB\\ \\ \\ \\0\\0\\0\\0")
  // >12	string	\0\0\0\0`\004\360	MS-DOS KEYBoard Layout file
  off = pageOff + 0xc
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x60, 0x4, 0xf0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f309 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">12\tstring\t\\0\\0\\0\\0`\\004\\360\tMS-DOS KEYBoard Layout file")
  out = append(out, "MS-DOS KEYBoard Layout file")
  goto s308
f309:
s308:
  goto end
f308:
  // 0	ulequad&0x07a0ffffffff		0xffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv)&0x7a0ffffffff == 0xffffffff)) { goto f310 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad&0x07a0ffffffff\t\t0xffffffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s310
s310:
  goto end
f310:
  // 0	ulequad				0x0513c00000000012
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x513c00000000012)) { goto f312 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0513c00000000012")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s312
s312:
  goto end
f312:
  // 0	ulequad				0x32f28000ffff0016
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x32f28000ffff0016)) { goto f314 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x32f28000ffff0016")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s314
s314:
  goto end
f314:
  // 0	ulequad				0x007f00000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x7f00000000ffff)) { goto f316 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x007f00000000ffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s316
s316:
  goto end
f316:
  // 0	ulequad				0x001600000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x1600000000ffff)) { goto f318 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x001600000000ffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s318
s318:
  goto end
f318:
  // 0	ulequad				0x0bf708c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0xbf708c2ffffffff)) { goto f320 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0bf708c2ffffffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s320
s320:
  goto end
f320:
  // 0	ulequad				0x07bd08c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x7bd08c2ffffffff)) { goto f322 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x07bd08c2ffffffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s322
s322:
  goto end
f322:
  // 0	ubyte		0x8c
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x8c)) { goto f324 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0x8c")
  // >4	string			!O====
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4f, 0x3d, 0x3d, 0x3d, 0x3d}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f325 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\t\t!O====")
  // >>5	string			!MAIN
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x41, 0x49, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f326 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>5\tstring\t\t\t!MAIN")
  // >>>4	ubyte			>13	DOS executable (COM, 0x8C-variant)
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0xd)) { goto f327 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>4\tubyte\t\t\t>13\tDOS executable (COM, 0x8C-variant)")
  out = append(out, "DOS executable (COM, 0x8C-variant)")
  goto s326
f327:
s326:
  goto s325
f326:
s325:
  goto s324
f325:
s324:
  goto end
f324:
  // 0	ulelong		0xffff10eb	DR-DOS executable (COM)
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xffff10eb)) { goto f328 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tulelong\t\t0xffff10eb\tDR-DOS executable (COM)")
  out = append(out, "DR-DOS executable (COM)")
  goto end
f328:
  // 0	ubeshort&0xeb8d	>0xeb00
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0xeb8d > 0xeb00)) { goto f329 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tubeshort&0xeb8d\t>0xeb00")
  goto end
f329:
  // 0	        byte	0xeb
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xeb)) { goto f330 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0\t        byte\t0xeb")
  // >1          byte    >-1
  off = pageOff + 0x1
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > -1)) { goto f331 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">1          byte    >-1")
  // >>(1.b+2)   byte    x
  {
    ra, ok := readU8le(tb, 0x1)
    if !ok { goto f332 }
    off = i64(ra)
    off = off + 0x2
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>(1.b+2)   byte    x")
  // >>>0        use msdos-com
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosCom(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>0        use msdos-com")
  goto s332
s332:
  goto s331
f332:
s331:
  goto s330
f331:
s330:
  goto end
f330:
  // 0           byte    0xe9
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xe9)) { goto f334 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0           byte    0xe9")
  // >1          short   >-1
  off = pageOff + 0x1
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > -1)) { goto f335 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">1          short   >-1")
  // >>(1.s+3)   byte    x
  {
    ra, ok := readU16le(tb, 0x1)
    if !ok { goto f336 }
    off = i64(ra)
    off = off + 0x3
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>(1.s+3)   byte    x")
  // >>>0        use msdos-com
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosCom(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>0        use msdos-com")
  goto s336
s336:
  goto s335
f336:
s335:
  goto s334
f335:
  // >1          short   <-259
  off = pageOff + 0x1
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) < -259)) { goto f338 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">1          short   <-259")
  // >>(1,s+65539)   byte    x
  {
    ra, ok := readU16le(tb, 0x1)
    if !ok { goto f339 }
    off = i64(ra)
    off = off + 0x10003
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>(1,s+65539)   byte    x")
  // >>>0        use msdos-com
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosCom(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>0        use msdos-com")
  goto s339
s339:
  goto s338
f339:
s338:
  goto s334
f338:
s334:
  goto end
f334:
  // 0	ubyte		0xb8
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xb8)) { goto f341 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0xb8")
  // >0	string		!\xb8\xc0\x07\x8e
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xb8, 0xc0, 0x7, 0x8e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f342 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0\tstring\t\t!\\xb8\\xc0\\x07\\x8e")
  // >>1	lelong&0xFFFFFFFe 0x21CD4CFe	COM executable (32-bit COMBOOT
  off = pageOff + 0x1
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0x21cd4cfe)) { goto f343 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>1\tlelong&0xFFFFFFFe 0x21CD4CFe\tCOM executable (32-bit COMBOOT")
  out = append(out, "COM executable (32-bit COMBOOT")
  // >>>1	lelong		0x21CD4CFf	\b)
  off = pageOff + 0x1
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x21cd4cff)) { goto f344 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>1\tlelong\t\t0x21CD4CFf\t\\b)")
  out = append(out, "\\b)")
  goto s343
f344:
  // >>>1	lelong		0x21CD4CFe	\b, relocatable)
  off = pageOff + 0x1
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x21cd4cfe)) { goto f345 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>1\tlelong\t\t0x21CD4CFe\t\\b, relocatable)")
  out = append(out, "\\b, relocatable)")
  goto s343
f345:
s343:
  goto s342
f343:
  // >>1	default	x			COM executable for DOS
  off = pageOff + 0x1
  // uh oh unhandled kind default
  goto f346
  fmt.Printf("matched rule: %s\n", ">>1\tdefault\tx\t\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto s342
f346:
s342:
  goto s341
f342:
s341:
  goto end
f341:
  // 0	string/b	\x81\xfc
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x81, 0xfc}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f347 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x81\\xfc")
  // >4	string	\x77\x02\xcd\x20\xb9
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x77, 0x2, 0xcd, 0x20, 0xb9}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f348 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\\x77\\x02\\xcd\\x20\\xb9")
  // >>36	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f349 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>36\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto s348
f349:
s348:
  goto s347
f348:
s347:
  goto end
f347:
  // 252	string Must\ have\ DOS\ version DR-DOS executable (COM)
  off = pageOff + 0xfc
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x75, 0x73, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f350 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "252\tstring Must\\ have\\ DOS\\ version DR-DOS executable (COM)")
  out = append(out, "DR-DOS executable (COM)")
  goto end
f350:
  // 34	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x22
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f351 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "34\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto end
f351:
  // 35	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f352 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "35\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto end
f352:
  // 2	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x2
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f353 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f353:
  // 4	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f354 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "4\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f354:
  // 5	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f355 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "5\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f355:
  // 7	string	\xcd\x21
  off = pageOff + 0x7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f356 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "7\tstring\t\\xcd\\x21")
  // >0	byte	!0xb8			COM executable for DOS
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0xb8)) { goto f357 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tbyte\t!0xb8\t\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto s356
f357:
s356:
  goto end
f356:
  // 10	string	\xcd\x21
  off = pageOff + 0xa
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f358 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "10\tstring\t\\xcd\\x21")
  // >5	string	!\xcd\x21		COM executable for DOS
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f359 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">5\tstring\t!\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto s358
f359:
s358:
  goto end
f358:
  // 13	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0xd
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f360 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "13\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f360:
  // 18	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x12
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f361 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "18\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f361:
  // 23	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x17
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f362 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "23\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f362:
  // 30	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f363 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "30\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f363:
  // 70	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x46
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f364 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "70\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f364:
  // 0x6	search/0xa	\xfc\x57\xf3\xa5\xc3	COM executable for MS-DOS
  off = pageOff + 0x6
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa5\xc3"))
    if ml < 0 { goto f365 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa5\\xc3\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f365:
  // 0x6	search/0xa	\xfc\x57\xf3\xa4\xc3	COM executable for DOS
  off = pageOff + 0x6
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa4\xc3"))
    if ml < 0 { goto f366 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa4\\xc3\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  // >0x18	search/0x10	\x50\xa4\xff\xd5\x73	\b, aPack compressed
  off = pageOff + 0x18
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x10, "P\xa4\xff\xd5s"))
    if ml < 0 { goto f367 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">0x18\tsearch/0x10\t\\x50\\xa4\\xff\\xd5\\x73\t\\b, aPack compressed")
  out = append(out, "\\b, aPack compressed")
  goto s366
f367:
s366:
  goto end
f366:
  // 0x3c	string		W\ Collis\0\0		COM executable for MS-DOS, Compack compressed
  off = pageOff + 0x3c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f368 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0x3c\tstring\t\tW\\ Collis\\0\\0\t\tCOM executable for MS-DOS, Compack compressed")
  out = append(out, "COM executable for MS-DOS, Compack compressed")
  goto end
f368:
  // 0	string/b	LZ		MS-DOS executable (built-in)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f369 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tLZ\t\tMS-DOS executable (built-in)")
  out = append(out, "MS-DOS executable (built-in)")
  goto end
f369:
  // 0	string/b	\320\317\021\340\241\261\032\341AAFB\015\000OM\006\016\053\064\001\001\001\377			AAF legacy file using MS Structured Storage
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x41, 0x41, 0x46, 0x42, 0xd, 0x0, 0x4f, 0x4d, 0x6, 0xe, 0x2b, 0x34, 0x1, 0x1, 0x1, 0xff}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f370 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341AAFB\\015\\000OM\\006\\016\\053\\064\\001\\001\\001\\377\t\t\tAAF legacy file using MS Structured Storage")
  out = append(out, "AAF legacy file using MS Structured Storage")
  // >30	byte	9		(512B sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f371 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t9\t\t(512B sectors)")
  out = append(out, "(512B sectors)")
  goto s370
f371:
  // >30	byte	12		(4kB sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f372 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t12\t\t(4kB sectors)")
  out = append(out, "(4kB sectors)")
  goto s370
f372:
s370:
  goto end
f370:
  // 0	string/b	\320\317\021\340\241\261\032\341\001\002\001\015\000\002\000\000\006\016\053\064\003\002\001\001			AAF file using MS Structured Storage
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x1, 0x2, 0x1, 0xd, 0x0, 0x2, 0x0, 0x0, 0x6, 0xe, 0x2b, 0x34, 0x3, 0x2, 0x1, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f373 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\\001\\002\\001\\015\\000\\002\\000\\000\\006\\016\\053\\064\\003\\002\\001\\001\t\t\tAAF file using MS Structured Storage")
  out = append(out, "AAF file using MS Structured Storage")
  // >30	byte	9		(512B sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f374 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t9\t\t(512B sectors)")
  out = append(out, "(512B sectors)")
  goto s373
f374:
  // >30	byte	12		(4kB sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f375 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t12\t\t(4kB sectors)")
  out = append(out, "(4kB sectors)")
  goto s373
f375:
s373:
  goto end
f373:
  // 2080	string	Microsoft\ Word\ 6.0\ Document	%s
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36, 0x2e, 0x30, 0x20, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f376 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Word\\ 6.0\\ Document\t%s")
  out = append(out, "%s")
  goto end
f376:
  // 2080	string	Documento\ Microsoft\ Word\ 6 Spanish Microsoft Word 6 document data
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f377 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tDocumento\\ Microsoft\\ Word\\ 6 Spanish Microsoft Word 6 document data")
  out = append(out, "Spanish Microsoft Word 6 document data")
  goto end
f377:
  // 2112	string	MSWordDoc			Microsoft Word document data
  off = pageOff + 0x840
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x6f, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f378 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2112\tstring\tMSWordDoc\t\t\tMicrosoft Word document data")
  out = append(out, "Microsoft Word document data")
  goto end
f378:
  // 0	belong	0x31be0000			Microsoft Word Document
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x31be0000)) { goto f379 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x31be0000\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f379:
  // 0	string/b	PO^Q`				Microsoft Word 6.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4f, 0x5e, 0x51, 0x60}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f380 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPO^Q`\t\t\t\tMicrosoft Word 6.0 Document")
  out = append(out, "Microsoft Word 6.0 Document")
  goto end
f380:
  // 4   long        0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f381 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "4   long        0")
  // >0  belong      0xfe320000      Microsoft Word for Macintosh 1.0
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xfe320000)) { goto f382 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe320000      Microsoft Word for Macintosh 1.0")
  out = append(out, "Microsoft Word for Macintosh 1.0")
  goto s381
f382:
  // >0  belong      0xfe340000      Microsoft Word for Macintosh 3.0
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xfe340000)) { goto f383 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe340000      Microsoft Word for Macintosh 3.0")
  out = append(out, "Microsoft Word for Macintosh 3.0")
  goto s381
f383:
  // >0  belong      0xfe37001c      Microsoft Word for Macintosh 4.0
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xfe37001c)) { goto f384 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe37001c      Microsoft Word for Macintosh 4.0")
  out = append(out, "Microsoft Word for Macintosh 4.0")
  goto s381
f384:
  // >0  belong      0xfe370023      Microsoft Word for Macintosh 5.0
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xfe370023)) { goto f385 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe370023      Microsoft Word for Macintosh 5.0")
  out = append(out, "Microsoft Word for Macintosh 5.0")
  goto s381
f385:
s381:
  goto end
f381:
  // 0	string/b	\333\245-\0\0\0			Microsoft Word 2.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f386 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\333\\245-\\0\\0\\0\t\t\tMicrosoft Word 2.0 Document")
  out = append(out, "Microsoft Word 2.0 Document")
  goto end
f386:
  // 512	string/b	\354\245\301			Microsoft Word Document
  off = pageOff + 0x200
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xec, 0xa5, 0xc1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f387 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "512\tstring/b\t\\354\\245\\301\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f387:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f388 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto end
f388:
  // 2080	string	Microsoft\ Excel\ 5.0\ Worksheet	%s
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65, 0x6c, 0x20, 0x35, 0x2e, 0x30, 0x20, 0x57, 0x6f, 0x72, 0x6b, 0x73, 0x68, 0x65, 0x65, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f389 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Excel\\ 5.0\\ Worksheet\t%s")
  out = append(out, "%s")
  goto end
f389:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f390 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto end
f390:
  // 2080	string	Foglio\ di\ lavoro\ Microsoft\ Exce	%s
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x46, 0x6f, 0x67, 0x6c, 0x69, 0x6f, 0x20, 0x64, 0x69, 0x20, 0x6c, 0x61, 0x76, 0x6f, 0x72, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f391 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tFoglio\\ di\\ lavoro\\ Microsoft\\ Exce\t%s")
  out = append(out, "%s")
  goto end
f391:
  // 2114	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x842
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f392 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2114\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto end
f392:
  // 2121	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x849
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f393 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2121\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto end
f393:
  // 0	string/b	\x09\x04\x06\x00\x00\x00\x10\x00	Microsoft Excel Worksheet
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x9, 0x4, 0x6, 0x0, 0x0, 0x0, 0x10, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f394 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x09\\x04\\x06\\x00\\x00\\x00\\x10\\x00\tMicrosoft Excel Worksheet")
  out = append(out, "Microsoft Excel Worksheet")
  goto end
f394:
  // 0	belong	0x00001a00
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1a00)) { goto f395 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00001a00")
  // >20	ubyte		>0
  off = pageOff + 0x14
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f396 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">20\tubyte\t\t>0")
  // >>20	ubyte		<32	Lotus 1-2-3
  off = pageOff + 0x14
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) < 0x20)) { goto f397 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>20\tubyte\t\t<32\tLotus 1-2-3")
  out = append(out, "Lotus 1-2-3")
  // >>>4	uleshort	0x1000	WorKsheet, version 3
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1000)) { goto f398 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1000\tWorKsheet, version 3")
  out = append(out, "WorKsheet, version 3")
  goto s397
f398:
  // >>>4	uleshort	0x1002	WorKsheet, version 4
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1002)) { goto f399 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1002\tWorKsheet, version 4")
  out = append(out, "WorKsheet, version 4")
  goto s397
f399:
  // >>>4	uleshort	0x1003	WorKsheet, version 97
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1003)) { goto f400 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1003\tWorKsheet, version 97")
  out = append(out, "WorKsheet, version 97")
  goto s397
f400:
  // >>>4	uleshort	0x1005	WorKsheet, version 9.8 Millennium
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1005)) { goto f401 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1005\tWorKsheet, version 9.8 Millennium")
  out = append(out, "WorKsheet, version 9.8 Millennium")
  goto s397
f401:
  // >>>4	uleshort	0x8001	FoRMatting data
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8001)) { goto f402 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8001\tFoRMatting data")
  out = append(out, "FoRMatting data")
  goto s397
f402:
  // >>>4	uleshort	0x8007	ForMatting data, version 3
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8007)) { goto f403 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8007\tForMatting data, version 3")
  out = append(out, "ForMatting data, version 3")
  goto s397
f403:
  // >>>4	default		x	unknown
  off = pageOff + 0x4
  // uh oh unhandled kind default
  goto f404
  fmt.Printf("matched rule: %s\n", ">>>4\tdefault\t\tx\tunknown")
  out = append(out, "unknown")
  // >>>>6	uleshort	=0x0004	worksheet
  off = pageOff + 0x6
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f405 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>6\tuleshort\t=0x0004\tworksheet")
  out = append(out, "worksheet")
  goto s404
f405:
  // >>>>6	uleshort	!0x0004	formatting data
  off = pageOff + 0x6
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) != 0x4)) { goto f406 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>6\tuleshort\t!0x0004\tformatting data")
  out = append(out, "formatting data")
  goto s404
f406:
  // >>>>4	uleshort	x	\b, revision 0x%x
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4\tuleshort\tx\t\\b, revision 0x%x")
  out = append(out, "\\b, revision 0x%x")
  goto s404
s404:
  goto s397
f404:
  // >>>6	uleshort	=0x0004	\b, cell range
  off = pageOff + 0x6
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f408 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>6\tuleshort\t=0x0004\t\\b, cell range")
  out = append(out, "\\b, cell range")
  // >>>>8	ulelong		!0
  off = pageOff + 0x8
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f409 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>8\tulelong\t\t!0")
  // >>>>>10	ubyte		>0	\b%d*
  off = pageOff + 0xa
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f410 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>10\tubyte\t\t>0\t\\b%d*")
  out = append(out, "\\b%d*")
  goto s409
f410:
  // >>>>>8	uleshort	x	\b%d,
  off = pageOff + 0x8
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>>8\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s409
  // >>>>>11	ubyte		x	\b%d-
  off = pageOff + 0xb
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>11\tubyte\t\tx\t\\b%d-")
  out = append(out, "\\b%d-")
  goto s409
s409:
  goto s408
f409:
  // >>>>14	ubyte		>0	\b%d*
  off = pageOff + 0xe
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f413 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>14\tubyte\t\t>0\t\\b%d*")
  out = append(out, "\\b%d*")
  goto s408
f413:
  // >>>>12	uleshort	x	\b%d,
  off = pageOff + 0xc
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>12\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s408
  // >>>>15	ubyte		x	\b%d
  off = pageOff + 0xf
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>15\tubyte\t\tx\t\\b%d")
  out = append(out, "\\b%d")
  goto s408
  // >>>>20	ubyte		>1	\b, character set 0x%x
  off = pageOff + 0x14
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x1)) { goto f416 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>20\tubyte\t\t>1\t\\b, character set 0x%x")
  out = append(out, "\\b, character set 0x%x")
  goto s408
f416:
  // >>>>21	ubyte		x	\b, flags 0x%x
  off = pageOff + 0x15
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>21\tubyte\t\tx\t\\b, flags 0x%x")
  out = append(out, "\\b, flags 0x%x")
  goto s408
s408:
  goto s397
f408:
  // >>>6	uleshort	!0x0004
  off = pageOff + 0x6
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) != 0x4)) { goto f418 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>6\tuleshort\t!0x0004")
  // >>>>30	search/29	\0\xAE
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1d, "\x00\xae"))
    if ml < 0 { goto f419 }
    gof = off + ml + 0x2
  }
  fmt.Printf("matched rule: %s\n", ">>>>30\tsearch/29\t\\0\\xAE")
  // >>>>>&4	string		>\0	\b, 1st font "%s"
  off = pageOff + gof + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f420 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>&4\tstring\t\t>\\0\t\\b, 1st font \"%s\"")
  out = append(out, "\\b, 1st font \"%s\"")
  goto s419
f420:
s419:
  goto s418
f419:
s418:
  goto s397
f418:
s397:
  goto s396
f397:
s396:
  goto s395
f396:
s395:
  goto end
f395:
  // 0	belong	0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f421 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00000200")
  // >7	ubyte		0
  off = pageOff + 0x7
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f422 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">7\tubyte\t\t0")
  // >>6	ubyte		>0	Lotus
  off = pageOff + 0x6
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f423 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>6\tubyte\t\t>0\tLotus")
  out = append(out, "Lotus")
  // >>>4	uleshort	0x0007	1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f424 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0007\t1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)")
  out = append(out, "1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)")
  goto s423
f424:
  // >>>4	uleshort	0x0C05	1-2-3 CoNFiguration, version 2.4J
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xc05)) { goto f425 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0C05\t1-2-3 CoNFiguration, version 2.4J")
  out = append(out, "1-2-3 CoNFiguration, version 2.4J")
  goto s423
f425:
  // >>>4	uleshort	0x0801	1-2-3 CoNFiguration, version 1-2.1
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x801)) { goto f426 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0801\t1-2-3 CoNFiguration, version 1-2.1")
  out = append(out, "1-2-3 CoNFiguration, version 1-2.1")
  goto s423
f426:
  // >>>4	uleshort	0x0802	Symphony CoNFiguration
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x802)) { goto f427 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0802\tSymphony CoNFiguration")
  out = append(out, "Symphony CoNFiguration")
  goto s423
f427:
  // >>>4	uleshort	0x0804	1-2-3 CoNFiguration, version 2.2
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x804)) { goto f428 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0804\t1-2-3 CoNFiguration, version 2.2")
  out = append(out, "1-2-3 CoNFiguration, version 2.2")
  goto s423
f428:
  // >>>4	uleshort	0x080A	1-2-3 CoNFiguration, version 2.3-2.4
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x80a)) { goto f429 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x080A\t1-2-3 CoNFiguration, version 2.3-2.4")
  out = append(out, "1-2-3 CoNFiguration, version 2.3-2.4")
  goto s423
f429:
  // >>>4	uleshort	0x1402	1-2-3 CoNFiguration, version 3.x
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1402)) { goto f430 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1402\t1-2-3 CoNFiguration, version 3.x")
  out = append(out, "1-2-3 CoNFiguration, version 3.x")
  goto s423
f430:
  // >>>4	uleshort	0x1450	1-2-3 CoNFiguration, version 4.x
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1450)) { goto f431 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1450\t1-2-3 CoNFiguration, version 4.x")
  out = append(out, "1-2-3 CoNFiguration, version 4.x")
  goto s423
f431:
  // >>>4	uleshort	0x0404	1-2-3 WorKSheet, version 1
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x404)) { goto f432 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0404\t1-2-3 WorKSheet, version 1")
  out = append(out, "1-2-3 WorKSheet, version 1")
  goto s423
f432:
  // >>>4	uleshort	0x0405	Symphony WoRksheet, version 1.0
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x405)) { goto f433 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0405\tSymphony WoRksheet, version 1.0")
  out = append(out, "Symphony WoRksheet, version 1.0")
  goto s423
f433:
  // >>>4	uleshort	0x0406	1-2-3/Symphony worksheet, version 2
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x406)) { goto f434 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0406\t1-2-3/Symphony worksheet, version 2")
  out = append(out, "1-2-3/Symphony worksheet, version 2")
  goto s423
f434:
  // >>>4	uleshort	0x0600	1-2-3 WorKsheet, version 1.xJ
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x600)) { goto f435 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0600\t1-2-3 WorKsheet, version 1.xJ")
  out = append(out, "1-2-3 WorKsheet, version 1.xJ")
  goto s423
f435:
  // >>>4	uleshort	0x0602	1-2-3 worksheet, version 2.4J
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x602)) { goto f436 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0602\t1-2-3 worksheet, version 2.4J")
  out = append(out, "1-2-3 worksheet, version 2.4J")
  goto s423
f436:
  // >>>4	uleshort	0x8006	1-2-3 ForMaTting data, version 2.x
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8006)) { goto f437 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8006\t1-2-3 ForMaTting data, version 2.x")
  out = append(out, "1-2-3 ForMaTting data, version 2.x")
  goto s423
f437:
  // >>>4	uleshort	0x8007	1-2-3 FoRMatting data, version 2.0
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8007)) { goto f438 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8007\t1-2-3 FoRMatting data, version 2.0")
  out = append(out, "1-2-3 FoRMatting data, version 2.0")
  goto s423
f438:
  // >>>4	default		x	unknown worksheet or configuration
  off = pageOff + 0x4
  // uh oh unhandled kind default
  goto f439
  fmt.Printf("matched rule: %s\n", ">>>4\tdefault\t\tx\tunknown worksheet or configuration")
  out = append(out, "unknown worksheet or configuration")
  // >>>>4	uleshort	x	\b, revision 0x%x
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4\tuleshort\tx\t\\b, revision 0x%x")
  out = append(out, "\\b, revision 0x%x")
  goto s439
s439:
  goto s423
f439:
  // >>>6		use	lotus-cells
  off = pageOff + 0x6
  {
    ss, _ := IdentifyLotusCells(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>6\t\tuse\tlotus-cells")
  goto s423
  // >>>(8.s+10)	use	lotus-cells
  {
    ra, ok := readU16le(tb, 0x8)
    if !ok { goto f442 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    ss, _ := IdentifyLotusCells(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s+10)\tuse\tlotus-cells")
  goto s423
f442:
s423:
  goto s422
f423:
s422:
  goto s421
f422:
s421:
  goto end
f421:
  // 0	string/b		WordPro\0	Lotus WordPro
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f443 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\0\tLotus WordPro")
  out = append(out, "Lotus WordPro")
  goto end
f443:
  // 0	string/b		WordPro\r\373	Lotus WordPro
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0xd, 0xfb}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f444 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\r\\373\tLotus WordPro")
  out = append(out, "Lotus WordPro")
  goto end
f444:
  // 0		string		\x71\xa8\x00\x00\x01\x02
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x71, 0xa8, 0x0, 0x0, 0x1, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f445 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\t\tstring\t\t\\x71\\xa8\\x00\\x00\\x01\\x02")
  // >12		string		Stirling\ Technologies,		InstallShield Uninstall Script
  off = pageOff + 0xc
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x74, 0x69, 0x72, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x69, 0x65, 0x73, 0x2c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f446 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">12\t\tstring\t\tStirling\\ Technologies,\t\tInstallShield Uninstall Script")
  out = append(out, "InstallShield Uninstall Script")
  goto s445
f446:
s445:
  goto end
f445:
  // 0	string/b	Nullsoft\ AVS\ Preset\ 	Winamp plug in
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x75, 0x6c, 0x6c, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x41, 0x56, 0x53, 0x20, 0x50, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f447 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tNullsoft\\ AVS\\ Preset\\ \tWinamp plug in")
  out = append(out, "Winamp plug in")
  goto end
f447:
  // 0	string/b	\327\315\306\232	ms-windows metafont .wmf
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd7, 0xcd, 0xc6, 0x9a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f448 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\327\\315\\306\\232\tms-windows metafont .wmf")
  out = append(out, "ms-windows metafont .wmf")
  goto end
f448:
  // 0	string/b	\002\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x2, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f449 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\002\\000\\011\\000\tms-windows metafont .wmf")
  out = append(out, "ms-windows metafont .wmf")
  goto end
f449:
  // 0	string/b	\001\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x1, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f450 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\001\\000\\011\\000\tms-windows metafont .wmf")
  out = append(out, "ms-windows metafont .wmf")
  goto end
f450:
  // 0	string/b	\003\001\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x1, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f451 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\001\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  out = append(out, "tz3 ms-works file")
  goto end
f451:
  // 0	string/b	\003\002\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x2, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f452 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\002\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  out = append(out, "tz3 ms-works file")
  goto end
f452:
  // 0	string/b	\003\003\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x3, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f453 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\003\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  out = append(out, "tz3 ms-works file")
  goto end
f453:
  // 0 string \211\000\077\003\005\000\063\237\127\065\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x35, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f454 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\065\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f454:
  // 0 string \211\000\077\003\005\000\063\237\127\066\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x36, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f455 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\066\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f455:
  // 0 string \211\000\077\003\005\000\063\237\127\067\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x37, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f456 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\067\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f456:
  // 0 string \211\000\077\003\005\000\063\237\127\070\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x38, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f457 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\070\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f457:
  // 0 string \211\000\077\003\005\000\063\237\127\071\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x39, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f458 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\071\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f458:
  // 0 string \211\000\225\003\005\000\062\122\207\304\100\345\042 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x95, 0x3, 0x5, 0x0, 0x32, 0x52, 0x87, 0xc4, 0x40, 0xe5, 0x22}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f459 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\225\\003\\005\\000\\062\\122\\207\\304\\100\\345\\042 PGP sig")
  out = append(out, "PGP sig")
  goto end
f459:
  // 0	string/b	MDIF\032\000\010\000\000\000\372\046\100\175\001\000\001\036\001\000 MS Windows special zipped file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x44, 0x49, 0x46, 0x1a, 0x0, 0x8, 0x0, 0x0, 0x0, 0xfa, 0x26, 0x40, 0x7d, 0x1, 0x0, 0x1, 0x1e, 0x1, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f460 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMDIF\\032\\000\\010\\000\\000\\000\\372\\046\\100\\175\\001\\000\\001\\036\\001\\000 MS Windows special zipped file")
  out = append(out, "MS Windows special zipped file")
  goto end
f460:
  // 0	string/b	\102\101\050\000\000\000\056\000\000\000\000\000\000\000	Icon for MS Windows
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x41, 0x28, 0x0, 0x0, 0x0, 0x2e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f461 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\102\\101\\050\\000\\000\\000\\056\\000\\000\\000\\000\\000\\000\\000\tIcon for MS Windows")
  out = append(out, "Icon for MS Windows")
  goto end
f461:
  // 0   belong  0x00000100
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f462 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000100")
  // >9  byte    0
  off = pageOff + 0x9
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f463 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  byte    0")
  // >>0 byte    x
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0 byte    x")
  goto s463
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s463
s463:
  goto s462
f463:
  // >9  ubyte   0xff
  off = pageOff + 0x9
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f466 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  ubyte   0xff")
  // >>0 byte    x
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0 byte    x")
  goto s466
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s466
s466:
  goto s462
f466:
s462:
  goto end
f462:
  // 0   belong  0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f469 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000200")
  // >9  byte    0
  off = pageOff + 0x9
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f470 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  byte    0")
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s470
s470:
  goto s469
f470:
  // >9  ubyte   0xff
  off = pageOff + 0x9
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f472 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  ubyte   0xff")
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s472
s472:
  goto s469
f472:
s469:
  goto end
f469:
  // 0	string/b	PK\010\010BGI	Borland font
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f474 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPK\\010\\010BGI\tBorland font")
  out = append(out, "Borland font")
  // >4	string	>\0	%s
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f475 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t>\\0\t%s")
  out = append(out, "%s")
  goto s474
f475:
s474:
  goto end
f474:
  // 0	string/b	pk\010\010BGI	Borland device
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x70, 0x6b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f476 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tpk\\010\\010BGI\tBorland device")
  out = append(out, "Borland device")
  // >4	string	>\0	%s
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f477 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t>\\0\t%s")
  out = append(out, "%s")
  goto s476
f477:
s476:
  goto end
f476:
  // 0	lelong		0x00000004
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f478 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000004")
  // >12	lelong		0x00000118	Windows Recycle Bin INFO2 file (Win98 or below)
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x118)) { goto f479 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tlelong\t\t0x00000118\tWindows Recycle Bin INFO2 file (Win98 or below)")
  out = append(out, "Windows Recycle Bin INFO2 file (Win98 or below)")
  goto s478
f479:
s478:
  goto end
f478:
  // 0	lelong		0x00000005
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f480 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000005")
  // >12	lelong		0x00000320	Windows Recycle Bin INFO2 file (Win2k - WinXP)
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x320)) { goto f481 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tlelong\t\t0x00000320\tWindows Recycle Bin INFO2 file (Win2k - WinXP)")
  out = append(out, "Windows Recycle Bin INFO2 file (Win2k - WinXP)")
  goto s480
f481:
s480:
  goto end
f480:
  // 9	string		GERBILDOC	First Choice document
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x4f, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f482 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDOC\tFirst Choice document")
  out = append(out, "First Choice document")
  goto end
f482:
  // 9	string		GERBILDB	First Choice database
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f483 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDB\tFirst Choice database")
  out = append(out, "First Choice database")
  goto end
f483:
  // 9	string		GERBILCLIP	First Choice database
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x43, 0x4c, 0x49, 0x50}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f484 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILCLIP\tFirst Choice database")
  out = append(out, "First Choice database")
  goto end
f484:
  // 0	string		GERBIL		First Choice device file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f485 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tGERBIL\t\tFirst Choice device file")
  out = append(out, "First Choice device file")
  goto end
f485:
  // 9	string		RABBITGRAPH	RabbitGraph file
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x41, 0x42, 0x42, 0x49, 0x54, 0x47, 0x52, 0x41, 0x50, 0x48}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f486 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tRABBITGRAPH\tRabbitGraph file")
  out = append(out, "RabbitGraph file")
  goto end
f486:
  // 0	string		DCU1		Borland Delphi .DCU file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x43, 0x55, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f487 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tDCU1\t\tBorland Delphi .DCU file")
  out = append(out, "Borland Delphi .DCU file")
  goto end
f487:
  // 0	string		=!<spell>	MKS Spell hash list (old format)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f488 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell>\tMKS Spell hash list (old format)")
  out = append(out, "MKS Spell hash list (old format)")
  goto end
f488:
  // 0	string		=!<spell2>	MKS Spell hash list
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x32, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f489 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell2>\tMKS Spell hash list")
  out = append(out, "MKS Spell hash list")
  goto end
f489:
  // 0	lelong		0x08086b70	TurboC BGI file
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x8086b70)) { goto f490 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08086b70\tTurboC BGI file")
  out = append(out, "TurboC BGI file")
  goto end
f490:
  // 0	lelong		0x08084b50	TurboC Font file
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x8084b50)) { goto f491 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08084b50\tTurboC Font file")
  out = append(out, "TurboC Font file")
  goto end
f491:
  // 0	string		TPF0
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x54, 0x50, 0x46, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f492 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tTPF0")
  goto end
f492:
  // 0	string		PMCC		Windows 3.x .GRP file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4d, 0x43, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f493 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tPMCC\t\tWindows 3.x .GRP file")
  out = append(out, "Windows 3.x .GRP file")
  goto end
f493:
  // 1	string		RDC-meg		MegaDots
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x44, 0x43, 0x2d, 0x6d, 0x65, 0x67}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f494 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "1\tstring\t\tRDC-meg\t\tMegaDots")
  out = append(out, "MegaDots")
  // >8	byte		>0x2F		version %c
  off = pageOff + 0x8
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x2f)) { goto f495 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">8\tbyte\t\t>0x2F\t\tversion %c")
  out = append(out, "version %c")
  goto s494
f495:
  // >9	byte		>0x2F		\b.%c file
  off = pageOff + 0x9
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x2f)) { goto f496 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9\tbyte\t\t>0x2F\t\t\\b.%c file")
  out = append(out, "\\b.%c file")
  goto s494
f496:
s494:
  goto end
f494:
  // 0	lelong		0x4C
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x4c)) { goto f497 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x4C")
  // >4	lelong		0x00021401	Windows shortcut file
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x21401)) { goto f498 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tlelong\t\t0x00021401\tWindows shortcut file")
  out = append(out, "Windows shortcut file")
  goto s497
f498:
s497:
  goto end
f497:
  // 0x171	string	MICROSOFT\ PIFEX\0	Windows Program Information File
  off = pageOff + 0x171
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x50, 0x49, 0x46, 0x45, 0x58, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f499 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0x171\tstring\tMICROSOFT\\ PIFEX\\0\tWindows Program Information File")
  out = append(out, "Windows Program Information File")
  // >0x24	string		>\0		\b for %.63s
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f500 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\t\t>\\0\t\t\\b for %.63s")
  out = append(out, "\\b for %.63s")
  goto s499
f500:
  // >0x65	string		>\0		\b, directory=%.64s
  off = pageOff + 0x65
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f501 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x65\tstring\t\t>\\0\t\t\\b, directory=%.64s")
  out = append(out, "\\b, directory=%.64s")
  goto s499
f501:
  // >0xA5	string		>\0		\b, parameters=%.64s
  off = pageOff + 0xa5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f502 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0xA5\tstring\t\t>\\0\t\t\\b, parameters=%.64s")
  out = append(out, "\\b, parameters=%.64s")
  goto s499
f502:
  // >0x187	search/0xB55	WINDOWS\ VMM\ 4.0\0
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "WINDOWS VMM 4.0\x00"))
    if ml < 0 { goto f503 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tWINDOWS\\ VMM\\ 4.0\\0")
  // >>&0x5e		ubyte	>0
  off = pageOff + gof + 0x5e
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f504 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&0x5e\t\tubyte\t>0")
  // >>>&-1		string	<PIFMGR.DLL		\b, icon=%s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x50, 0x49, 0x46, 0x4d, 0x47, 0x52, 0x2e, 0x44, 0x4c, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f505 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t<PIFMGR.DLL\t\t\\b, icon=%s")
  out = append(out, "\\b, icon=%s")
  goto s504
f505:
  // >>>&-1		string	>PIFMGR.DLL		\b, icon=%s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x50, 0x49, 0x46, 0x4d, 0x47, 0x52, 0x2e, 0x44, 0x4c, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f506 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t>PIFMGR.DLL\t\t\\b, icon=%s")
  out = append(out, "\\b, icon=%s")
  goto s504
f506:
s504:
  goto s503
f504:
  // >>&0xF0		ubyte	>0
  off = pageOff + gof + 0xf0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f507 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&0xF0\t\tubyte\t>0")
  // >>>&-1		string	<Terminal		\b, font=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f508 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t<Terminal\t\t\\b, font=%.32s")
  out = append(out, "\\b, font=%.32s")
  goto s507
f508:
  // >>>&-1		string	>Terminal		\b, font=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f509 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t>Terminal\t\t\\b, font=%.32s")
  out = append(out, "\\b, font=%.32s")
  goto s507
f509:
s507:
  goto s503
f507:
  // >>&0x110	ubyte	>0
  off = pageOff + gof + 0x110
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f510 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&0x110\tubyte\t>0")
  // >>>&-1		string	<Lucida\ Console	\b, TrueTypeFont=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x4c, 0x75, 0x63, 0x69, 0x64, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f511 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t<Lucida\\ Console\t\\b, TrueTypeFont=%.32s")
  out = append(out, "\\b, TrueTypeFont=%.32s")
  goto s510
f511:
  // >>>&-1		string	>Lucida\ Console	\b, TrueTypeFont=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x4c, 0x75, 0x63, 0x69, 0x64, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f512 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t>Lucida\\ Console\t\\b, TrueTypeFont=%.32s")
  out = append(out, "\\b, TrueTypeFont=%.32s")
  goto s510
f512:
s510:
  goto s503
f510:
s503:
  goto s499
f503:
  // >0x187	search/0xB55	WINDOWS\ NT\ \ 3.1\0	\b, Windows NT-style
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "WINDOWS NT  3.1\x00"))
    if ml < 0 { goto f513 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tWINDOWS\\ NT\\ \\ 3.1\\0\t\\b, Windows NT-style")
  out = append(out, "\\b, Windows NT-style")
  goto s499
f513:
  // >0x187	search/0xB55	CONFIG\ \ SYS\ 4.0\0	\b +CONFIG.SYS
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "CONFIG  SYS 4.0\x00"))
    if ml < 0 { goto f514 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tCONFIG\\ \\ SYS\\ 4.0\\0\t\\b +CONFIG.SYS")
  out = append(out, "\\b +CONFIG.SYS")
  goto s499
f514:
  // >0x187	search/0xB55	AUTOEXECBAT\ 4.0\0	\b +AUTOEXEC.BAT
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "AUTOEXECBAT 4.0\x00"))
    if ml < 0 { goto f515 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tAUTOEXECBAT\\ 4.0\\0\t\\b +AUTOEXEC.BAT")
  out = append(out, "\\b +AUTOEXEC.BAT")
  goto s499
f515:
s499:
  goto end
f499:
  // 0	belong		0xC5D0D3C6	DOS EPS Binary File
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xc5d0d3c6)) { goto f516 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xC5D0D3C6\tDOS EPS Binary File")
  out = append(out, "DOS EPS Binary File")
  // >4	long		>0		Postscript starts at byte %d
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f517 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tlong\t\t>0\t\tPostscript starts at byte %d")
  out = append(out, "Postscript starts at byte %d")
  // >>8	long		>0		length %d
  off = pageOff + 0x8
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f518 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>8\tlong\t\t>0\t\tlength %d")
  out = append(out, "length %d")
  // >>>12	long		>0		Metafile starts at byte %d
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f519 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>12\tlong\t\t>0\t\tMetafile starts at byte %d")
  out = append(out, "Metafile starts at byte %d")
  // >>>>16	long		>0		length %d
  off = pageOff + 0x10
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f520 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>16\tlong\t\t>0\t\tlength %d")
  out = append(out, "length %d")
  goto s519
f520:
s519:
  goto s518
f519:
  // >>>20	long		>0		TIFF starts at byte %d
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f521 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>20\tlong\t\t>0\t\tTIFF starts at byte %d")
  out = append(out, "TIFF starts at byte %d")
  // >>>>24	long		>0		length %d
  off = pageOff + 0x18
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f522 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>24\tlong\t\t>0\t\tlength %d")
  out = append(out, "length %d")
  goto s521
f522:
s521:
  goto s518
f521:
s518:
  goto s517
f518:
s517:
  goto s516
f517:
s516:
  goto end
f516:
  // 0	leshort		0x223e9f78	TNEF
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x223e9f78)) { goto f523 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x223e9f78\tTNEF")
  out = append(out, "TNEF")
  goto end
f523:
  // 0	string		NG\0\001
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x47, 0x0, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f524 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tNG\\0\\001")
  // >2	ulelong		0x00000100	Norton Guide
  off = pageOff + 0x2
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f525 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">2\tulelong\t\t0x00000100\tNorton Guide")
  out = append(out, "Norton Guide")
  // >>8	string		>\0		"%-.40s"
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f526 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>8\tstring\t\t>\\0\t\t\"%-.40s\"")
  out = append(out, "\"%-.40s\"")
  goto s525
f526:
  // >>48	string		>\0		\b, %-.66s
  off = pageOff + 0x30
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f527 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>48\tstring\t\t>\\0\t\t\\b, %-.66s")
  out = append(out, "\\b, %-.66s")
  goto s525
f527:
  // >>114	string		>\0		%-.66s
  off = pageOff + 0x72
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f528 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>114\tstring\t\t>\\0\t\t%-.66s")
  out = append(out, "%-.66s")
  goto s525
f528:
s525:
  goto s524
f525:
s524:
  goto end
f524:
  // 0	ulelong	0x48443408		4DOS help file
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x48443408)) { goto f529 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tulelong\t0x48443408\t\t4DOS help file")
  out = append(out, "4DOS help file")
  // >4	string	x			\b, version %-4.4s
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f530 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\tx\t\t\t\\b, version %-4.4s")
  out = append(out, "\\b, version %-4.4s")
  goto s529
f530:
s529:
  goto end
f529:
  // 0	ulequad	0x3a000000024e4c	MS Advisor help file
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x3a000000024e4c)) { goto f531 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t0x3a000000024e4c\tMS Advisor help file")
  out = append(out, "MS Advisor help file")
  goto end
f531:
  // 0	string/b	ITSF\003\000\000\000\x60\000\000\000	MS Windows HtmlHelp Data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x53, 0x46, 0x3, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f532 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITSF\\003\\000\\000\\000\\x60\\000\\000\\000\tMS Windows HtmlHelp Data")
  out = append(out, "MS Windows HtmlHelp Data")
  goto end
f532:
  // 2	string/b	GFA-BASIC3	GFA-BASIC 3 data
  off = pageOff + 0x2
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x46, 0x41, 0x2d, 0x42, 0x41, 0x53, 0x49, 0x43, 0x33}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f533 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2\tstring/b\tGFA-BASIC3\tGFA-BASIC 3 data")
  out = append(out, "GFA-BASIC 3 data")
  goto end
f533:
  // 0	string/b	MSCF\0\0\0\0	Microsoft Cabinet archive data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x46, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f534 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCF\\0\\0\\0\\0\tMicrosoft Cabinet archive data")
  out = append(out, "Microsoft Cabinet archive data")
  // >8	lelong		x		\b, %u bytes
  off = pageOff + 0x8
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">8\tlelong\t\tx\t\t\\b, %u bytes")
  out = append(out, "\\b, %u bytes")
  goto s534
  // >28	leshort		1		\b, 1 file
  off = pageOff + 0x1c
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f536 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">28\tleshort\t\t1\t\t\\b, 1 file")
  out = append(out, "\\b, 1 file")
  goto s534
f536:
  // >28	leshort		>1		\b, %u files
  off = pageOff + 0x1c
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f537 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">28\tleshort\t\t>1\t\t\\b, %u files")
  out = append(out, "\\b, %u files")
  goto s534
f537:
s534:
  goto end
f534:
  // 0	string/b	ISc(		InstallShield Cabinet archive data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x53, 0x63, 0x28}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f538 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tISc(\t\tInstallShield Cabinet archive data")
  out = append(out, "InstallShield Cabinet archive data")
  // >5	byte&0xf0	=0x60		version 6,
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv)&0xf0 == 0x60)) { goto f539 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte&0xf0\t=0x60\t\tversion 6,")
  out = append(out, "version 6,")
  goto s538
f539:
  // >5	byte&0xf0	!0x60		version 4/5,
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv)&0xf0 != 0x60)) { goto f540 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte&0xf0\t!0x60\t\tversion 4/5,")
  out = append(out, "version 4/5,")
  goto s538
f540:
  // >(12.l+40)	lelong	x		%u files
  {
    ra, ok := readU32le(tb, 0xc)
    if !ok { goto f541 }
    off = i64(ra)
    off = off + 0x28
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(12.l+40)\tlelong\tx\t\t%u files")
  out = append(out, "%u files")
  goto s538
f541:
s538:
  goto end
f538:
  // 0	string/b	MSCE\0\0\0\0	Microsoft WinCE install header
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x45, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f542 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCE\\0\\0\\0\\0\tMicrosoft WinCE install header")
  out = append(out, "Microsoft WinCE install header")
  // >20	lelong		0		\b, architecture-independent
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f543 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t0\t\t\\b, architecture-independent")
  out = append(out, "\\b, architecture-independent")
  goto s542
f543:
  // >20	lelong		103		\b, Hitachi SH3
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x67)) { goto f544 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t103\t\t\\b, Hitachi SH3")
  out = append(out, "\\b, Hitachi SH3")
  goto s542
f544:
  // >20	lelong		104		\b, Hitachi SH4
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x68)) { goto f545 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t104\t\t\\b, Hitachi SH4")
  out = append(out, "\\b, Hitachi SH4")
  goto s542
f545:
  // >20	lelong		0xA11		\b, StrongARM
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xa11)) { goto f546 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t0xA11\t\t\\b, StrongARM")
  out = append(out, "\\b, StrongARM")
  goto s542
f546:
  // >20	lelong		4000		\b, MIPS R4000
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xfa0)) { goto f547 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t4000\t\t\\b, MIPS R4000")
  out = append(out, "\\b, MIPS R4000")
  goto s542
f547:
  // >20	lelong		10003		\b, Hitachi SH3
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x2713)) { goto f548 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t10003\t\t\\b, Hitachi SH3")
  out = append(out, "\\b, Hitachi SH3")
  goto s542
f548:
  // >20	lelong		10004		\b, Hitachi SH3E
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x2714)) { goto f549 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t10004\t\t\\b, Hitachi SH3E")
  out = append(out, "\\b, Hitachi SH3E")
  goto s542
f549:
  // >20	lelong		10005		\b, Hitachi SH4
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x2715)) { goto f550 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t10005\t\t\\b, Hitachi SH4")
  out = append(out, "\\b, Hitachi SH4")
  goto s542
f550:
  // >20	lelong		70001		\b, ARM 7TDMI
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x11171)) { goto f551 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t70001\t\t\\b, ARM 7TDMI")
  out = append(out, "\\b, ARM 7TDMI")
  goto s542
f551:
  // >52	leshort		1		\b, 1 file
  off = pageOff + 0x34
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f552 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">52\tleshort\t\t1\t\t\\b, 1 file")
  out = append(out, "\\b, 1 file")
  goto s542
f552:
  // >52	leshort		>1		\b, %u files
  off = pageOff + 0x34
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f553 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">52\tleshort\t\t>1\t\t\\b, %u files")
  out = append(out, "\\b, %u files")
  goto s542
f553:
  // >56	leshort		1		\b, 1 registry entry
  off = pageOff + 0x38
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f554 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">56\tleshort\t\t1\t\t\\b, 1 registry entry")
  out = append(out, "\\b, 1 registry entry")
  goto s542
f554:
  // >56	leshort		>1		\b, %u registry entries
  off = pageOff + 0x38
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f555 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">56\tleshort\t\t>1\t\t\\b, %u registry entries")
  out = append(out, "\\b, %u registry entries")
  goto s542
f555:
s542:
  goto end
f542:
  // 0	ulelong 1
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f556 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tulelong 1")
  // >40	string	\ EMF		Windows Enhanced Metafile (EMF) image data
  off = pageOff + 0x28
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x45, 0x4d, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f557 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">40\tstring\t\\ EMF\t\tWindows Enhanced Metafile (EMF) image data")
  out = append(out, "Windows Enhanced Metafile (EMF) image data")
  // >>44	ulelong x		version 0x%x
  off = pageOff + 0x2c
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>44\tulelong x\t\tversion 0x%x")
  out = append(out, "version 0x%x")
  goto s557
s557:
  goto s556
f557:
s556:
  goto end
f556:
  // 0	string/b	\320\317\021\340\241\261\032\341	Microsoft Office Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f559 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\tMicrosoft Office Document")
  out = append(out, "Microsoft Office Document")
  // >546	string	bjbj			Microsoft Word Document
  off = pageOff + 0x222
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x62, 0x6a, 0x62, 0x6a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f560 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">546\tstring\tbjbj\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto s559
f560:
  // >546	string	jbjb			Microsoft Word Document
  off = pageOff + 0x222
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x6a, 0x62, 0x6a, 0x62}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f561 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">546\tstring\tjbjb\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto s559
f561:
s559:
  goto end
f559:
  // 0	string/b	\224\246\056		Microsoft Word Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x94, 0xa6, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f562 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\224\\246\\056\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f562:
  // 512	string	R\0o\0o\0t\0\ \0E\0n\0t\0r\0y	Microsoft Word Document
  off = pageOff + 0x200
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x0, 0x6f, 0x0, 0x6f, 0x0, 0x74, 0x0, 0x20, 0x0, 0x45, 0x0, 0x6e, 0x0, 0x74, 0x0, 0x72, 0x0, 0x79}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f563 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "512\tstring\tR\\0o\\0o\\0t\\0\\ \\0E\\0n\\0t\\0r\\0y\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f563:
  // 0	string/b $RBU
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x52, 0x42, 0x55}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f564 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b $RBU")
  // >23	string Dell			%s system BIOS
  off = pageOff + 0x17
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x65, 0x6c, 0x6c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f565 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">23\tstring Dell\t\t\t%s system BIOS")
  out = append(out, "%s system BIOS")
  goto s564
f565:
  // >5	byte   2
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f566 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte   2")
  // >>48	byte   x			version %d.
  off = pageOff + 0x30
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>48\tbyte   x\t\t\tversion %d.")
  out = append(out, "version %d.")
  goto s566
  // >>49	byte   x			\b%d.
  off = pageOff + 0x31
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>49\tbyte   x\t\t\t\\b%d.")
  out = append(out, "\\b%d.")
  goto s566
  // >>50	byte   x			\b%d
  off = pageOff + 0x32
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>50\tbyte   x\t\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s566
s566:
  goto s564
f566:
  // >5	byte   <2
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) < 0x2)) { goto f570 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte   <2")
  // >>48	string x			version %.3s
  off = pageOff + 0x30
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f571 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>48\tstring x\t\t\tversion %.3s")
  out = append(out, "version %.3s")
  goto s570
f571:
s570:
  goto s564
f570:
s564:
  goto end
f564:
  // 0	string/b	DDS\040\174\000\000\000 Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x44, 0x53, 0x20, 0x7c, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f572 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tDDS\\040\\174\\000\\000\\000 Microsoft DirectDraw Surface (DDS),")
  out = append(out, "Microsoft DirectDraw Surface (DDS),")
  // >16	lelong	>0			%d x
  off = pageOff + 0x10
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f573 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">16\tlelong\t>0\t\t\t%d x")
  out = append(out, "%d x")
  goto s572
f573:
  // >12	lelong	>0			%d,
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f574 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tlelong\t>0\t\t\t%d,")
  out = append(out, "%d,")
  goto s572
f574:
  // >84	string	x			%.4s
  off = pageOff + 0x54
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f575 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">84\tstring\tx\t\t\t%.4s")
  out = append(out, "%.4s")
  goto s572
f575:
s572:
  goto end
f572:
  // 0	string/b	ITOLITLS		Microsoft Reader eBook Data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x4f, 0x4c, 0x49, 0x54, 0x4c, 0x53}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f576 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITOLITLS\t\tMicrosoft Reader eBook Data")
  out = append(out, "Microsoft Reader eBook Data")
  // >8	lelong	x			\b, version %u
  off = pageOff + 0x8
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">8\tlelong\tx\t\t\t\\b, version %u")
  out = append(out, "\\b, version %u")
  goto s576
s576:
  goto end
f576:
  // 0	string/b	B000FF\n	Windows Embedded CE binary image
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x30, 0x30, 0x30, 0x46, 0x46, 0xa}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f578 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tB000FF\\n\tWindows Embedded CE binary image")
  out = append(out, "Windows Embedded CE binary image")
  goto end
f578:
  // 0	string/b	MSWIM\000\000\000	Windows imaging (WIM) image
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x49, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f579 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSWIM\\000\\000\\000\tWindows imaging (WIM) image")
  out = append(out, "Windows imaging (WIM) image")
  goto end
f579:
  // 0	string/b	WLPWM\000\000\000	Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x4c, 0x50, 0x57, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f580 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tWLPWM\\000\\000\\000\tWindows imaging (WIM) image, wimlib pipable format")
  out = append(out, "Windows imaging (WIM) image, wimlib pipable format")
  goto end
f580:
  // 0	string	\xfc\x03\x00	Mallard BASIC program data (v1.11)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f581 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x00\tMallard BASIC program data (v1.11)")
  out = append(out, "Mallard BASIC program data (v1.11)")
  goto end
f581:
  // 0	string	\xfc\x04\x00	Mallard BASIC program data (v1.29+)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f582 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x00\tMallard BASIC program data (v1.29+)")
  out = append(out, "Mallard BASIC program data (v1.29+)")
  goto end
f582:
  // 0	string	\xfc\x03\x01	Mallard BASIC protected program data (v1.11)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f583 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x01\tMallard BASIC protected program data (v1.11)")
  out = append(out, "Mallard BASIC protected program data (v1.11)")
  goto end
f583:
  // 0	string	\xfc\x04\x01	Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f584 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x01\tMallard BASIC protected program data (v1.29+)")
  out = append(out, "Mallard BASIC protected program data (v1.29+)")
  goto end
f584:
  // 0	string	MIOPEN		Mallard BASIC Jetsam data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x4f, 0x50, 0x45, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f585 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\tMIOPEN\t\tMallard BASIC Jetsam data")
  out = append(out, "Mallard BASIC Jetsam data")
  goto end
f585:
  // 0	string	Jetsam0		Mallard BASIC Jetsam index data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4a, 0x65, 0x74, 0x73, 0x61, 0x6d, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f586 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\tJetsam0\t\tMallard BASIC Jetsam index data")
  out = append(out, "Mallard BASIC Jetsam index data")
  goto end
f586:
  // 0x3	ushort	>1979
  off = pageOff + 0x3
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x7bb)) { goto f587 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0x3\tushort\t>1979")
  // >0x5	ubyte-1 <31
  off = pageOff + 0x5
  {
    iv, ok := readU8le(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0x1f)) { goto f588 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0x5\tubyte-1 <31")
  // >>0x6	ubyte-1 <12
  off = pageOff + 0x6
  {
    iv, ok := readU8le(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0xc)) { goto f589 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0x6\tubyte-1 <12")
  // >>>0x7	string	\0\0\0\0\0\0\0\0
  off = pageOff + 0x7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f590 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>0x7\tstring\t\\0\\0\\0\\0\\0\\0\\0\\0")
  // >>>>0x1 ubyte	x	DOS 2.0 backup id file, sequence %d
  off = pageOff + 0x1
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>0x1 ubyte\tx\tDOS 2.0 backup id file, sequence %d")
  out = append(out, "DOS 2.0 backup id file, sequence %d")
  goto s590
  // >>>>0x0 ubyte	0xff	\b, last disk
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f592 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>0x0 ubyte\t0xff\t\\b, last disk")
  out = append(out, "\\b, last disk")
  goto s590
f592:
s590:
  goto s589
f590:
s589:
  goto s588
f589:
s588:
  goto s587
f588:
s587:
  goto end
f587:
  // 0x53	ubyte-1	<80
  off = pageOff + 0x53
  {
    iv, ok := readU8le(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0x50)) { goto f593 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0x53\tubyte-1\t<80")
  // >0x54	string	\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0
  off = pageOff + 0x54
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f594 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x54\tstring\t\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0")
  // >>0x5	string	x	DOS 2.0 backed up file %s,
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f595 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x5\tstring\tx\tDOS 2.0 backed up file %s,")
  out = append(out, "DOS 2.0 backed up file %s,")
  goto s594
f595:
  // >>0	ubyte	0xff	complete file
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f596 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0\tubyte\t0xff\tcomplete file")
  out = append(out, "complete file")
  goto s594
f596:
  // >>0	ubyte	!0xff
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0xff)) { goto f597 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0\tubyte\t!0xff")
  // >>>1	ushort	x	split file, sequence %d
  off = pageOff + 0x1
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>1\tushort\tx\tsplit file, sequence %d")
  out = append(out, "split file, sequence %d")
  goto s597
s597:
  goto s594
f597:
s594:
  goto s593
f594:
s593:
  goto end
f593:
  // 0	string	\x8bBACKUP\x20
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x8b, 0x42, 0x41, 0x43, 0x4b, 0x55, 0x50, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f599 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\x8bBACKUP\\x20")
  // >0xa	string	\0\0\0\0\0\0\0\0
  off = pageOff + 0xa
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f600 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0xa\tstring\t\\0\\0\\0\\0\\0\\0\\0\\0")
  // >>0x9	ubyte	x	DOS 3.3 backup control file, sequence %d
  off = pageOff + 0x9
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0x9\tubyte\tx\tDOS 3.3 backup control file, sequence %d")
  out = append(out, "DOS 3.3 backup control file, sequence %d")
  goto s600
  // >>0x8a	ubyte	0xff	\b, last disk
  off = pageOff + 0x8a
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f602 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0x8a\tubyte\t0xff\t\\b, last disk")
  out = append(out, "\\b, last disk")
  goto s600
f602:
s600:
  goto s599
f600:
s599:
  goto end
f599:
end:
  return out, nil
}

func Identify__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f0 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  // >4	belong		>30		compiled Java class data,
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x1e)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tbelong\t\t>30\t\tcompiled Java class data,")
  out = append(out, "compiled Java class data,")
  // >>6	beshort		x	        version %d.
  off = pageOff + 0x6
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>6\tbeshort\t\tx\t        version %d.")
  out = append(out, "version %d.")
  goto s1
  // >>4	beshort		x       	\b%d
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tbeshort\t\tx       \t\\b%d")
  out = append(out, "\\b%d")
  goto s1
  // >>4	belong		0x002e		(Java 1.2)
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x2e)) { goto f4 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x002e\t\t(Java 1.2)")
  out = append(out, "(Java 1.2)")
  goto s1
f4:
  // >>4	belong		0x002f		(Java 1.3)
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x2f)) { goto f5 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x002f\t\t(Java 1.3)")
  out = append(out, "(Java 1.3)")
  goto s1
f5:
  // >>4	belong		0x0030		(Java 1.4)
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x30)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x0030\t\t(Java 1.4)")
  out = append(out, "(Java 1.4)")
  goto s1
f6:
  // >>4	belong		0x0031		(Java 1.5)
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x31)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x0031\t\t(Java 1.5)")
  out = append(out, "(Java 1.5)")
  goto s1
f7:
  // >>4	belong		0x0032		(Java 1.6)
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x32)) { goto f8 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t0x0032\t\t(Java 1.6)")
  out = append(out, "(Java 1.6)")
  goto s1
f8:
s1:
  goto s0
f1:
s0:
  goto end
f0:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  out = append(out, "JAR compressed with pack200,")
  // >5	byte		x		version %d.
  off = pageOff + 0x5
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\tx\t\tversion %d.")
  out = append(out, "version %d.")
  goto s9
  // >4	byte		x		\b%d
  off = pageOff + 0x4
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\tx\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s9
s9:
  goto end
f9:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f12 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  out = append(out, "JAR compressed with pack200,")
  // >5	byte		x		version %d.
  off = pageOff + 0x5
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\tx\t\tversion %d.")
  out = append(out, "version %d.")
  goto s12
  // >4	byte		x		\b%d
  off = pageOff + 0x4
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\tx\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s12
s12:
  goto end
f12:
  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f15 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  // >4	belong		1		Mach-O universal binary with 1 architecture:
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f16 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tbelong\t\t1\t\tMach-O universal binary with 1 architecture:")
  out = append(out, "Mach-O universal binary with 1 architecture:")
  // >>8	use		mach-o		\b
  off = pageOff + 0x8
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>8\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s16
s16:
  goto s15
f16:
  // >4	belong		>1
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x1)) { goto f18 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tbelong\t\t>1")
  // >>4	belong		<20		Mach-O universal binary with %ld architectures:
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) < 0x14)) { goto f19 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t<20\t\tMach-O universal binary with %ld architectures:")
  out = append(out, "Mach-O universal binary with %ld architectures:")
  // >>>8	use		mach-o		\b
  off = pageOff + 0x8
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>8\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s19
  // >>>28	use		mach-o		\b
  off = pageOff + 0x1c
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>28\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s19
s19:
  goto s18
f19:
  // >>4	belong		>2
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x2)) { goto f22 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t>2")
  // >>>48	use		mach-o		\b
  off = pageOff + 0x30
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>48\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s22
s22:
  goto s18
f22:
  // >>4	belong		>3
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0x3)) { goto f24 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tbelong\t\t>3")
  // >>>68	use		mach-o		\b
  off = pageOff + 0x44
  {
    ss, _ := IdentifyMachO(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>68\tuse\t\tmach-o\t\t\\b")
  out = append(out, "\\b")
  goto s24
s24:
  goto s18
f24:
s18:
  goto s15
f18:
s15:
  goto end
f15:
  // 0	string/wt	#!\ /bin/sh		POSIX shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f26 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/sh\t\tPOSIX shell script text executable")
  out = append(out, "POSIX shell script text executable")
  goto end
f26:
  // 0	string/wb	#!\ /bin/sh		POSIX shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f27 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/sh\t\tPOSIX shell script executable (binary data)")
  out = append(out, "POSIX shell script executable (binary data)")
  goto end
f27:
  // 0	string/wt	#!\ /bin/csh		C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f28 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/csh\t\tC shell script text executable")
  out = append(out, "C shell script text executable")
  goto end
f28:
  // 0	string/wt	#!\ /bin/ksh		Korn shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f29 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/ksh\t\tKorn shell script text executable")
  out = append(out, "Korn shell script text executable")
  goto end
f29:
  // 0	string/wb	#!\ /bin/ksh		Korn shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f30 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/ksh\t\tKorn shell script executable (binary data)")
  out = append(out, "Korn shell script executable (binary data)")
  goto end
f30:
  // 0	string/wt 	#!\ /bin/tcsh		Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f31 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /bin/tcsh\t\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f31:
  // 0	string/wt	#!\ /usr/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f32 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/tcsh\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f32:
  // 0	string/wt 	#!\ /usr/local/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f33 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /usr/local/tcsh\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f33:
  // 0	string/wt	#!\ /usr/local/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f34 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/tcsh\tTenex C shell script text executable")
  out = append(out, "Tenex C shell script text executable")
  goto end
f34:
  // 0	string/wt	#!\ /bin/zsh		Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f35 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/zsh\t\tPaul Falstad's zsh script text executable")
  out = append(out, "Paul Falstad's zsh script text executable")
  goto end
f35:
  // 0	string/wt	#!\ /usr/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f36 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/zsh\tPaul Falstad's zsh script text executable")
  out = append(out, "Paul Falstad's zsh script text executable")
  goto end
f36:
  // 0	string/wt	#!\ /usr/local/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f37 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/zsh\tPaul Falstad's zsh script text executable")
  out = append(out, "Paul Falstad's zsh script text executable")
  goto end
f37:
  // 0	string/wt	#!\ /usr/local/bin/ash	Neil Brown's ash script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f38 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ash\tNeil Brown's ash script text executable")
  out = append(out, "Neil Brown's ash script text executable")
  goto end
f38:
  // 0	string/wt	#!\ /usr/local/bin/ae	Neil Brown's ae script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f39 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ae\tNeil Brown's ae script text executable")
  out = append(out, "Neil Brown's ae script text executable")
  goto end
f39:
  // 0	string/wt	#!\ /bin/nawk		new awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f40 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/nawk\t\tnew awk script text executable")
  out = append(out, "new awk script text executable")
  goto end
f40:
  // 0	string/wt	#!\ /usr/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f41 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/nawk\tnew awk script text executable")
  out = append(out, "new awk script text executable")
  goto end
f41:
  // 0	string/wt	#!\ /usr/local/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f42 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/nawk\tnew awk script text executable")
  out = append(out, "new awk script text executable")
  goto end
f42:
  // 0	string/wt	#!\ /bin/gawk		GNU awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f43 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/gawk\t\tGNU awk script text executable")
  out = append(out, "GNU awk script text executable")
  goto end
f43:
  // 0	string/wt	#!\ /usr/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f44 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/gawk\tGNU awk script text executable")
  out = append(out, "GNU awk script text executable")
  goto end
f44:
  // 0	string/wt	#!\ /usr/local/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f45 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/gawk\tGNU awk script text executable")
  out = append(out, "GNU awk script text executable")
  goto end
f45:
  // 0	string/wt	#!\ /bin/awk		awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f46 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/awk\t\tawk script text executable")
  out = append(out, "awk script text executable")
  goto end
f46:
  // 0	string/wt	#!\ /usr/bin/awk	awk script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f47 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/awk\tawk script text executable")
  out = append(out, "awk script text executable")
  goto end
f47:
  // 0	string/wt	#!\ /bin/rc	Plan 9 rc shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f48 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/rc\tPlan 9 rc shell script text executable")
  out = append(out, "Plan 9 rc shell script text executable")
  goto end
f48:
  // 0	string/wt	#!\ /bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f49 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f49:
  // 0	string/wb	#!\ /bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f50 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f50:
  // 0	string/wt	#!\ /usr/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f51 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f51:
  // 0	string/wb	#!\ /usr/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f52 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/bin/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f52:
  // 0	string/wt	#!\ /usr/local/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f53 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f53:
  // 0	string/wb	#!\ /usr/local/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f54 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f54:
  // 0	string/wt	#!\ /usr/local/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f55 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/bash\tBourne-Again shell script text executable")
  out = append(out, "Bourne-Again shell script text executable")
  goto end
f55:
  // 0	string/wb	#!\ /usr/local/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f56 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bin/bash\tBourne-Again shell script executable (binary data)")
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto end
f56:
  // 0	search/1/c	=<?php			PHP script text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?php"))
    if ml < 0 { goto f57 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/c\t=<?php\t\t\tPHP script text")
  out = append(out, "PHP script text")
  goto end
f57:
  // 0	search/1	=<?\n			PHP script text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\n"))
    if ml < 0 { goto f58 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\n\t\t\tPHP script text")
  out = append(out, "PHP script text")
  goto end
f58:
  // 0	search/1	=<?\r			PHP script text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\r"))
    if ml < 0 { goto f59 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\r\t\t\tPHP script text")
  out = append(out, "PHP script text")
  goto end
f59:
  // 0	search/1/w	#!\ /usr/local/bin/php	PHP script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/local/bin/php"))
    if ml < 0 { goto f60 }
    gof = off + ml + 0x15
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/local/bin/php\tPHP script text executable")
  out = append(out, "PHP script text executable")
  goto end
f60:
  // 0	search/1/w	#!\ /usr/bin/php	PHP script text executable
  off = pageOff + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/bin/php"))
    if ml < 0 { goto f61 }
    gof = off + ml + 0xf
  }
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/bin/php\tPHP script text executable")
  out = append(out, "PHP script text executable")
  goto end
f61:
  // 0	string	=<?php\ /*\ Smarty\ version	Smarty compiled template
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x3c, 0x3f, 0x70, 0x68, 0x70, 0x20, 0x2f, 0x2a, 0x20, 0x53, 0x6d, 0x61, 0x72, 0x74, 0x79, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f62 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t=<?php\\ /*\\ Smarty\\ version\tSmarty compiled template")
  out = append(out, "Smarty compiled template")
  goto end
f62:
  // 0	string		Zend\x00		PHP script Zend Optimizer data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x65, 0x6e, 0x64, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f63 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tZend\\x00\t\tPHP script Zend Optimizer data")
  out = append(out, "PHP script Zend Optimizer data")
  goto end
f63:
  // 0	string/t	$!			DCL command file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f64 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t$!\t\t\tDCL command file")
  out = append(out, "DCL command file")
  goto end
f64:
  // 0	string		#!/usr/bin/pdmenu	Pdmenu configuration file text
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x70, 0x64, 0x6d, 0x65, 0x6e, 0x75}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f65 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t#!/usr/bin/pdmenu\tPdmenu configuration file text")
  out = append(out, "Pdmenu configuration file text")
  goto end
f65:
  // 0	string		\177ELF		ELF
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x7f, 0x45, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f66 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t\\177ELF\t\tELF")
  out = append(out, "ELF")
  // >4	byte		0		invalid class
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f67 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\t0\t\tinvalid class")
  out = append(out, "invalid class")
  goto s66
f67:
  // >4	byte		1		32-bit
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f68 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\t1\t\t32-bit")
  out = append(out, "32-bit")
  goto s66
f68:
  // >4	byte		2		64-bit
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f69 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4\tbyte\t\t2\t\t64-bit")
  out = append(out, "64-bit")
  goto s66
f69:
  // >5	byte		0		invalid byte order
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f70 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\t0\t\tinvalid byte order")
  out = append(out, "invalid byte order")
  goto s66
f70:
  // >5	byte		1		LSB
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f71 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\t1\t\tLSB")
  out = append(out, "LSB")
  // >>0	use		elf-le
  off = pageOff + 0x0
  {
    ss, _ := IdentifyElfLe(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0\tuse\t\telf-le")
  goto s71
s71:
  goto s66
f71:
  // >5	byte		2		MSB
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f73 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte\t\t2\t\tMSB")
  out = append(out, "MSB")
  // >>0	use		\^elf-le
  off = pageOff + 0x0
  {
    ss, _ := IdentifyElfLe__Swapped(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0\tuse\t\t\\^elf-le")
  goto s73
s73:
  goto s66
f73:
  // >4      byte            <0x80
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) < 0x80)) { goto f75 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">4      byte            <0x80")
  // >>8	string		>\0		(%s)
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f76 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>8\tstring\t\t>\\0\t\t(%s)")
  out = append(out, "(%s)")
  goto s75
f76:
s75:
  goto s66
f75:
  // >8	string		\0
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f77 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">8\tstring\t\t\\0")
  // >>7	byte		0		(SYSV)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f78 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t0\t\t(SYSV)")
  out = append(out, "(SYSV)")
  goto s77
f78:
  // >>7	byte		1		(HP-UX)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f79 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t1\t\t(HP-UX)")
  out = append(out, "(HP-UX)")
  goto s77
f79:
  // >>7	byte		2		(NetBSD)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f80 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t2\t\t(NetBSD)")
  out = append(out, "(NetBSD)")
  goto s77
f80:
  // >>7	byte		3		(GNU/Linux)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f81 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t3\t\t(GNU/Linux)")
  out = append(out, "(GNU/Linux)")
  goto s77
f81:
  // >>7	byte		4		(GNU/Hurd)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f82 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t4\t\t(GNU/Hurd)")
  out = append(out, "(GNU/Hurd)")
  goto s77
f82:
  // >>7	byte		5		(86Open)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f83 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t5\t\t(86Open)")
  out = append(out, "(86Open)")
  goto s77
f83:
  // >>7	byte		6		(Solaris)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f84 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t6\t\t(Solaris)")
  out = append(out, "(Solaris)")
  goto s77
f84:
  // >>7	byte		7		(Monterey)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f85 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t7\t\t(Monterey)")
  out = append(out, "(Monterey)")
  goto s77
f85:
  // >>7	byte		8		(IRIX)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f86 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t8\t\t(IRIX)")
  out = append(out, "(IRIX)")
  goto s77
f86:
  // >>7	byte		9		(FreeBSD)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f87 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t9\t\t(FreeBSD)")
  out = append(out, "(FreeBSD)")
  goto s77
f87:
  // >>7	byte		10		(Tru64)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f88 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t10\t\t(Tru64)")
  out = append(out, "(Tru64)")
  goto s77
f88:
  // >>7	byte		11		(Novell Modesto)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f89 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t11\t\t(Novell Modesto)")
  out = append(out, "(Novell Modesto)")
  goto s77
f89:
  // >>7	byte		12		(OpenBSD)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f90 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t12\t\t(OpenBSD)")
  out = append(out, "(OpenBSD)")
  goto s77
f90:
s77:
  goto s66
f77:
  // >8      string          \2
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f91 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">8      string          \\2")
  // >>7     byte            13              (OpenVMS)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xd)) { goto f92 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7     byte            13              (OpenVMS)")
  out = append(out, "(OpenVMS)")
  goto s91
f92:
  // >>7	byte		97		(ARM)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x61)) { goto f93 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t97\t\t(ARM)")
  out = append(out, "(ARM)")
  goto s91
f93:
  // >>7	byte		255		(embedded)
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f94 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>7\tbyte\t\t255\t\t(embedded)")
  out = append(out, "(embedded)")
  goto s91
f94:
s91:
  goto s66
f91:
s66:
  goto end
f66:
  // 0	lelong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f95 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong&0xfffffffe\t0xfeedface\tMach-O")
  out = append(out, "Mach-O")
  // >0	use	\^mach-o-be
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMachOBe__Swapped(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\\^mach-o-be")
  goto s95
s95:
  goto end
f95:
  // 0	belong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f97 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong&0xfffffffe\t0xfeedface\tMach-O")
  out = append(out, "Mach-O")
  // >0	use	mach-o-be
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMachOBe(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\tmach-o-be")
  goto s97
s97:
  goto end
f97:
  // 0	string/t	@
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x40}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
    if ml < 0 { goto f99 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t@")
  // >1	string/cW	\ echo\ off	DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x6f, 0x66, 0x66}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f100 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\t\\ echo\\ off\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f100:
  // >1	string/cW	echo\ off	DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x65, 0x63, 0x68, 0x6f, 0x20, 0x6f, 0x66, 0x66}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f101 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\techo\\ off\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f101:
  // >1	string/cW	rem		DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x72, 0x65, 0x6d}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f102 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\trem\t\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f102:
  // >1	string/cW	set\ 		DOS batch file text
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x73, 0x65, 0x74, 0x20}, wizardry.StringTestFlags{CompactWhitespace:true, OptionalBlanks:false, LowerMatchesBoth:true, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f103 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1\tstring/cW\tset\\ \t\tDOS batch file text")
  out = append(out, "DOS batch file text")
  goto s99
f103:
s99:
  goto end
f99:
  // 100	search/0xffff   rxfuncadd
  off = pageOff + 0x64
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xffff, "rxfuncadd"))
    if ml < 0 { goto f104 }
    gof = off + ml + 0x9
  }
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   rxfuncadd")
  goto end
f104:
  // 100	search/0xffff   say
  off = pageOff + 0x64
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xffff, "say"))
    if ml < 0 { goto f105 }
    gof = off + ml + 0x3
  }
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   say")
  goto end
f105:
  // 0	leshort		0x166	MS Windows COFF MIPS R4000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x166)) { goto f106 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x166\tMS Windows COFF MIPS R4000 object file")
  out = append(out, "MS Windows COFF MIPS R4000 object file")
  goto end
f106:
  // 0	leshort		0x184	MS Windows COFF Alpha object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x184)) { goto f107 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x184\tMS Windows COFF Alpha object file")
  out = append(out, "MS Windows COFF Alpha object file")
  goto end
f107:
  // 0	leshort		0x268	MS Windows COFF Motorola 68000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x268)) { goto f108 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x268\tMS Windows COFF Motorola 68000 object file")
  out = append(out, "MS Windows COFF Motorola 68000 object file")
  goto end
f108:
  // 0	leshort		0x1f0	MS Windows COFF PowerPC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1f0)) { goto f109 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x1f0\tMS Windows COFF PowerPC object file")
  out = append(out, "MS Windows COFF PowerPC object file")
  goto end
f109:
  // 0	leshort		0x290	MS Windows COFF PA-RISC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x290)) { goto f110 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x290\tMS Windows COFF PA-RISC object file")
  out = append(out, "MS Windows COFF PA-RISC object file")
  goto end
f110:
  // 0	string/b	MZ
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f111 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMZ")
  // >0x18	leshort <0x40 MS-DOS executable
  off = pageOff + 0x18
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) < 0x40)) { goto f112 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">0x18\tleshort <0x40 MS-DOS executable")
  out = append(out, "MS-DOS executable")
  goto s111
f112:
  // >0x18  leshort >0x3f
  off = pageOff + 0x18
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x3f)) { goto f113 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">0x18  leshort >0x3f")
  // >>(0x3c.l) string PE\0\0 PE
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f114 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x45, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f114 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l) string PE\\0\\0 PE")
  out = append(out, "PE")
  // >>>(0x3c.l+24)	leshort		0x010b	\b32 executable
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f115 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x10b)) { goto f115 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x010b\t\\b32 executable")
  out = append(out, "\\b32 executable")
  goto s114
f115:
  // >>>(0x3c.l+24)	leshort		0x020b	\b32+ executable
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f116 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x20b)) { goto f116 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x020b\t\\b32+ executable")
  out = append(out, "\\b32+ executable")
  goto s114
f116:
  // >>>(0x3c.l+24)	leshort		0x0107	ROM image
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f117 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x107)) { goto f117 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x0107\tROM image")
  out = append(out, "ROM image")
  goto s114
f117:
  // >>>(0x3c.l+24)	default		x	Unknown PE signature
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f118 }
    off = i64(ra)
    off = off + 0x18
  }
  // uh oh unhandled kind default
  goto f118
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tdefault\t\tx\tUnknown PE signature")
  out = append(out, "Unknown PE signature")
  // >>>>&0 		leshort		x	0x%x
  off = pageOff + gof + 0x0
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>&0 \t\tleshort\t\tx\t0x%x")
  out = append(out, "0x%x")
  goto s118
s118:
  goto s114
f118:
  // >>>(0x3c.l+22)	leshort&0x2000	>0	(DLL)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f120 }
    off = i64(ra)
    off = off + 0x16
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0x2000 > 0x0)) { goto f120 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+22)\tleshort&0x2000\t>0\t(DLL)")
  out = append(out, "(DLL)")
  goto s114
f120:
  // >>>(0x3c.l+92)	leshort		1	(native)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f121 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f121 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t1\t(native)")
  out = append(out, "(native)")
  goto s114
f121:
  // >>>(0x3c.l+92)	leshort		2	(GUI)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f122 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f122 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t2\t(GUI)")
  out = append(out, "(GUI)")
  goto s114
f122:
  // >>>(0x3c.l+92)	leshort		3	(console)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f123 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f123 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t3\t(console)")
  out = append(out, "(console)")
  goto s114
f123:
  // >>>(0x3c.l+92)	leshort		7	(POSIX)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f124 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f124 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t7\t(POSIX)")
  out = append(out, "(POSIX)")
  goto s114
f124:
  // >>>(0x3c.l+92)	leshort		9	(Windows CE)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f125 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f125 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t9\t(Windows CE)")
  out = append(out, "(Windows CE)")
  goto s114
f125:
  // >>>(0x3c.l+92)	leshort		10	(EFI application)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f126 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f126 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t10\t(EFI application)")
  out = append(out, "(EFI application)")
  goto s114
f126:
  // >>>(0x3c.l+92)	leshort		11	(EFI boot service driver)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f127 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f127 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t11\t(EFI boot service driver)")
  out = append(out, "(EFI boot service driver)")
  goto s114
f127:
  // >>>(0x3c.l+92)	leshort		12	(EFI runtime driver)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f128 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f128 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t12\t(EFI runtime driver)")
  out = append(out, "(EFI runtime driver)")
  goto s114
f128:
  // >>>(0x3c.l+92)	leshort		13	(EFI ROM)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f129 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xd)) { goto f129 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t13\t(EFI ROM)")
  out = append(out, "(EFI ROM)")
  goto s114
f129:
  // >>>(0x3c.l+92)	leshort		14	(XBOX)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f130 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xe)) { goto f130 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t14\t(XBOX)")
  out = append(out, "(XBOX)")
  goto s114
f130:
  // >>>(0x3c.l+92)	leshort		15	(Windows boot application)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f131 }
    off = i64(ra)
    off = off + 0x5c
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xf)) { goto f131 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tleshort\t\t15\t(Windows boot application)")
  out = append(out, "(Windows boot application)")
  goto s114
f131:
  // >>>(0x3c.l+92)	default		x	(Unknown subsystem
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f132 }
    off = i64(ra)
    off = off + 0x5c
  }
  // uh oh unhandled kind default
  goto f132
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+92)\tdefault\t\tx\t(Unknown subsystem")
  out = append(out, "(Unknown subsystem")
  // >>>>&0		leshort		x	0x%x)
  off = pageOff + gof + 0x0
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>&0\t\tleshort\t\tx\t0x%x)")
  out = append(out, "0x%x)")
  goto s132
s132:
  goto s114
f132:
  // >>>(0x3c.l+4)	leshort		0x14c	Intel 80386
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f134 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x14c)) { goto f134 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x14c\tIntel 80386")
  out = append(out, "Intel 80386")
  goto s114
f134:
  // >>>(0x3c.l+4)	leshort		0x166	MIPS R4000
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f135 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x166)) { goto f135 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x166\tMIPS R4000")
  out = append(out, "MIPS R4000")
  goto s114
f135:
  // >>>(0x3c.l+4)	leshort		0x168	MIPS R10000
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f136 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x168)) { goto f136 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x168\tMIPS R10000")
  out = append(out, "MIPS R10000")
  goto s114
f136:
  // >>>(0x3c.l+4)	leshort		0x184	Alpha
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f137 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x184)) { goto f137 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x184\tAlpha")
  out = append(out, "Alpha")
  goto s114
f137:
  // >>>(0x3c.l+4)	leshort		0x1a2	Hitachi SH3
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f138 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1a2)) { goto f138 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1a2\tHitachi SH3")
  out = append(out, "Hitachi SH3")
  goto s114
f138:
  // >>>(0x3c.l+4)	leshort		0x1a6	Hitachi SH4
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f139 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1a6)) { goto f139 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1a6\tHitachi SH4")
  out = append(out, "Hitachi SH4")
  goto s114
f139:
  // >>>(0x3c.l+4)	leshort		0x1c0	ARM
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f140 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1c0)) { goto f140 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1c0\tARM")
  out = append(out, "ARM")
  goto s114
f140:
  // >>>(0x3c.l+4)	leshort		0x1c2	ARM Thumb
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f141 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1c2)) { goto f141 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1c2\tARM Thumb")
  out = append(out, "ARM Thumb")
  goto s114
f141:
  // >>>(0x3c.l+4)	leshort		0x1c4	ARMv7 Thumb
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f142 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1c4)) { goto f142 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1c4\tARMv7 Thumb")
  out = append(out, "ARMv7 Thumb")
  goto s114
f142:
  // >>>(0x3c.l+4)	leshort		0x1f0	PowerPC
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f143 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1f0)) { goto f143 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x1f0\tPowerPC")
  out = append(out, "PowerPC")
  goto s114
f143:
  // >>>(0x3c.l+4)	leshort		0x200	Intel Itanium
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f144 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f144 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x200\tIntel Itanium")
  out = append(out, "Intel Itanium")
  goto s114
f144:
  // >>>(0x3c.l+4)	leshort		0x266	MIPS16
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f145 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x266)) { goto f145 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x266\tMIPS16")
  out = append(out, "MIPS16")
  goto s114
f145:
  // >>>(0x3c.l+4)	leshort		0x268	Motorola 68000
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f146 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x268)) { goto f146 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x268\tMotorola 68000")
  out = append(out, "Motorola 68000")
  goto s114
f146:
  // >>>(0x3c.l+4)	leshort		0x290	PA-RISC
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f147 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x290)) { goto f147 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x290\tPA-RISC")
  out = append(out, "PA-RISC")
  goto s114
f147:
  // >>>(0x3c.l+4)	leshort		0x366	MIPSIV
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f148 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x366)) { goto f148 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x366\tMIPSIV")
  out = append(out, "MIPSIV")
  goto s114
f148:
  // >>>(0x3c.l+4)	leshort		0x466	MIPS16 with FPU
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f149 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x466)) { goto f149 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x466\tMIPS16 with FPU")
  out = append(out, "MIPS16 with FPU")
  goto s114
f149:
  // >>>(0x3c.l+4)	leshort		0xebc	EFI byte code
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f150 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xebc)) { goto f150 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0xebc\tEFI byte code")
  out = append(out, "EFI byte code")
  goto s114
f150:
  // >>>(0x3c.l+4)	leshort		0x8664	x86-64
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f151 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8664)) { goto f151 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0x8664\tx86-64")
  out = append(out, "x86-64")
  goto s114
f151:
  // >>>(0x3c.l+4)	leshort		0xc0ee	MSIL
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f152 }
    off = i64(ra)
    off = off + 0x4
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xc0ee)) { goto f152 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tleshort\t\t0xc0ee\tMSIL")
  out = append(out, "MSIL")
  goto s114
f152:
  // >>>(0x3c.l+4)	default		x	Unknown processor type
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f153 }
    off = i64(ra)
    off = off + 0x4
  }
  // uh oh unhandled kind default
  goto f153
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+4)\tdefault\t\tx\tUnknown processor type")
  out = append(out, "Unknown processor type")
  // >>>>&0		leshort		x	0x%x
  off = pageOff + gof + 0x0
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>&0\t\tleshort\t\tx\t0x%x")
  out = append(out, "0x%x")
  goto s153
s153:
  goto s114
f153:
  // >>>(0x3c.l+22)	leshort&0x0200	>0	(stripped to external PDB)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f155 }
    off = i64(ra)
    off = off + 0x16
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0x200 > 0x0)) { goto f155 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+22)\tleshort&0x0200\t>0\t(stripped to external PDB)")
  out = append(out, "(stripped to external PDB)")
  goto s114
f155:
  // >>>(0x3c.l+22)	leshort&0x1000	>0	system file
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f156 }
    off = i64(ra)
    off = off + 0x16
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0x1000 > 0x0)) { goto f156 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+22)\tleshort&0x1000\t>0\tsystem file")
  out = append(out, "system file")
  goto s114
f156:
  // >>>(0x3c.l+24)	leshort		0x010b
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f157 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x10b)) { goto f157 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x010b")
  // >>>>(0x3c.l+232) lelong	>0	Mono/.Net assembly
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f158 }
    off = i64(ra)
    off = off + 0xe8
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f158 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+232) lelong\t>0\tMono/.Net assembly")
  out = append(out, "Mono/.Net assembly")
  goto s157
f158:
s157:
  goto s114
f157:
  // >>>(0x3c.l+24)	leshort		0x020b
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f159 }
    off = i64(ra)
    off = off + 0x18
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x20b)) { goto f159 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+24)\tleshort\t\t0x020b")
  // >>>>(0x3c.l+248) lelong	>0	Mono/.Net assembly
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f160 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f160 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+248) lelong\t>0\tMono/.Net assembly")
  out = append(out, "Mono/.Net assembly")
  goto s159
f160:
s159:
  goto s114
f159:
  // >>>(8.s*16)		string		32STUB	\b, 32rtm DOS extender
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f161 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x33, 0x32, 0x53, 0x54, 0x55, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f161 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s*16)\t\tstring\t\t32STUB\t\\b, 32rtm DOS extender")
  out = append(out, "\\b, 32rtm DOS extender")
  goto s114
f161:
  // >>>(8.s*16)		string		!32STUB	\b, for MS Windows
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f162 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x33, 0x32, 0x53, 0x54, 0x55, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f162 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s*16)\t\tstring\t\t!32STUB\t\\b, for MS Windows")
  out = append(out, "\\b, for MS Windows")
  goto s114
f162:
  // >>>(0x3c.l+0xf8)	string		UPX0 \b, UPX compressed
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f163 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f163 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tstring\t\tUPX0 \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s114
f163:
  // >>>(0x3c.l+0xf8)	search/0x140	PEC2 \b, PECompact2 compressed
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f164 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, "PEC2"))
    if ml < 0 { goto f164 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\tPEC2 \\b, PECompact2 compressed")
  out = append(out, "\\b, PECompact2 compressed")
  goto s114
f164:
  // >>>(0x3c.l+0xf8)	search/0x140	UPX2
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f165 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, "UPX2"))
    if ml < 0 { goto f165 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\tUPX2")
  // >>>>(&0x10.l+(-4))	string		PK\3\4 \b, ZIP self-extracting archive (Info-Zip)
  {
    ra, ok := readU32be(tb, (gof + 0x10))
    if !ok { goto f166 }
    rb, ok := readU32be(tb, (gof + 0x10) + -4)
    if !ok { goto f166 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x3, 0x4}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f166 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x10.l+(-4))\tstring\t\tPK\\3\\4 \\b, ZIP self-extracting archive (Info-Zip)")
  out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
  goto s165
f166:
s165:
  goto s114
f165:
  // >>>(0x3c.l+0xf8)	search/0x140	.idata
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f167 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".idata"))
    if ml < 0 { goto f167 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.idata")
  // >>>>(&0xe.l+(-4))	string		PK\3\4 \b, ZIP self-extracting archive (Info-Zip)
  {
    ra, ok := readU32be(tb, (gof + 0xe))
    if !ok { goto f168 }
    rb, ok := readU32be(tb, (gof + 0xe) + -4)
    if !ok { goto f168 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x3, 0x4}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f168 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0xe.l+(-4))\tstring\t\tPK\\3\\4 \\b, ZIP self-extracting archive (Info-Zip)")
  out = append(out, "\\b, ZIP self-extracting archive (Info-Zip)")
  goto s167
f168:
  // >>>>(&0xe.l+(-4))	string		ZZ0 \b, ZZip self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xe))
    if !ok { goto f169 }
    rb, ok := readU32be(tb, (gof + 0xe) + -4)
    if !ok { goto f169 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x5a, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f169 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0xe.l+(-4))\tstring\t\tZZ0 \\b, ZZip self-extracting archive")
  out = append(out, "\\b, ZZip self-extracting archive")
  goto s167
f169:
  // >>>>(&0xe.l+(-4))	string		ZZ1 \b, ZZip self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xe))
    if !ok { goto f170 }
    rb, ok := readU32be(tb, (gof + 0xe) + -4)
    if !ok { goto f170 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x5a, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f170 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0xe.l+(-4))\tstring\t\tZZ1 \\b, ZZip self-extracting archive")
  out = append(out, "\\b, ZZip self-extracting archive")
  goto s167
f170:
s167:
  goto s114
f167:
  // >>>(0x3c.l+0xf8)	search/0x140	.rsrc
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f171 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".rsrc"))
    if ml < 0 { goto f171 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.rsrc")
  // >>>>(&0x0f.l+(-4))	string		a\\\4\5 \b, WinHKI self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xf))
    if !ok { goto f172 }
    rb, ok := readU32be(tb, (gof + 0xf) + -4)
    if !ok { goto f172 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x61, 0x5c, 0x4, 0x5}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f172 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tstring\t\ta\\\\\\4\\5 \\b, WinHKI self-extracting archive")
  out = append(out, "\\b, WinHKI self-extracting archive")
  goto s171
f172:
  // >>>>(&0x0f.l+(-4))	string		Rar! \b, RAR self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xf))
    if !ok { goto f173 }
    rb, ok := readU32be(tb, (gof + 0xf) + -4)
    if !ok { goto f173 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x61, 0x72, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f173 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tstring\t\tRar! \\b, RAR self-extracting archive")
  out = append(out, "\\b, RAR self-extracting archive")
  goto s171
f173:
  // >>>>(&0x0f.l+(-4))	search/0x3000	MSCF \b, InstallShield self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xf))
    if !ok { goto f174 }
    rb, ok := readU32be(tb, (gof + 0xf) + -4)
    if !ok { goto f174 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x3000, "MSCF"))
    if ml < 0 { goto f174 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tsearch/0x3000\tMSCF \\b, InstallShield self-extracting archive")
  out = append(out, "\\b, InstallShield self-extracting archive")
  goto s171
f174:
  // >>>>(&0x0f.l+(-4))	search/32	Nullsoft \b, Nullsoft Installer self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xf))
    if !ok { goto f175 }
    rb, ok := readU32be(tb, (gof + 0xf) + -4)
    if !ok { goto f175 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x20, "Nullsoft"))
    if ml < 0 { goto f175 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l+(-4))\tsearch/32\tNullsoft \\b, Nullsoft Installer self-extracting archive")
  out = append(out, "\\b, Nullsoft Installer self-extracting archive")
  goto s171
f175:
s171:
  goto s114
f171:
  // >>>(0x3c.l+0xf8)	search/0x140	.data
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f176 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".data"))
    if ml < 0 { goto f176 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.data")
  // >>>>(&0x0f.l)		string		WEXTRACT \b, MS CAB-Installer self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0xf))
    if !ok { goto f177 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x45, 0x58, 0x54, 0x52, 0x41, 0x43, 0x54}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f177 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>(&0x0f.l)\t\tstring\t\tWEXTRACT \\b, MS CAB-Installer self-extracting archive")
  out = append(out, "\\b, MS CAB-Installer self-extracting archive")
  goto s176
f177:
s176:
  goto s114
f176:
  // >>>(0x3c.l+0xf8)	search/0x140	.petite\0 \b, Petite compressed
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f178 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".petite\x00"))
    if ml < 0 { goto f178 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.petite\\0 \\b, Petite compressed")
  out = append(out, "\\b, Petite compressed")
  // >>>>(0x3c.l+0xf7)	byte		x
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f179 }
    off = i64(ra)
    off = off + 0xf7
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+0xf7)\tbyte\t\tx")
  // >>>>>(&0x104.l+(-4))	string		=!sfx! \b, ACE self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0x104))
    if !ok { goto f180 }
    rb, ok := readU32be(tb, (gof + 0x104) + -4)
    if !ok { goto f180 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x73, 0x66, 0x78, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f180 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>(&0x104.l+(-4))\tstring\t\t=!sfx! \\b, ACE self-extracting archive")
  out = append(out, "\\b, ACE self-extracting archive")
  goto s179
f180:
s179:
  goto s178
f179:
s178:
  goto s114
f178:
  // >>>(0x3c.l+0xf8)	search/0x140	.WISE \b, WISE installer self-extracting archive
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f181 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".WISE"))
    if ml < 0 { goto f181 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.WISE \\b, WISE installer self-extracting archive")
  out = append(out, "\\b, WISE installer self-extracting archive")
  goto s114
f181:
  // >>>(0x3c.l+0xf8)	search/0x140	.dz\0\0\0 \b, Dzip self-extracting archive
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f182 }
    off = i64(ra)
    off = off + 0xf8
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, ".dz\x00\x00\x00"))
    if ml < 0 { goto f182 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0xf8)\tsearch/0x140\t.dz\\0\\0\\0 \\b, Dzip self-extracting archive")
  out = append(out, "\\b, Dzip self-extracting archive")
  goto s114
f182:
  // >>>&(0x3c.l+0xf8)	search/0x100	_winzip_ \b, ZIP self-extracting archive (WinZip)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f183 }
    off = i64(ra)
    off = off + 0xf8
    off += gof
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "_winzip_"))
    if ml < 0 { goto f183 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>&(0x3c.l+0xf8)\tsearch/0x100\t_winzip_ \\b, ZIP self-extracting archive (WinZip)")
  out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
  goto s114
f183:
  // >>>&(0x3c.l+0xf8)	search/0x100	SharedD \b, Microsoft Installer self-extracting archive
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f184 }
    off = i64(ra)
    off = off + 0xf8
    off += gof
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "SharedD"))
    if ml < 0 { goto f184 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>&(0x3c.l+0xf8)\tsearch/0x100\tSharedD \\b, Microsoft Installer self-extracting archive")
  out = append(out, "\\b, Microsoft Installer self-extracting archive")
  goto s114
f184:
  // >>>0x30			string		Inno \b, InnoSetup self-extracting archive
  off = pageOff + 0x30
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x6e, 0x6e, 0x6f}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f185 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>0x30\t\t\tstring\t\tInno \\b, InnoSetup self-extracting archive")
  out = append(out, "\\b, InnoSetup self-extracting archive")
  goto s114
f185:
s114:
  goto s113
f114:
  // >>(0x3c.l) string !PE\0\0 MS-DOS executable
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f186 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x45, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f186 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l) string !PE\\0\\0 MS-DOS executable")
  out = append(out, "MS-DOS executable")
  goto s113
f186:
  // >>(0x3c.l)		string		NE \b, NE
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f187 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f187 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tNE \\b, NE")
  out = append(out, "\\b, NE")
  // >>>(0x3c.l+0x36)	byte		1 for OS/2 1.x
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f188 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f188 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t1 for OS/2 1.x")
  out = append(out, "for OS/2 1.x")
  goto s187
f188:
  // >>>(0x3c.l+0x36)	byte		2 for MS Windows 3.x
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f189 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f189 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t2 for MS Windows 3.x")
  out = append(out, "for MS Windows 3.x")
  goto s187
f189:
  // >>>(0x3c.l+0x36)	byte		3 for MS-DOS
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f190 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f190 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t3 for MS-DOS")
  out = append(out, "for MS-DOS")
  goto s187
f190:
  // >>>(0x3c.l+0x36)	byte		4 for Windows 386
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f191 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f191 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t4 for Windows 386")
  out = append(out, "for Windows 386")
  goto s187
f191:
  // >>>(0x3c.l+0x36)	byte		5 for Borland Operating System Services
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f192 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f192 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t5 for Borland Operating System Services")
  out = append(out, "for Borland Operating System Services")
  goto s187
f192:
  // >>>(0x3c.l+0x36)	default		x
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f193 }
    off = i64(ra)
    off = off + 0x36
  }
  // uh oh unhandled kind default
  goto f193
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tdefault\t\tx")
  // >>>>(0x3c.l+0x36)	byte		x (unknown OS %x)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f194 }
    off = i64(ra)
    off = off + 0x36
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>(0x3c.l+0x36)\tbyte\t\tx (unknown OS %x)")
  out = append(out, "(unknown OS %x)")
  goto s193
f194:
s193:
  goto s187
f193:
  // >>>(0x3c.l+0x36)	byte		0x81 for MS-DOS, Phar Lap DOS extender
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f195 }
    off = i64(ra)
    off = off + 0x36
  }
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x81)) { goto f195 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x36)\tbyte\t\t0x81 for MS-DOS, Phar Lap DOS extender")
  out = append(out, "for MS-DOS, Phar Lap DOS extender")
  goto s187
f195:
  // >>>(0x3c.l+0x0c)	leshort&0x8003	0x8002 (DLL)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f196 }
    off = i64(ra)
    off = off + 0xc
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8003 == 0x8002)) { goto f196 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0c)\tleshort&0x8003\t0x8002 (DLL)")
  out = append(out, "(DLL)")
  goto s187
f196:
  // >>>(0x3c.l+0x0c)	leshort&0x8003	0x8001 (driver)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f197 }
    off = i64(ra)
    off = off + 0xc
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8003 == 0x8001)) { goto f197 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0c)\tleshort&0x8003\t0x8001 (driver)")
  out = append(out, "(driver)")
  goto s187
f197:
  // >>>&(&0x24.s-1)		string		ARJSFX \b, ARJ self-extracting archive
  {
    ra, ok := readU16be(tb, (gof + 0x24))
    if !ok { goto f198 }
    off = i64(ra)
    off = off * 0x1
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x41, 0x52, 0x4a, 0x53, 0x46, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f198 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&(&0x24.s-1)\t\tstring\t\tARJSFX \\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s187
f198:
  // >>>(0x3c.l+0x70)	search/0x80	WinZip(R)\ Self-Extractor \b, ZIP self-extracting archive (WinZip)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f199 }
    off = i64(ra)
    off = off + 0x70
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x80, "WinZip(R) Self-Extractor"))
    if ml < 0 { goto f199 }
    gof = off + ml + 0x18
  }
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x70)\tsearch/0x80\tWinZip(R)\\ Self-Extractor \\b, ZIP self-extracting archive (WinZip)")
  out = append(out, "\\b, ZIP self-extracting archive (WinZip)")
  goto s187
f199:
s187:
  goto s113
f187:
  // >>(0x3c.l)		string		LX\0\0 \b, LX
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f200 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x58, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f200 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tLX\\0\\0 \\b, LX")
  out = append(out, "\\b, LX")
  // >>>(0x3c.l+0x0a)	leshort		<1 (unknown OS)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f201 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) < 0x1)) { goto f201 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t<1 (unknown OS)")
  out = append(out, "(unknown OS)")
  goto s200
f201:
  // >>>(0x3c.l+0x0a)	leshort		1 for OS/2
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f202 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f202 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t1 for OS/2")
  out = append(out, "for OS/2")
  goto s200
f202:
  // >>>(0x3c.l+0x0a)	leshort		2 for MS Windows
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f203 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f203 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t2 for MS Windows")
  out = append(out, "for MS Windows")
  goto s200
f203:
  // >>>(0x3c.l+0x0a)	leshort		3 for DOS
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f204 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f204 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t3 for DOS")
  out = append(out, "for DOS")
  goto s200
f204:
  // >>>(0x3c.l+0x0a)	leshort		>3 (unknown OS)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f205 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x3)) { goto f205 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t>3 (unknown OS)")
  out = append(out, "(unknown OS)")
  goto s200
f205:
  // >>>(0x3c.l+0x10)	lelong&0x28000	=0x8000 (DLL)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f206 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x28000 == 0x8000)) { goto f206 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x28000\t=0x8000 (DLL)")
  out = append(out, "(DLL)")
  goto s200
f206:
  // >>>(0x3c.l+0x10)	lelong&0x20000	>0 (device driver)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f207 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0x20000 > 0x0)) { goto f207 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x20000\t>0 (device driver)")
  out = append(out, "(device driver)")
  goto s200
f207:
  // >>>(0x3c.l+0x10)	lelong&0x300	0x300 (GUI)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f208 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x300 == 0x300)) { goto f208 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x300\t0x300 (GUI)")
  out = append(out, "(GUI)")
  goto s200
f208:
  // >>>(0x3c.l+0x10)	lelong&0x28300	<0x300 (console)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f209 }
    off = i64(ra)
    off = off + 0x10
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0x28300 < 0x300)) { goto f209 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x10)\tlelong&0x28300\t<0x300 (console)")
  out = append(out, "(console)")
  goto s200
f209:
  // >>>(0x3c.l+0x08)	leshort		1 i80286
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f210 }
    off = i64(ra)
    off = off + 0x8
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f210 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x08)\tleshort\t\t1 i80286")
  out = append(out, "i80286")
  goto s200
f210:
  // >>>(0x3c.l+0x08)	leshort		2 i80386
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f211 }
    off = i64(ra)
    off = off + 0x8
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f211 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x08)\tleshort\t\t2 i80386")
  out = append(out, "i80386")
  goto s200
f211:
  // >>>(0x3c.l+0x08)	leshort		3 i80486
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f212 }
    off = i64(ra)
    off = off + 0x8
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f212 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x08)\tleshort\t\t3 i80486")
  out = append(out, "i80486")
  goto s200
f212:
  // >>>(8.s*16)		string		emx \b, emx
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f213 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x65, 0x6d, 0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f213 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s*16)\t\tstring\t\temx \\b, emx")
  out = append(out, "\\b, emx")
  // >>>>&1			string		x %s
  off = pageOff + gof + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f214 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&1\t\t\tstring\t\tx %s")
  out = append(out, "%s")
  goto s213
f214:
s213:
  goto s200
f213:
  // >>>&(&0x54.l-3)		string		arjsfx \b, ARJ self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0x54))
    if !ok { goto f215 }
    off = i64(ra)
    off = off * 0x3
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x61, 0x72, 0x6a, 0x73, 0x66, 0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f215 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&(&0x54.l-3)\t\tstring\t\tarjsfx \\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s200
f215:
s200:
  goto s113
f200:
  // >>(0x3c.l)		string		W3 \b, W3 for MS Windows
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f216 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x33}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f216 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tW3 \\b, W3 for MS Windows")
  out = append(out, "\\b, W3 for MS Windows")
  goto s113
f216:
  // >>(0x3c.l)		string		LE\0\0 \b, LE executable
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f217 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x45, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f217 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(0x3c.l)\t\tstring\t\tLE\\0\\0 \\b, LE executable")
  out = append(out, "\\b, LE executable")
  // >>>(0x3c.l+0x0a)	leshort		1
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f218 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f218 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t1")
  // >>>>0x240		search/0x100	DOS/4G for MS-DOS, DOS4GW DOS extender
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "DOS/4G"))
    if ml < 0 { goto f219 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x240\t\tsearch/0x100\tDOS/4G for MS-DOS, DOS4GW DOS extender")
  out = append(out, "for MS-DOS, DOS4GW DOS extender")
  goto s218
f219:
  // >>>>0x240		search/0x200	WATCOM\ C/C++ for MS-DOS, DOS4GW DOS extender
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x200, "WATCOM C/C++"))
    if ml < 0 { goto f220 }
    gof = off + ml + 0xc
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x240\t\tsearch/0x200\tWATCOM\\ C/C++ for MS-DOS, DOS4GW DOS extender")
  out = append(out, "for MS-DOS, DOS4GW DOS extender")
  goto s218
f220:
  // >>>>0x440		search/0x100	CauseWay\ DOS\ Extender for MS-DOS, CauseWay DOS extender
  off = pageOff + 0x440
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "CauseWay DOS Extender"))
    if ml < 0 { goto f221 }
    gof = off + ml + 0x15
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x440\t\tsearch/0x100\tCauseWay\\ DOS\\ Extender for MS-DOS, CauseWay DOS extender")
  out = append(out, "for MS-DOS, CauseWay DOS extender")
  goto s218
f221:
  // >>>>0x40		search/0x40	PMODE/W for MS-DOS, PMODE/W DOS extender
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x40, "PMODE/W"))
    if ml < 0 { goto f222 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x40\tPMODE/W for MS-DOS, PMODE/W DOS extender")
  out = append(out, "for MS-DOS, PMODE/W DOS extender")
  goto s218
f222:
  // >>>>0x40		search/0x40	STUB/32A for MS-DOS, DOS/32A DOS extender (stub)
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x40, "STUB/32A"))
    if ml < 0 { goto f223 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x40\tSTUB/32A for MS-DOS, DOS/32A DOS extender (stub)")
  out = append(out, "for MS-DOS, DOS/32A DOS extender (stub)")
  goto s218
f223:
  // >>>>0x40		search/0x80	STUB/32C for MS-DOS, DOS/32A DOS extender (configurable stub)
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x80, "STUB/32C"))
    if ml < 0 { goto f224 }
    gof = off + ml + 0x8
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x80\tSTUB/32C for MS-DOS, DOS/32A DOS extender (configurable stub)")
  out = append(out, "for MS-DOS, DOS/32A DOS extender (configurable stub)")
  goto s218
f224:
  // >>>>0x40		search/0x80	DOS/32A for MS-DOS, DOS/32A DOS extender (embedded)
  off = pageOff + 0x40
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x80, "DOS/32A"))
    if ml < 0 { goto f225 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x40\t\tsearch/0x80\tDOS/32A for MS-DOS, DOS/32A DOS extender (embedded)")
  out = append(out, "for MS-DOS, DOS/32A DOS extender (embedded)")
  goto s218
f225:
  // >>>>&0x24		lelong		<0x50
  off = pageOff + gof + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) < 0x50)) { goto f226 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>&0x24\t\tlelong\t\t<0x50")
  // >>>>>(&0x4c.l)		string		\xfc\xb8WATCOM
  {
    ra, ok := readU32be(tb, (gof + 0x4c))
    if !ok { goto f227 }
    off = i64(ra)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0xb8, 0x57, 0x41, 0x54, 0x43, 0x4f, 0x4d}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f227 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>(&0x4c.l)\t\tstring\t\t\\xfc\\xb8WATCOM")
  // >>>>>>&0		search/8	3\xdbf\xb9 \b, 32Lite compressed
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x8, "3\xdbf\xb9"))
    if ml < 0 { goto f228 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>>>>>&0\t\tsearch/8\t3\\xdbf\\xb9 \\b, 32Lite compressed")
  out = append(out, "\\b, 32Lite compressed")
  goto s227
f228:
s227:
  goto s226
f227:
s226:
  goto s218
f226:
s218:
  goto s217
f218:
  // >>>(0x3c.l+0x0a)	leshort		2 for MS Windows
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f229 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f229 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t2 for MS Windows")
  out = append(out, "for MS Windows")
  goto s217
f229:
  // >>>(0x3c.l+0x0a)	leshort		3 for DOS
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f230 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f230 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t3 for DOS")
  out = append(out, "for DOS")
  goto s217
f230:
  // >>>(0x3c.l+0x0a)	leshort		4 for MS Windows (VxD)
  {
    ra, ok := readU32be(tb, 0x3c)
    if !ok { goto f231 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f231 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(0x3c.l+0x0a)\tleshort\t\t4 for MS Windows (VxD)")
  out = append(out, "for MS Windows (VxD)")
  goto s217
f231:
  // >>>(&0x7c.l+0x26)	string		UPX \b, UPX compressed
  {
    ra, ok := readU32be(tb, (gof + 0x7c))
    if !ok { goto f232 }
    off = i64(ra)
    off = off + 0x26
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f232 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(&0x7c.l+0x26)\tstring\t\tUPX \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s217
f232:
  // >>>&(&0x54.l-3)		string		UNACE \b, ACE self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0x54))
    if !ok { goto f233 }
    off = i64(ra)
    off = off * 0x3
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x4e, 0x41, 0x43, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f233 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&(&0x54.l-3)\t\tstring\t\tUNACE \\b, ACE self-extracting archive")
  out = append(out, "\\b, ACE self-extracting archive")
  goto s217
f233:
s217:
  goto s113
f217:
  // >>0x3c		lelong	>0x20000000
  off = pageOff + 0x3c
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x20000000)) { goto f234 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0x3c\t\tlelong\t>0x20000000")
  // >>>(4.s*512)	leshort !0x014c \b, MZ for MS-DOS
  {
    ra, ok := readU16be(tb, 0x4)
    if !ok { goto f235 }
    off = i64(ra)
    off = off * 0x200
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) != 0x14c)) { goto f235 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(4.s*512)\tleshort !0x014c \\b, MZ for MS-DOS")
  out = append(out, "\\b, MZ for MS-DOS")
  goto s234
f235:
s234:
  goto s113
f234:
s113:
  goto s111
f113:
  // >2		long	!0
  off = pageOff + 0x2
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f236 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">2\t\tlong\t!0")
  // >>0x18		leshort <0x40
  off = pageOff + 0x18
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) < 0x40)) { goto f237 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>0x18\t\tleshort <0x40")
  // >>>(4.s*512)	leshort !0x014c
  {
    ra, ok := readU16be(tb, 0x4)
    if !ok { goto f238 }
    off = i64(ra)
    off = off * 0x200
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) != 0x14c)) { goto f238 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>(4.s*512)\tleshort !0x014c")
  // >>>>&(2.s-514)	string	!LE
  {
    ra, ok := readU16be(tb, 0x2)
    if !ok { goto f239 }
    off = i64(ra)
    off = off * 0x202
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f239 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&(2.s-514)\tstring\t!LE")
  // >>>>>&-2	string	!BW \b, MZ for MS-DOS
  off = pageOff + gof + -2
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x57}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f240 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>&-2\tstring\t!BW \\b, MZ for MS-DOS")
  out = append(out, "\\b, MZ for MS-DOS")
  goto s239
f240:
s239:
  goto s238
f239:
  // >>>>&(2.s-514)	string	LE \b, LE
  {
    ra, ok := readU16be(tb, 0x2)
    if !ok { goto f241 }
    off = i64(ra)
    off = off * 0x202
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x45}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f241 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&(2.s-514)\tstring\tLE \\b, LE")
  out = append(out, "\\b, LE")
  // >>>>>0x240	search/0x100	DOS/4G for MS-DOS, DOS4GW DOS extender
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "DOS/4G"))
    if ml < 0 { goto f242 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x240\tsearch/0x100\tDOS/4G for MS-DOS, DOS4GW DOS extender")
  out = append(out, "for MS-DOS, DOS4GW DOS extender")
  goto s241
f242:
s241:
  goto s238
f241:
  // >>>>&(2.s-514)	string	BW
  {
    ra, ok := readU16be(tb, 0x2)
    if !ok { goto f243 }
    off = i64(ra)
    off = off * 0x202
    off += gof
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x57}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f243 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>&(2.s-514)\tstring\tBW")
  // >>>>>0x240	search/0x100	DOS/4G	\b, LE for MS-DOS, DOS4GW DOS extender (embedded)
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "DOS/4G"))
    if ml < 0 { goto f244 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x240\tsearch/0x100\tDOS/4G\t\\b, LE for MS-DOS, DOS4GW DOS extender (embedded)")
  out = append(out, "\\b, LE for MS-DOS, DOS4GW DOS extender (embedded)")
  goto s243
f244:
  // >>>>>0x240	search/0x100	!DOS/4G	\b, BW collection for MS-DOS
  off = pageOff + 0x240
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x100, "!DOS/4G"))
    if ml < 0 { goto f245 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x240\tsearch/0x100\t!DOS/4G\t\\b, BW collection for MS-DOS")
  out = append(out, "\\b, BW collection for MS-DOS")
  goto s243
f245:
s243:
  goto s238
f243:
s238:
  goto s237
f238:
s237:
  goto s236
f237:
s236:
  goto s111
f236:
  // >(4.s*512)	leshort		0x014c \b, COFF
  {
    ra, ok := readU16be(tb, 0x4)
    if !ok { goto f246 }
    off = i64(ra)
    off = off * 0x200
  }
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x14c)) { goto f246 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">(4.s*512)\tleshort\t\t0x014c \\b, COFF")
  out = append(out, "\\b, COFF")
  // >>(8.s*16)	string		go32stub for MS-DOS, DJGPP go32 DOS extender
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f247 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x67, 0x6f, 0x33, 0x32, 0x73, 0x74, 0x75, 0x62}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f247 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(8.s*16)\tstring\t\tgo32stub for MS-DOS, DJGPP go32 DOS extender")
  out = append(out, "for MS-DOS, DJGPP go32 DOS extender")
  goto s246
f247:
  // >>(8.s*16)	string		emx
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f248 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x65, 0x6d, 0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f248 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>(8.s*16)\tstring\t\temx")
  // >>>&1		string		x for DOS, Win or OS/2, emx %s
  off = pageOff + gof + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f249 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&1\t\tstring\t\tx for DOS, Win or OS/2, emx %s")
  out = append(out, "for DOS, Win or OS/2, emx %s")
  goto s248
f249:
s248:
  goto s246
f248:
  // >>&(&0x42.l-3)	byte		x
  {
    ra, ok := readU32be(tb, (gof + 0x42))
    if !ok { goto f250 }
    off = i64(ra)
    off = off * 0x3
    off += gof
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&(&0x42.l-3)\tbyte\t\tx")
  // >>>&0x26	string		UPX \b, UPX compressed
  off = pageOff + gof + 0x26
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f251 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0x26\tstring\t\tUPX \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s250
f251:
s250:
  goto s246
f250:
  // >>&0x2c		search/0xa0	.text
  off = pageOff + gof + 0x2c
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xa0, ".text"))
    if ml < 0 { goto f252 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">>&0x2c\t\tsearch/0xa0\t.text")
  // >>>&0x0b	lelong		<0x2000
  off = pageOff + gof + 0xb
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) < 0x2000)) { goto f253 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>&0x0b\tlelong\t\t<0x2000")
  // >>>>&0		lelong		>0x6000 \b, 32lite compressed
  off = pageOff + gof + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x6000)) { goto f254 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>&0\t\tlelong\t\t>0x6000 \\b, 32lite compressed")
  out = append(out, "\\b, 32lite compressed")
  goto s253
f254:
s253:
  goto s252
f253:
s252:
  goto s246
f252:
s246:
  goto s111
f246:
  // >(8.s*16) string $WdX \b, WDos/X DOS extender
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f255 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x57, 0x64, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f255 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">(8.s*16) string $WdX \\b, WDos/X DOS extender")
  out = append(out, "\\b, WDos/X DOS extender")
  goto s111
f255:
  // >0x35	string	\x8e\xc0\xb9\x08\x00\xf3\xa5\x4a\x75\xeb\x8e\xc3\x8e\xd8\x33\xff\xbe\x30\x00\x05 \b, aPack compressed
  off = pageOff + 0x35
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x8e, 0xc0, 0xb9, 0x8, 0x0, 0xf3, 0xa5, 0x4a, 0x75, 0xeb, 0x8e, 0xc3, 0x8e, 0xd8, 0x33, 0xff, 0xbe, 0x30, 0x0, 0x5}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f256 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x35\tstring\t\\x8e\\xc0\\xb9\\x08\\x00\\xf3\\xa5\\x4a\\x75\\xeb\\x8e\\xc3\\x8e\\xd8\\x33\\xff\\xbe\\x30\\x00\\x05 \\b, aPack compressed")
  out = append(out, "\\b, aPack compressed")
  goto s111
f256:
  // >0xe7	string	LH/2\ 	Self-Extract \b, %s
  off = pageOff + 0xe7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x48, 0x2f, 0x32, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f257 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0xe7\tstring\tLH/2\\ \tSelf-Extract \\b, %s")
  out = append(out, "Self-Extract \\b, %s")
  goto s111
f257:
  // >0x1c	string	UC2X	\b, UCEXE compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x43, 0x32, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f258 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tUC2X\t\\b, UCEXE compressed")
  out = append(out, "\\b, UCEXE compressed")
  goto s111
f258:
  // >0x1c	string	WWP\ 	\b, WWPACK compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x57, 0x50, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f259 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tWWP\\ \t\\b, WWPACK compressed")
  out = append(out, "\\b, WWPACK compressed")
  goto s111
f259:
  // >0x1c	string	RJSX 	\b, ARJ self-extracting archive
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x4a, 0x53, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f260 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tRJSX \t\\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s111
f260:
  // >0x1c	string	diet 	\b, diet compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x64, 0x69, 0x65, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f261 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tdiet \t\\b, diet compressed")
  out = append(out, "\\b, diet compressed")
  goto s111
f261:
  // >0x1c	string	LZ09 	\b, LZEXE v0.90 compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a, 0x30, 0x39}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f262 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tLZ09 \t\\b, LZEXE v0.90 compressed")
  out = append(out, "\\b, LZEXE v0.90 compressed")
  goto s111
f262:
  // >0x1c	string	LZ91 	\b, LZEXE v0.91 compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a, 0x39, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f263 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\tLZ91 \t\\b, LZEXE v0.91 compressed")
  out = append(out, "\\b, LZEXE v0.91 compressed")
  goto s111
f263:
  // >0x1c	string	tz 	\b, TinyProg compressed
  off = pageOff + 0x1c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x74, 0x7a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f264 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1c\tstring\ttz \t\\b, TinyProg compressed")
  out = append(out, "\\b, TinyProg compressed")
  goto s111
f264:
  // >0x1e	string	Copyright\ 1989-1990\ PKWARE\ Inc.	Self-extracting PKZIP archive
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x31, 0x39, 0x38, 0x39, 0x2d, 0x31, 0x39, 0x39, 0x30, 0x20, 0x50, 0x4b, 0x57, 0x41, 0x52, 0x45, 0x20, 0x49, 0x6e, 0x63, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f265 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1e\tstring\tCopyright\\ 1989-1990\\ PKWARE\\ Inc.\tSelf-extracting PKZIP archive")
  out = append(out, "Self-extracting PKZIP archive")
  goto s111
f265:
  // >0x1e	string	PKLITE\ Copr.	Self-extracting PKZIP archive
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x4c, 0x49, 0x54, 0x45, 0x20, 0x43, 0x6f, 0x70, 0x72, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f266 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x1e\tstring\tPKLITE\\ Copr.\tSelf-extracting PKZIP archive")
  out = append(out, "Self-extracting PKZIP archive")
  goto s111
f266:
  // >0x20	search/0xe0	aRJsfX \b, ARJ self-extracting archive
  off = pageOff + 0x20
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xe0, "aRJsfX"))
    if ml < 0 { goto f267 }
    gof = off + ml + 0x6
  }
  fmt.Printf("matched rule: %s\n", ">0x20\tsearch/0xe0\taRJsfX \\b, ARJ self-extracting archive")
  out = append(out, "\\b, ARJ self-extracting archive")
  goto s111
f267:
  // >0x20	string AIN
  off = pageOff + 0x20
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x41, 0x49, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f268 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x20\tstring AIN")
  // >>0x23	string 2	\b, AIN 2.x compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x32}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f269 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x23\tstring 2\t\\b, AIN 2.x compressed")
  out = append(out, "\\b, AIN 2.x compressed")
  goto s268
f269:
  // >>0x23	string <2	\b, AIN 1.x compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x32}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f270 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x23\tstring <2\t\\b, AIN 1.x compressed")
  out = append(out, "\\b, AIN 1.x compressed")
  goto s268
f270:
  // >>0x23	string >2	\b, AIN 1.x compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x32}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f271 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x23\tstring >2\t\\b, AIN 1.x compressed")
  out = append(out, "\\b, AIN 1.x compressed")
  goto s268
f271:
s268:
  goto s111
f268:
  // >0x24	string	LHa's\ SFX \b, LHa self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x48, 0x61, 0x27, 0x73, 0x20, 0x53, 0x46, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f272 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\tLHa's\\ SFX \\b, LHa self-extracting archive")
  out = append(out, "\\b, LHa self-extracting archive")
  goto s111
f272:
  // >0x24	string	LHA's\ SFX \b, LHa self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x48, 0x41, 0x27, 0x73, 0x20, 0x53, 0x46, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f273 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\tLHA's\\ SFX \\b, LHa self-extracting archive")
  out = append(out, "\\b, LHa self-extracting archive")
  goto s111
f273:
  // >0x24	string	\ $ARX \b, ARX self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x41, 0x52, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f274 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\t\\ $ARX \\b, ARX self-extracting archive")
  out = append(out, "\\b, ARX self-extracting archive")
  goto s111
f274:
  // >0x24	string	\ $LHarc \b, LHarc self-extracting archive
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x4c, 0x48, 0x61, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f275 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\t\\ $LHarc \\b, LHarc self-extracting archive")
  out = append(out, "\\b, LHarc self-extracting archive")
  goto s111
f275:
  // >0x20	string	SFX\ by\ LARC \b, LARC self-extracting archive
  off = pageOff + 0x20
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x46, 0x58, 0x20, 0x62, 0x79, 0x20, 0x4c, 0x41, 0x52, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f276 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x20\tstring\tSFX\\ by\\ LARC \\b, LARC self-extracting archive")
  out = append(out, "\\b, LARC self-extracting archive")
  goto s111
f276:
  // >0x40	string aPKG \b, aPackage self-extracting archive
  off = pageOff + 0x40
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x61, 0x50, 0x4b, 0x47}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f277 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x40\tstring aPKG \\b, aPackage self-extracting archive")
  out = append(out, "\\b, aPackage self-extracting archive")
  goto s111
f277:
  // >0x64	string	W\ Collis\0\0 \b, Compack compressed
  off = pageOff + 0x64
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f278 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x64\tstring\tW\\ Collis\\0\\0 \\b, Compack compressed")
  out = append(out, "\\b, Compack compressed")
  goto s111
f278:
  // >0x7a	string		Windows\ self-extracting\ ZIP	\b, ZIP self-extracting archive
  off = pageOff + 0x7a
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x73, 0x65, 0x6c, 0x66, 0x2d, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x5a, 0x49, 0x50}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f279 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x7a\tstring\t\tWindows\\ self-extracting\\ ZIP\t\\b, ZIP self-extracting archive")
  out = append(out, "\\b, ZIP self-extracting archive")
  // >>&0xf4 search/0x140 \x0\x40\x1\x0
  off = pageOff + gof + 0xf4
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x140, "\x00@\x01\x00"))
    if ml < 0 { goto f280 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>&0xf4 search/0x140 \\x0\\x40\\x1\\x0")
  // >>>(&0.l+(4)) string MSCF \b, WinHKI CAB self-extracting archive
  {
    ra, ok := readU32be(tb, (gof + 0x0))
    if !ok { goto f281 }
    rb, ok := readU32be(tb, (gof + 0x0) + 0x4)
    if !ok { goto f281 }
    off = i64(ra)
    off = off + i64(rb)
  }
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f281 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>(&0.l+(4)) string MSCF \\b, WinHKI CAB self-extracting archive")
  out = append(out, "\\b, WinHKI CAB self-extracting archive")
  goto s280
f281:
s280:
  goto s279
f280:
s279:
  goto s111
f279:
  // >1638	string	-lh5- \b, LHa self-extracting archive v2.13S
  off = pageOff + 0x666
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x2d, 0x6c, 0x68, 0x35, 0x2d}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f282 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">1638\tstring\t-lh5- \\b, LHa self-extracting archive v2.13S")
  out = append(out, "\\b, LHa self-extracting archive v2.13S")
  goto s111
f282:
  // >0x17888 string Rar! \b, RAR self-extracting archive
  off = pageOff + 0x17888
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x61, 0x72, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f283 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x17888 string Rar! \\b, RAR self-extracting archive")
  out = append(out, "\\b, RAR self-extracting archive")
  goto s111
f283:
  // >(4.s*512)	long	x
  {
    ra, ok := readU16be(tb, 0x4)
    if !ok { goto f284 }
    off = i64(ra)
    off = off * 0x200
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(4.s*512)\tlong\tx")
  // >>&(2.s-517)	byte	x
  {
    ra, ok := readU16be(tb, 0x2)
    if !ok { goto f285 }
    off = i64(ra)
    off = off * 0x205
    off += gof
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&(2.s-517)\tbyte\tx")
  // >>>&0	string		PK\3\4 \b, ZIP self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x3, 0x4}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f286 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\tPK\\3\\4 \\b, ZIP self-extracting archive")
  out = append(out, "\\b, ZIP self-extracting archive")
  goto s285
f286:
  // >>>&0	string		Rar! \b, RAR self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x61, 0x72, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f287 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\tRar! \\b, RAR self-extracting archive")
  out = append(out, "\\b, RAR self-extracting archive")
  goto s285
f287:
  // >>>&0	string		=!\x11 \b, AIN 2.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x11}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f288 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x11 \\b, AIN 2.x self-extracting archive")
  out = append(out, "\\b, AIN 2.x self-extracting archive")
  goto s285
f288:
  // >>>&0	string		=!\x12 \b, AIN 2.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x12}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f289 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x12 \\b, AIN 2.x self-extracting archive")
  out = append(out, "\\b, AIN 2.x self-extracting archive")
  goto s285
f289:
  // >>>&0	string		=!\x17 \b, AIN 1.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x17}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f290 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x17 \\b, AIN 1.x self-extracting archive")
  out = append(out, "\\b, AIN 1.x self-extracting archive")
  goto s285
f290:
  // >>>&0	string		=!\x18 \b, AIN 1.x self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x18}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f291 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\t=!\\x18 \\b, AIN 1.x self-extracting archive")
  out = append(out, "\\b, AIN 1.x self-extracting archive")
  goto s285
f291:
  // >>>&7	search/400	**ACE** \b, ACE self-extracting archive
  off = pageOff + gof + 0x7
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x190, "**ACE**"))
    if ml < 0 { goto f292 }
    gof = off + ml + 0x7
  }
  fmt.Printf("matched rule: %s\n", ">>>&7\tsearch/400\t**ACE** \\b, ACE self-extracting archive")
  out = append(out, "\\b, ACE self-extracting archive")
  goto s285
f292:
  // >>>&0	search/0x480	UC2SFX\ Header \b, UC2 self-extracting archive
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x480, "UC2SFX Header"))
    if ml < 0 { goto f293 }
    gof = off + ml + 0xd
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tsearch/0x480\tUC2SFX\\ Header \\b, UC2 self-extracting archive")
  out = append(out, "\\b, UC2 self-extracting archive")
  goto s285
f293:
s285:
  goto s284
f285:
s284:
  goto s111
f284:
  // >(8.s*16)	search/0x20	PKSFX \b, ZIP self-extracting archive (PKZIP)
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f294 }
    off = i64(ra)
    off = off * 0x10
  }
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x20, "PKSFX"))
    if ml < 0 { goto f294 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">(8.s*16)\tsearch/0x20\tPKSFX \\b, ZIP self-extracting archive (PKZIP)")
  out = append(out, "\\b, ZIP self-extracting archive (PKZIP)")
  goto s111
f294:
  // >49801	string	\x79\xff\x80\xff\x76\xff	\b, CODEC archive v3.21
  off = pageOff + 0xc289
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x79, 0xff, 0x80, 0xff, 0x76, 0xff}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f295 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">49801\tstring\t\\x79\\xff\\x80\\xff\\x76\\xff\t\\b, CODEC archive v3.21")
  out = append(out, "\\b, CODEC archive v3.21")
  // >>49824 leshort		=1			\b, 1 file
  off = pageOff + 0xc2a0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f296 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>49824 leshort\t\t=1\t\t\t\\b, 1 file")
  out = append(out, "\\b, 1 file")
  goto s295
f296:
  // >>49824 leshort		>1			\b, %u files
  off = pageOff + 0xc2a0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f297 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>49824 leshort\t\t>1\t\t\t\\b, %u files")
  out = append(out, "\\b, %u files")
  goto s295
f297:
s295:
  goto s111
f295:
s111:
  goto end
f111:
  // 0	string/b	KCF		FreeDOS KEYBoard Layout collection
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x43, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f298 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKCF\t\tFreeDOS KEYBoard Layout collection")
  out = append(out, "FreeDOS KEYBoard Layout collection")
  // >3	uleshort	x		\b, version 0x%x
  off = pageOff + 0x3
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">3\tuleshort\tx\t\t\\b, version 0x%x")
  out = append(out, "\\b, version 0x%x")
  goto s298
  // >6	ubyte		>0
  off = pageOff + 0x6
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f300 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">6\tubyte\t\t>0")
  // >>7	string		>\0		\b, author=%-.14s
  off = pageOff + 0x7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f301 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>7\tstring\t\t>\\0\t\t\\b, author=%-.14s")
  out = append(out, "\\b, author=%-.14s")
  goto s300
f301:
  // >>7	search/254	\xff		\b, info=
  off = pageOff + 0x7
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xfe, "\xff"))
    if ml < 0 { goto f302 }
    gof = off + ml + 0x1
  }
  fmt.Printf("matched rule: %s\n", ">>7\tsearch/254\t\\xff\t\t\\b, info=")
  out = append(out, "\\b, info=")
  // >>>&0	string		x		\b%-.15s
  off = pageOff + gof + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f303 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&0\tstring\t\tx\t\t\\b%-.15s")
  out = append(out, "\\b%-.15s")
  goto s302
f303:
s302:
  goto s300
f302:
s300:
  goto s298
f300:
s298:
  goto end
f298:
  // 0	string/b	KLF		FreeDOS KEYBoard Layout file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f304 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKLF\t\tFreeDOS KEYBoard Layout file")
  out = append(out, "FreeDOS KEYBoard Layout file")
  // >3	uleshort	x		\b, version 0x%x
  off = pageOff + 0x3
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">3\tuleshort\tx\t\t\\b, version 0x%x")
  out = append(out, "\\b, version 0x%x")
  goto s304
  // >5	ubyte		>0
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f306 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tubyte\t\t>0")
  // >>8	string		x		\b, name=%-.2s
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f307 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>8\tstring\t\tx\t\t\\b, name=%-.2s")
  out = append(out, "\\b, name=%-.2s")
  goto s306
f307:
s306:
  goto s304
f306:
s304:
  goto end
f304:
  // 0	string	\xffKEYB\ \ \ \0\0\0\0
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xff, 0x4b, 0x45, 0x59, 0x42, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f308 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xffKEYB\\ \\ \\ \\0\\0\\0\\0")
  // >12	string	\0\0\0\0`\004\360	MS-DOS KEYBoard Layout file
  off = pageOff + 0xc
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x60, 0x4, 0xf0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f309 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">12\tstring\t\\0\\0\\0\\0`\\004\\360\tMS-DOS KEYBoard Layout file")
  out = append(out, "MS-DOS KEYBoard Layout file")
  goto s308
f309:
s308:
  goto end
f308:
  // 0	ulequad&0x07a0ffffffff		0xffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv)&0x7a0ffffffff == 0xffffffff)) { goto f310 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad&0x07a0ffffffff\t\t0xffffffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s310
s310:
  goto end
f310:
  // 0	ulequad				0x0513c00000000012
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x513c00000000012)) { goto f312 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0513c00000000012")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s312
s312:
  goto end
f312:
  // 0	ulequad				0x32f28000ffff0016
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x32f28000ffff0016)) { goto f314 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x32f28000ffff0016")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s314
s314:
  goto end
f314:
  // 0	ulequad				0x007f00000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x7f00000000ffff)) { goto f316 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x007f00000000ffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s316
s316:
  goto end
f316:
  // 0	ulequad				0x001600000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x1600000000ffff)) { goto f318 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x001600000000ffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s318
s318:
  goto end
f318:
  // 0	ulequad				0x0bf708c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0xbf708c2ffffffff)) { goto f320 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0bf708c2ffffffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s320
s320:
  goto end
f320:
  // 0	ulequad				0x07bd08c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x7bd08c2ffffffff)) { goto f322 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x07bd08c2ffffffff")
  // >0	use				msdos-driver
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosDriver(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\t\t\tmsdos-driver")
  goto s322
s322:
  goto end
f322:
  // 0	ubyte		0x8c
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x8c)) { goto f324 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0x8c")
  // >4	string			!O====
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4f, 0x3d, 0x3d, 0x3d, 0x3d}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f325 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\t\t!O====")
  // >>5	string			!MAIN
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x41, 0x49, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f326 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>5\tstring\t\t\t!MAIN")
  // >>>4	ubyte			>13	DOS executable (COM, 0x8C-variant)
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0xd)) { goto f327 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>4\tubyte\t\t\t>13\tDOS executable (COM, 0x8C-variant)")
  out = append(out, "DOS executable (COM, 0x8C-variant)")
  goto s326
f327:
s326:
  goto s325
f326:
s325:
  goto s324
f325:
s324:
  goto end
f324:
  // 0	ulelong		0xffff10eb	DR-DOS executable (COM)
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xffff10eb)) { goto f328 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tulelong\t\t0xffff10eb\tDR-DOS executable (COM)")
  out = append(out, "DR-DOS executable (COM)")
  goto end
f328:
  // 0	ubeshort&0xeb8d	>0xeb00
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0xeb8d > 0xeb00)) { goto f329 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tubeshort&0xeb8d\t>0xeb00")
  goto end
f329:
  // 0	        byte	0xeb
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xeb)) { goto f330 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0\t        byte\t0xeb")
  // >1          byte    >-1
  off = pageOff + 0x1
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > -1)) { goto f331 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">1          byte    >-1")
  // >>(1.b+2)   byte    x
  {
    ra, ok := readU8be(tb, 0x1)
    if !ok { goto f332 }
    off = i64(ra)
    off = off + 0x2
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>(1.b+2)   byte    x")
  // >>>0        use msdos-com
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosCom(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>0        use msdos-com")
  goto s332
s332:
  goto s331
f332:
s331:
  goto s330
f331:
s330:
  goto end
f330:
  // 0           byte    0xe9
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xe9)) { goto f334 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0           byte    0xe9")
  // >1          short   >-1
  off = pageOff + 0x1
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > -1)) { goto f335 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">1          short   >-1")
  // >>(1.s+3)   byte    x
  {
    ra, ok := readU16be(tb, 0x1)
    if !ok { goto f336 }
    off = i64(ra)
    off = off + 0x3
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>(1.s+3)   byte    x")
  // >>>0        use msdos-com
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosCom(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>0        use msdos-com")
  goto s336
s336:
  goto s335
f336:
s335:
  goto s334
f335:
  // >1          short   <-259
  off = pageOff + 0x1
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) < -259)) { goto f338 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">1          short   <-259")
  // >>(1,s+65539)   byte    x
  {
    ra, ok := readU16be(tb, 0x1)
    if !ok { goto f339 }
    off = i64(ra)
    off = off + 0x10003
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>(1,s+65539)   byte    x")
  // >>>0        use msdos-com
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMsdosCom(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>0        use msdos-com")
  goto s339
s339:
  goto s338
f339:
s338:
  goto s334
f338:
s334:
  goto end
f334:
  // 0	ubyte		0xb8
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xb8)) { goto f341 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0xb8")
  // >0	string		!\xb8\xc0\x07\x8e
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xb8, 0xc0, 0x7, 0x8e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f342 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0\tstring\t\t!\\xb8\\xc0\\x07\\x8e")
  // >>1	lelong&0xFFFFFFFe 0x21CD4CFe	COM executable (32-bit COMBOOT
  off = pageOff + 0x1
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0x21cd4cfe)) { goto f343 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>1\tlelong&0xFFFFFFFe 0x21CD4CFe\tCOM executable (32-bit COMBOOT")
  out = append(out, "COM executable (32-bit COMBOOT")
  // >>>1	lelong		0x21CD4CFf	\b)
  off = pageOff + 0x1
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x21cd4cff)) { goto f344 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>1\tlelong\t\t0x21CD4CFf\t\\b)")
  out = append(out, "\\b)")
  goto s343
f344:
  // >>>1	lelong		0x21CD4CFe	\b, relocatable)
  off = pageOff + 0x1
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x21cd4cfe)) { goto f345 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>1\tlelong\t\t0x21CD4CFe\t\\b, relocatable)")
  out = append(out, "\\b, relocatable)")
  goto s343
f345:
s343:
  goto s342
f343:
  // >>1	default	x			COM executable for DOS
  off = pageOff + 0x1
  // uh oh unhandled kind default
  goto f346
  fmt.Printf("matched rule: %s\n", ">>1\tdefault\tx\t\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto s342
f346:
s342:
  goto s341
f342:
s341:
  goto end
f341:
  // 0	string/b	\x81\xfc
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x81, 0xfc}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f347 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x81\\xfc")
  // >4	string	\x77\x02\xcd\x20\xb9
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x77, 0x2, 0xcd, 0x20, 0xb9}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f348 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\\x77\\x02\\xcd\\x20\\xb9")
  // >>36	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f349 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>36\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto s348
f349:
s348:
  goto s347
f348:
s347:
  goto end
f347:
  // 252	string Must\ have\ DOS\ version DR-DOS executable (COM)
  off = pageOff + 0xfc
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x75, 0x73, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f350 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "252\tstring Must\\ have\\ DOS\\ version DR-DOS executable (COM)")
  out = append(out, "DR-DOS executable (COM)")
  goto end
f350:
  // 34	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x22
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f351 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "34\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto end
f351:
  // 35	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x23
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f352 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "35\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto end
f352:
  // 2	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x2
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f353 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f353:
  // 4	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f354 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "4\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f354:
  // 5	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f355 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "5\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f355:
  // 7	string	\xcd\x21
  off = pageOff + 0x7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f356 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "7\tstring\t\\xcd\\x21")
  // >0	byte	!0xb8			COM executable for DOS
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0xb8)) { goto f357 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tbyte\t!0xb8\t\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto s356
f357:
s356:
  goto end
f356:
  // 10	string	\xcd\x21
  off = pageOff + 0xa
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f358 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "10\tstring\t\\xcd\\x21")
  // >5	string	!\xcd\x21		COM executable for DOS
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml >= 0 { goto f359 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">5\tstring\t!\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto s358
f359:
s358:
  goto end
f358:
  // 13	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0xd
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f360 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "13\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f360:
  // 18	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x12
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f361 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "18\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f361:
  // 23	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x17
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f362 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "23\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f362:
  // 30	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f363 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "30\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f363:
  // 70	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x46
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f364 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "70\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  goto end
f364:
  // 0x6	search/0xa	\xfc\x57\xf3\xa5\xc3	COM executable for MS-DOS
  off = pageOff + 0x6
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa5\xc3"))
    if ml < 0 { goto f365 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa5\\xc3\tCOM executable for MS-DOS")
  out = append(out, "COM executable for MS-DOS")
  goto end
f365:
  // 0x6	search/0xa	\xfc\x57\xf3\xa4\xc3	COM executable for DOS
  off = pageOff + 0x6
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa4\xc3"))
    if ml < 0 { goto f366 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa4\\xc3\tCOM executable for DOS")
  out = append(out, "COM executable for DOS")
  // >0x18	search/0x10	\x50\xa4\xff\xd5\x73	\b, aPack compressed
  off = pageOff + 0x18
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x10, "P\xa4\xff\xd5s"))
    if ml < 0 { goto f367 }
    gof = off + ml + 0x5
  }
  fmt.Printf("matched rule: %s\n", ">0x18\tsearch/0x10\t\\x50\\xa4\\xff\\xd5\\x73\t\\b, aPack compressed")
  out = append(out, "\\b, aPack compressed")
  goto s366
f367:
s366:
  goto end
f366:
  // 0x3c	string		W\ Collis\0\0		COM executable for MS-DOS, Compack compressed
  off = pageOff + 0x3c
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f368 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0x3c\tstring\t\tW\\ Collis\\0\\0\t\tCOM executable for MS-DOS, Compack compressed")
  out = append(out, "COM executable for MS-DOS, Compack compressed")
  goto end
f368:
  // 0	string/b	LZ		MS-DOS executable (built-in)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f369 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tLZ\t\tMS-DOS executable (built-in)")
  out = append(out, "MS-DOS executable (built-in)")
  goto end
f369:
  // 0	string/b	\320\317\021\340\241\261\032\341AAFB\015\000OM\006\016\053\064\001\001\001\377			AAF legacy file using MS Structured Storage
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x41, 0x41, 0x46, 0x42, 0xd, 0x0, 0x4f, 0x4d, 0x6, 0xe, 0x2b, 0x34, 0x1, 0x1, 0x1, 0xff}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f370 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341AAFB\\015\\000OM\\006\\016\\053\\064\\001\\001\\001\\377\t\t\tAAF legacy file using MS Structured Storage")
  out = append(out, "AAF legacy file using MS Structured Storage")
  // >30	byte	9		(512B sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f371 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t9\t\t(512B sectors)")
  out = append(out, "(512B sectors)")
  goto s370
f371:
  // >30	byte	12		(4kB sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f372 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t12\t\t(4kB sectors)")
  out = append(out, "(4kB sectors)")
  goto s370
f372:
s370:
  goto end
f370:
  // 0	string/b	\320\317\021\340\241\261\032\341\001\002\001\015\000\002\000\000\006\016\053\064\003\002\001\001			AAF file using MS Structured Storage
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x1, 0x2, 0x1, 0xd, 0x0, 0x2, 0x0, 0x0, 0x6, 0xe, 0x2b, 0x34, 0x3, 0x2, 0x1, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f373 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\\001\\002\\001\\015\\000\\002\\000\\000\\006\\016\\053\\064\\003\\002\\001\\001\t\t\tAAF file using MS Structured Storage")
  out = append(out, "AAF file using MS Structured Storage")
  // >30	byte	9		(512B sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f374 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t9\t\t(512B sectors)")
  out = append(out, "(512B sectors)")
  goto s373
f374:
  // >30	byte	12		(4kB sectors)
  off = pageOff + 0x1e
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xc)) { goto f375 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">30\tbyte\t12\t\t(4kB sectors)")
  out = append(out, "(4kB sectors)")
  goto s373
f375:
s373:
  goto end
f373:
  // 2080	string	Microsoft\ Word\ 6.0\ Document	%s
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36, 0x2e, 0x30, 0x20, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f376 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Word\\ 6.0\\ Document\t%s")
  out = append(out, "%s")
  goto end
f376:
  // 2080	string	Documento\ Microsoft\ Word\ 6 Spanish Microsoft Word 6 document data
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f377 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tDocumento\\ Microsoft\\ Word\\ 6 Spanish Microsoft Word 6 document data")
  out = append(out, "Spanish Microsoft Word 6 document data")
  goto end
f377:
  // 2112	string	MSWordDoc			Microsoft Word document data
  off = pageOff + 0x840
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x6f, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f378 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2112\tstring\tMSWordDoc\t\t\tMicrosoft Word document data")
  out = append(out, "Microsoft Word document data")
  goto end
f378:
  // 0	belong	0x31be0000			Microsoft Word Document
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x31be0000)) { goto f379 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x31be0000\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f379:
  // 0	string/b	PO^Q`				Microsoft Word 6.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4f, 0x5e, 0x51, 0x60}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f380 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPO^Q`\t\t\t\tMicrosoft Word 6.0 Document")
  out = append(out, "Microsoft Word 6.0 Document")
  goto end
f380:
  // 4   long        0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f381 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "4   long        0")
  // >0  belong      0xfe320000      Microsoft Word for Macintosh 1.0
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xfe320000)) { goto f382 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe320000      Microsoft Word for Macintosh 1.0")
  out = append(out, "Microsoft Word for Macintosh 1.0")
  goto s381
f382:
  // >0  belong      0xfe340000      Microsoft Word for Macintosh 3.0
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xfe340000)) { goto f383 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe340000      Microsoft Word for Macintosh 3.0")
  out = append(out, "Microsoft Word for Macintosh 3.0")
  goto s381
f383:
  // >0  belong      0xfe37001c      Microsoft Word for Macintosh 4.0
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xfe37001c)) { goto f384 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe37001c      Microsoft Word for Macintosh 4.0")
  out = append(out, "Microsoft Word for Macintosh 4.0")
  goto s381
f384:
  // >0  belong      0xfe370023      Microsoft Word for Macintosh 5.0
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xfe370023)) { goto f385 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0  belong      0xfe370023      Microsoft Word for Macintosh 5.0")
  out = append(out, "Microsoft Word for Macintosh 5.0")
  goto s381
f385:
s381:
  goto end
f381:
  // 0	string/b	\333\245-\0\0\0			Microsoft Word 2.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f386 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\333\\245-\\0\\0\\0\t\t\tMicrosoft Word 2.0 Document")
  out = append(out, "Microsoft Word 2.0 Document")
  goto end
f386:
  // 512	string/b	\354\245\301			Microsoft Word Document
  off = pageOff + 0x200
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xec, 0xa5, 0xc1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f387 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "512\tstring/b\t\\354\\245\\301\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f387:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f388 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto end
f388:
  // 2080	string	Microsoft\ Excel\ 5.0\ Worksheet	%s
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65, 0x6c, 0x20, 0x35, 0x2e, 0x30, 0x20, 0x57, 0x6f, 0x72, 0x6b, 0x73, 0x68, 0x65, 0x65, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f389 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Excel\\ 5.0\\ Worksheet\t%s")
  out = append(out, "%s")
  goto end
f389:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f390 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto end
f390:
  // 2080	string	Foglio\ di\ lavoro\ Microsoft\ Exce	%s
  off = pageOff + 0x820
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x46, 0x6f, 0x67, 0x6c, 0x69, 0x6f, 0x20, 0x64, 0x69, 0x20, 0x6c, 0x61, 0x76, 0x6f, 0x72, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f391 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tFoglio\\ di\\ lavoro\\ Microsoft\\ Exce\t%s")
  out = append(out, "%s")
  goto end
f391:
  // 2114	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x842
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f392 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2114\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto end
f392:
  // 2121	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x849
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f393 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2121\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto end
f393:
  // 0	string/b	\x09\x04\x06\x00\x00\x00\x10\x00	Microsoft Excel Worksheet
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x9, 0x4, 0x6, 0x0, 0x0, 0x0, 0x10, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f394 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x09\\x04\\x06\\x00\\x00\\x00\\x10\\x00\tMicrosoft Excel Worksheet")
  out = append(out, "Microsoft Excel Worksheet")
  goto end
f394:
  // 0	belong	0x00001a00
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1a00)) { goto f395 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00001a00")
  // >20	ubyte		>0
  off = pageOff + 0x14
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f396 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">20\tubyte\t\t>0")
  // >>20	ubyte		<32	Lotus 1-2-3
  off = pageOff + 0x14
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) < 0x20)) { goto f397 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>20\tubyte\t\t<32\tLotus 1-2-3")
  out = append(out, "Lotus 1-2-3")
  // >>>4	uleshort	0x1000	WorKsheet, version 3
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1000)) { goto f398 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1000\tWorKsheet, version 3")
  out = append(out, "WorKsheet, version 3")
  goto s397
f398:
  // >>>4	uleshort	0x1002	WorKsheet, version 4
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1002)) { goto f399 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1002\tWorKsheet, version 4")
  out = append(out, "WorKsheet, version 4")
  goto s397
f399:
  // >>>4	uleshort	0x1003	WorKsheet, version 97
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1003)) { goto f400 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1003\tWorKsheet, version 97")
  out = append(out, "WorKsheet, version 97")
  goto s397
f400:
  // >>>4	uleshort	0x1005	WorKsheet, version 9.8 Millennium
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1005)) { goto f401 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1005\tWorKsheet, version 9.8 Millennium")
  out = append(out, "WorKsheet, version 9.8 Millennium")
  goto s397
f401:
  // >>>4	uleshort	0x8001	FoRMatting data
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8001)) { goto f402 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8001\tFoRMatting data")
  out = append(out, "FoRMatting data")
  goto s397
f402:
  // >>>4	uleshort	0x8007	ForMatting data, version 3
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8007)) { goto f403 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8007\tForMatting data, version 3")
  out = append(out, "ForMatting data, version 3")
  goto s397
f403:
  // >>>4	default		x	unknown
  off = pageOff + 0x4
  // uh oh unhandled kind default
  goto f404
  fmt.Printf("matched rule: %s\n", ">>>4\tdefault\t\tx\tunknown")
  out = append(out, "unknown")
  // >>>>6	uleshort	=0x0004	worksheet
  off = pageOff + 0x6
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f405 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>6\tuleshort\t=0x0004\tworksheet")
  out = append(out, "worksheet")
  goto s404
f405:
  // >>>>6	uleshort	!0x0004	formatting data
  off = pageOff + 0x6
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) != 0x4)) { goto f406 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>6\tuleshort\t!0x0004\tformatting data")
  out = append(out, "formatting data")
  goto s404
f406:
  // >>>>4	uleshort	x	\b, revision 0x%x
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4\tuleshort\tx\t\\b, revision 0x%x")
  out = append(out, "\\b, revision 0x%x")
  goto s404
s404:
  goto s397
f404:
  // >>>6	uleshort	=0x0004	\b, cell range
  off = pageOff + 0x6
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f408 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>6\tuleshort\t=0x0004\t\\b, cell range")
  out = append(out, "\\b, cell range")
  // >>>>8	ulelong		!0
  off = pageOff + 0x8
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f409 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>8\tulelong\t\t!0")
  // >>>>>10	ubyte		>0	\b%d*
  off = pageOff + 0xa
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f410 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>10\tubyte\t\t>0\t\\b%d*")
  out = append(out, "\\b%d*")
  goto s409
f410:
  // >>>>>8	uleshort	x	\b%d,
  off = pageOff + 0x8
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>>8\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s409
  // >>>>>11	ubyte		x	\b%d-
  off = pageOff + 0xb
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>11\tubyte\t\tx\t\\b%d-")
  out = append(out, "\\b%d-")
  goto s409
s409:
  goto s408
f409:
  // >>>>14	ubyte		>0	\b%d*
  off = pageOff + 0xe
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f413 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>14\tubyte\t\t>0\t\\b%d*")
  out = append(out, "\\b%d*")
  goto s408
f413:
  // >>>>12	uleshort	x	\b%d,
  off = pageOff + 0xc
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>12\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s408
  // >>>>15	ubyte		x	\b%d
  off = pageOff + 0xf
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>15\tubyte\t\tx\t\\b%d")
  out = append(out, "\\b%d")
  goto s408
  // >>>>20	ubyte		>1	\b, character set 0x%x
  off = pageOff + 0x14
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x1)) { goto f416 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>20\tubyte\t\t>1\t\\b, character set 0x%x")
  out = append(out, "\\b, character set 0x%x")
  goto s408
f416:
  // >>>>21	ubyte		x	\b, flags 0x%x
  off = pageOff + 0x15
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>21\tubyte\t\tx\t\\b, flags 0x%x")
  out = append(out, "\\b, flags 0x%x")
  goto s408
s408:
  goto s397
f408:
  // >>>6	uleshort	!0x0004
  off = pageOff + 0x6
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) != 0x4)) { goto f418 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>6\tuleshort\t!0x0004")
  // >>>>30	search/29	\0\xAE
  off = pageOff + 0x1e
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x1d, "\x00\xae"))
    if ml < 0 { goto f419 }
    gof = off + ml + 0x2
  }
  fmt.Printf("matched rule: %s\n", ">>>>30\tsearch/29\t\\0\\xAE")
  // >>>>>&4	string		>\0	\b, 1st font "%s"
  off = pageOff + gof + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f420 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>>&4\tstring\t\t>\\0\t\\b, 1st font \"%s\"")
  out = append(out, "\\b, 1st font \"%s\"")
  goto s419
f420:
s419:
  goto s418
f419:
s418:
  goto s397
f418:
s397:
  goto s396
f397:
s396:
  goto s395
f396:
s395:
  goto end
f395:
  // 0	belong	0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f421 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00000200")
  // >7	ubyte		0
  off = pageOff + 0x7
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f422 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">7\tubyte\t\t0")
  // >>6	ubyte		>0	Lotus
  off = pageOff + 0x6
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f423 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>6\tubyte\t\t>0\tLotus")
  out = append(out, "Lotus")
  // >>>4	uleshort	0x0007	1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f424 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0007\t1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)")
  out = append(out, "1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)")
  goto s423
f424:
  // >>>4	uleshort	0x0C05	1-2-3 CoNFiguration, version 2.4J
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xc05)) { goto f425 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0C05\t1-2-3 CoNFiguration, version 2.4J")
  out = append(out, "1-2-3 CoNFiguration, version 2.4J")
  goto s423
f425:
  // >>>4	uleshort	0x0801	1-2-3 CoNFiguration, version 1-2.1
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x801)) { goto f426 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0801\t1-2-3 CoNFiguration, version 1-2.1")
  out = append(out, "1-2-3 CoNFiguration, version 1-2.1")
  goto s423
f426:
  // >>>4	uleshort	0x0802	Symphony CoNFiguration
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x802)) { goto f427 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0802\tSymphony CoNFiguration")
  out = append(out, "Symphony CoNFiguration")
  goto s423
f427:
  // >>>4	uleshort	0x0804	1-2-3 CoNFiguration, version 2.2
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x804)) { goto f428 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0804\t1-2-3 CoNFiguration, version 2.2")
  out = append(out, "1-2-3 CoNFiguration, version 2.2")
  goto s423
f428:
  // >>>4	uleshort	0x080A	1-2-3 CoNFiguration, version 2.3-2.4
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x80a)) { goto f429 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x080A\t1-2-3 CoNFiguration, version 2.3-2.4")
  out = append(out, "1-2-3 CoNFiguration, version 2.3-2.4")
  goto s423
f429:
  // >>>4	uleshort	0x1402	1-2-3 CoNFiguration, version 3.x
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1402)) { goto f430 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1402\t1-2-3 CoNFiguration, version 3.x")
  out = append(out, "1-2-3 CoNFiguration, version 3.x")
  goto s423
f430:
  // >>>4	uleshort	0x1450	1-2-3 CoNFiguration, version 4.x
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1450)) { goto f431 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x1450\t1-2-3 CoNFiguration, version 4.x")
  out = append(out, "1-2-3 CoNFiguration, version 4.x")
  goto s423
f431:
  // >>>4	uleshort	0x0404	1-2-3 WorKSheet, version 1
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x404)) { goto f432 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0404\t1-2-3 WorKSheet, version 1")
  out = append(out, "1-2-3 WorKSheet, version 1")
  goto s423
f432:
  // >>>4	uleshort	0x0405	Symphony WoRksheet, version 1.0
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x405)) { goto f433 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0405\tSymphony WoRksheet, version 1.0")
  out = append(out, "Symphony WoRksheet, version 1.0")
  goto s423
f433:
  // >>>4	uleshort	0x0406	1-2-3/Symphony worksheet, version 2
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x406)) { goto f434 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0406\t1-2-3/Symphony worksheet, version 2")
  out = append(out, "1-2-3/Symphony worksheet, version 2")
  goto s423
f434:
  // >>>4	uleshort	0x0600	1-2-3 WorKsheet, version 1.xJ
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x600)) { goto f435 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0600\t1-2-3 WorKsheet, version 1.xJ")
  out = append(out, "1-2-3 WorKsheet, version 1.xJ")
  goto s423
f435:
  // >>>4	uleshort	0x0602	1-2-3 worksheet, version 2.4J
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x602)) { goto f436 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x0602\t1-2-3 worksheet, version 2.4J")
  out = append(out, "1-2-3 worksheet, version 2.4J")
  goto s423
f436:
  // >>>4	uleshort	0x8006	1-2-3 ForMaTting data, version 2.x
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8006)) { goto f437 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8006\t1-2-3 ForMaTting data, version 2.x")
  out = append(out, "1-2-3 ForMaTting data, version 2.x")
  goto s423
f437:
  // >>>4	uleshort	0x8007	1-2-3 FoRMatting data, version 2.0
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8007)) { goto f438 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\t0x8007\t1-2-3 FoRMatting data, version 2.0")
  out = append(out, "1-2-3 FoRMatting data, version 2.0")
  goto s423
f438:
  // >>>4	default		x	unknown worksheet or configuration
  off = pageOff + 0x4
  // uh oh unhandled kind default
  goto f439
  fmt.Printf("matched rule: %s\n", ">>>4\tdefault\t\tx\tunknown worksheet or configuration")
  out = append(out, "unknown worksheet or configuration")
  // >>>>4	uleshort	x	\b, revision 0x%x
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4\tuleshort\tx\t\\b, revision 0x%x")
  out = append(out, "\\b, revision 0x%x")
  goto s439
s439:
  goto s423
f439:
  // >>>6		use	lotus-cells
  off = pageOff + 0x6
  {
    ss, _ := IdentifyLotusCells(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>6\t\tuse\tlotus-cells")
  goto s423
  // >>>(8.s+10)	use	lotus-cells
  {
    ra, ok := readU16be(tb, 0x8)
    if !ok { goto f442 }
    off = i64(ra)
    off = off + 0xa
  }
  {
    ss, _ := IdentifyLotusCells(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>(8.s+10)\tuse\tlotus-cells")
  goto s423
f442:
s423:
  goto s422
f423:
s422:
  goto s421
f422:
s421:
  goto end
f421:
  // 0	string/b		WordPro\0	Lotus WordPro
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f443 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\0\tLotus WordPro")
  out = append(out, "Lotus WordPro")
  goto end
f443:
  // 0	string/b		WordPro\r\373	Lotus WordPro
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0xd, 0xfb}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f444 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\r\\373\tLotus WordPro")
  out = append(out, "Lotus WordPro")
  goto end
f444:
  // 0		string		\x71\xa8\x00\x00\x01\x02
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x71, 0xa8, 0x0, 0x0, 0x1, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f445 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\t\tstring\t\t\\x71\\xa8\\x00\\x00\\x01\\x02")
  // >12		string		Stirling\ Technologies,		InstallShield Uninstall Script
  off = pageOff + 0xc
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x74, 0x69, 0x72, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x69, 0x65, 0x73, 0x2c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f446 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">12\t\tstring\t\tStirling\\ Technologies,\t\tInstallShield Uninstall Script")
  out = append(out, "InstallShield Uninstall Script")
  goto s445
f446:
s445:
  goto end
f445:
  // 0	string/b	Nullsoft\ AVS\ Preset\ 	Winamp plug in
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x75, 0x6c, 0x6c, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x41, 0x56, 0x53, 0x20, 0x50, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f447 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tNullsoft\\ AVS\\ Preset\\ \tWinamp plug in")
  out = append(out, "Winamp plug in")
  goto end
f447:
  // 0	string/b	\327\315\306\232	ms-windows metafont .wmf
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd7, 0xcd, 0xc6, 0x9a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f448 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\327\\315\\306\\232\tms-windows metafont .wmf")
  out = append(out, "ms-windows metafont .wmf")
  goto end
f448:
  // 0	string/b	\002\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x2, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f449 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\002\\000\\011\\000\tms-windows metafont .wmf")
  out = append(out, "ms-windows metafont .wmf")
  goto end
f449:
  // 0	string/b	\001\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x1, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f450 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\001\\000\\011\\000\tms-windows metafont .wmf")
  out = append(out, "ms-windows metafont .wmf")
  goto end
f450:
  // 0	string/b	\003\001\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x1, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f451 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\001\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  out = append(out, "tz3 ms-works file")
  goto end
f451:
  // 0	string/b	\003\002\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x2, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f452 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\002\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  out = append(out, "tz3 ms-works file")
  goto end
f452:
  // 0	string/b	\003\003\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x3, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f453 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\003\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  out = append(out, "tz3 ms-works file")
  goto end
f453:
  // 0 string \211\000\077\003\005\000\063\237\127\065\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x35, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f454 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\065\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f454:
  // 0 string \211\000\077\003\005\000\063\237\127\066\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x36, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f455 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\066\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f455:
  // 0 string \211\000\077\003\005\000\063\237\127\067\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x37, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f456 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\067\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f456:
  // 0 string \211\000\077\003\005\000\063\237\127\070\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x38, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f457 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\070\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f457:
  // 0 string \211\000\077\003\005\000\063\237\127\071\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x39, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f458 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\071\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  out = append(out, "PGP sig")
  goto end
f458:
  // 0 string \211\000\225\003\005\000\062\122\207\304\100\345\042 PGP sig
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x95, 0x3, 0x5, 0x0, 0x32, 0x52, 0x87, 0xc4, 0x40, 0xe5, 0x22}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f459 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\225\\003\\005\\000\\062\\122\\207\\304\\100\\345\\042 PGP sig")
  out = append(out, "PGP sig")
  goto end
f459:
  // 0	string/b	MDIF\032\000\010\000\000\000\372\046\100\175\001\000\001\036\001\000 MS Windows special zipped file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x44, 0x49, 0x46, 0x1a, 0x0, 0x8, 0x0, 0x0, 0x0, 0xfa, 0x26, 0x40, 0x7d, 0x1, 0x0, 0x1, 0x1e, 0x1, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f460 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMDIF\\032\\000\\010\\000\\000\\000\\372\\046\\100\\175\\001\\000\\001\\036\\001\\000 MS Windows special zipped file")
  out = append(out, "MS Windows special zipped file")
  goto end
f460:
  // 0	string/b	\102\101\050\000\000\000\056\000\000\000\000\000\000\000	Icon for MS Windows
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x41, 0x28, 0x0, 0x0, 0x0, 0x2e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f461 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\102\\101\\050\\000\\000\\000\\056\\000\\000\\000\\000\\000\\000\\000\tIcon for MS Windows")
  out = append(out, "Icon for MS Windows")
  goto end
f461:
  // 0   belong  0x00000100
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f462 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000100")
  // >9  byte    0
  off = pageOff + 0x9
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f463 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  byte    0")
  // >>0 byte    x
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0 byte    x")
  goto s463
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s463
s463:
  goto s462
f463:
  // >9  ubyte   0xff
  off = pageOff + 0x9
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f466 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  ubyte   0xff")
  // >>0 byte    x
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0 byte    x")
  goto s466
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s466
s466:
  goto s462
f466:
s462:
  goto end
f462:
  // 0   belong  0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f469 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000200")
  // >9  byte    0
  off = pageOff + 0x9
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f470 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  byte    0")
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s470
s470:
  goto s469
f470:
  // >9  ubyte   0xff
  off = pageOff + 0x9
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f472 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9  ubyte   0xff")
  // >>0 use     cur-ico-dir
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoDir(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>0 use     cur-ico-dir")
  goto s472
s472:
  goto s469
f472:
s469:
  goto end
f469:
  // 0	string/b	PK\010\010BGI	Borland font
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f474 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPK\\010\\010BGI\tBorland font")
  out = append(out, "Borland font")
  // >4	string	>\0	%s
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f475 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t>\\0\t%s")
  out = append(out, "%s")
  goto s474
f475:
s474:
  goto end
f474:
  // 0	string/b	pk\010\010BGI	Borland device
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x70, 0x6b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f476 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tpk\\010\\010BGI\tBorland device")
  out = append(out, "Borland device")
  // >4	string	>\0	%s
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f477 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t>\\0\t%s")
  out = append(out, "%s")
  goto s476
f477:
s476:
  goto end
f476:
  // 0	lelong		0x00000004
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f478 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000004")
  // >12	lelong		0x00000118	Windows Recycle Bin INFO2 file (Win98 or below)
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x118)) { goto f479 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tlelong\t\t0x00000118\tWindows Recycle Bin INFO2 file (Win98 or below)")
  out = append(out, "Windows Recycle Bin INFO2 file (Win98 or below)")
  goto s478
f479:
s478:
  goto end
f478:
  // 0	lelong		0x00000005
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f480 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000005")
  // >12	lelong		0x00000320	Windows Recycle Bin INFO2 file (Win2k - WinXP)
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x320)) { goto f481 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tlelong\t\t0x00000320\tWindows Recycle Bin INFO2 file (Win2k - WinXP)")
  out = append(out, "Windows Recycle Bin INFO2 file (Win2k - WinXP)")
  goto s480
f481:
s480:
  goto end
f480:
  // 9	string		GERBILDOC	First Choice document
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x4f, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f482 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDOC\tFirst Choice document")
  out = append(out, "First Choice document")
  goto end
f482:
  // 9	string		GERBILDB	First Choice database
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f483 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDB\tFirst Choice database")
  out = append(out, "First Choice database")
  goto end
f483:
  // 9	string		GERBILCLIP	First Choice database
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x43, 0x4c, 0x49, 0x50}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f484 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILCLIP\tFirst Choice database")
  out = append(out, "First Choice database")
  goto end
f484:
  // 0	string		GERBIL		First Choice device file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f485 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tGERBIL\t\tFirst Choice device file")
  out = append(out, "First Choice device file")
  goto end
f485:
  // 9	string		RABBITGRAPH	RabbitGraph file
  off = pageOff + 0x9
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x41, 0x42, 0x42, 0x49, 0x54, 0x47, 0x52, 0x41, 0x50, 0x48}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f486 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tRABBITGRAPH\tRabbitGraph file")
  out = append(out, "RabbitGraph file")
  goto end
f486:
  // 0	string		DCU1		Borland Delphi .DCU file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x43, 0x55, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f487 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tDCU1\t\tBorland Delphi .DCU file")
  out = append(out, "Borland Delphi .DCU file")
  goto end
f487:
  // 0	string		=!<spell>	MKS Spell hash list (old format)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f488 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell>\tMKS Spell hash list (old format)")
  out = append(out, "MKS Spell hash list (old format)")
  goto end
f488:
  // 0	string		=!<spell2>	MKS Spell hash list
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x32, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f489 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell2>\tMKS Spell hash list")
  out = append(out, "MKS Spell hash list")
  goto end
f489:
  // 0	lelong		0x08086b70	TurboC BGI file
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x8086b70)) { goto f490 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08086b70\tTurboC BGI file")
  out = append(out, "TurboC BGI file")
  goto end
f490:
  // 0	lelong		0x08084b50	TurboC Font file
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x8084b50)) { goto f491 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08084b50\tTurboC Font file")
  out = append(out, "TurboC Font file")
  goto end
f491:
  // 0	string		TPF0
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x54, 0x50, 0x46, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f492 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tTPF0")
  goto end
f492:
  // 0	string		PMCC		Windows 3.x .GRP file
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4d, 0x43, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f493 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tPMCC\t\tWindows 3.x .GRP file")
  out = append(out, "Windows 3.x .GRP file")
  goto end
f493:
  // 1	string		RDC-meg		MegaDots
  off = pageOff + 0x1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x44, 0x43, 0x2d, 0x6d, 0x65, 0x67}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f494 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "1\tstring\t\tRDC-meg\t\tMegaDots")
  out = append(out, "MegaDots")
  // >8	byte		>0x2F		version %c
  off = pageOff + 0x8
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x2f)) { goto f495 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">8\tbyte\t\t>0x2F\t\tversion %c")
  out = append(out, "version %c")
  goto s494
f495:
  // >9	byte		>0x2F		\b.%c file
  off = pageOff + 0x9
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x2f)) { goto f496 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">9\tbyte\t\t>0x2F\t\t\\b.%c file")
  out = append(out, "\\b.%c file")
  goto s494
f496:
s494:
  goto end
f494:
  // 0	lelong		0x4C
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x4c)) { goto f497 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x4C")
  // >4	lelong		0x00021401	Windows shortcut file
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x21401)) { goto f498 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tlelong\t\t0x00021401\tWindows shortcut file")
  out = append(out, "Windows shortcut file")
  goto s497
f498:
s497:
  goto end
f497:
  // 0x171	string	MICROSOFT\ PIFEX\0	Windows Program Information File
  off = pageOff + 0x171
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x50, 0x49, 0x46, 0x45, 0x58, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f499 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0x171\tstring\tMICROSOFT\\ PIFEX\\0\tWindows Program Information File")
  out = append(out, "Windows Program Information File")
  // >0x24	string		>\0		\b for %.63s
  off = pageOff + 0x24
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f500 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x24\tstring\t\t>\\0\t\t\\b for %.63s")
  out = append(out, "\\b for %.63s")
  goto s499
f500:
  // >0x65	string		>\0		\b, directory=%.64s
  off = pageOff + 0x65
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f501 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x65\tstring\t\t>\\0\t\t\\b, directory=%.64s")
  out = append(out, "\\b, directory=%.64s")
  goto s499
f501:
  // >0xA5	string		>\0		\b, parameters=%.64s
  off = pageOff + 0xa5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f502 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0xA5\tstring\t\t>\\0\t\t\\b, parameters=%.64s")
  out = append(out, "\\b, parameters=%.64s")
  goto s499
f502:
  // >0x187	search/0xB55	WINDOWS\ VMM\ 4.0\0
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "WINDOWS VMM 4.0\x00"))
    if ml < 0 { goto f503 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tWINDOWS\\ VMM\\ 4.0\\0")
  // >>&0x5e		ubyte	>0
  off = pageOff + gof + 0x5e
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f504 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&0x5e\t\tubyte\t>0")
  // >>>&-1		string	<PIFMGR.DLL		\b, icon=%s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x50, 0x49, 0x46, 0x4d, 0x47, 0x52, 0x2e, 0x44, 0x4c, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f505 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t<PIFMGR.DLL\t\t\\b, icon=%s")
  out = append(out, "\\b, icon=%s")
  goto s504
f505:
  // >>>&-1		string	>PIFMGR.DLL		\b, icon=%s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x50, 0x49, 0x46, 0x4d, 0x47, 0x52, 0x2e, 0x44, 0x4c, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f506 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t>PIFMGR.DLL\t\t\\b, icon=%s")
  out = append(out, "\\b, icon=%s")
  goto s504
f506:
s504:
  goto s503
f504:
  // >>&0xF0		ubyte	>0
  off = pageOff + gof + 0xf0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f507 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&0xF0\t\tubyte\t>0")
  // >>>&-1		string	<Terminal		\b, font=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f508 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t<Terminal\t\t\\b, font=%.32s")
  out = append(out, "\\b, font=%.32s")
  goto s507
f508:
  // >>>&-1		string	>Terminal		\b, font=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x54, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f509 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t>Terminal\t\t\\b, font=%.32s")
  out = append(out, "\\b, font=%.32s")
  goto s507
f509:
s507:
  goto s503
f507:
  // >>&0x110	ubyte	>0
  off = pageOff + gof + 0x110
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x0)) { goto f510 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>&0x110\tubyte\t>0")
  // >>>&-1		string	<Lucida\ Console	\b, TrueTypeFont=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3c, 0x4c, 0x75, 0x63, 0x69, 0x64, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f511 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t<Lucida\\ Console\t\\b, TrueTypeFont=%.32s")
  out = append(out, "\\b, TrueTypeFont=%.32s")
  goto s510
f511:
  // >>>&-1		string	>Lucida\ Console	\b, TrueTypeFont=%.32s
  off = pageOff + gof + -1
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x4c, 0x75, 0x63, 0x69, 0x64, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f512 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>&-1\t\tstring\t>Lucida\\ Console\t\\b, TrueTypeFont=%.32s")
  out = append(out, "\\b, TrueTypeFont=%.32s")
  goto s510
f512:
s510:
  goto s503
f510:
s503:
  goto s499
f503:
  // >0x187	search/0xB55	WINDOWS\ NT\ \ 3.1\0	\b, Windows NT-style
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "WINDOWS NT  3.1\x00"))
    if ml < 0 { goto f513 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tWINDOWS\\ NT\\ \\ 3.1\\0\t\\b, Windows NT-style")
  out = append(out, "\\b, Windows NT-style")
  goto s499
f513:
  // >0x187	search/0xB55	CONFIG\ \ SYS\ 4.0\0	\b +CONFIG.SYS
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "CONFIG  SYS 4.0\x00"))
    if ml < 0 { goto f514 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tCONFIG\\ \\ SYS\\ 4.0\\0\t\\b +CONFIG.SYS")
  out = append(out, "\\b +CONFIG.SYS")
  goto s499
f514:
  // >0x187	search/0xB55	AUTOEXECBAT\ 4.0\0	\b +AUTOEXEC.BAT
  off = pageOff + 0x187
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0xb55, "AUTOEXECBAT 4.0\x00"))
    if ml < 0 { goto f515 }
    gof = off + ml + 0x10
  }
  fmt.Printf("matched rule: %s\n", ">0x187\tsearch/0xB55\tAUTOEXECBAT\\ 4.0\\0\t\\b +AUTOEXEC.BAT")
  out = append(out, "\\b +AUTOEXEC.BAT")
  goto s499
f515:
s499:
  goto end
f499:
  // 0	belong		0xC5D0D3C6	DOS EPS Binary File
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xc5d0d3c6)) { goto f516 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xC5D0D3C6\tDOS EPS Binary File")
  out = append(out, "DOS EPS Binary File")
  // >4	long		>0		Postscript starts at byte %d
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f517 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">4\tlong\t\t>0\t\tPostscript starts at byte %d")
  out = append(out, "Postscript starts at byte %d")
  // >>8	long		>0		length %d
  off = pageOff + 0x8
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f518 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>8\tlong\t\t>0\t\tlength %d")
  out = append(out, "length %d")
  // >>>12	long		>0		Metafile starts at byte %d
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f519 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>12\tlong\t\t>0\t\tMetafile starts at byte %d")
  out = append(out, "Metafile starts at byte %d")
  // >>>>16	long		>0		length %d
  off = pageOff + 0x10
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f520 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>16\tlong\t\t>0\t\tlength %d")
  out = append(out, "length %d")
  goto s519
f520:
s519:
  goto s518
f519:
  // >>>20	long		>0		TIFF starts at byte %d
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f521 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>20\tlong\t\t>0\t\tTIFF starts at byte %d")
  out = append(out, "TIFF starts at byte %d")
  // >>>>24	long		>0		length %d
  off = pageOff + 0x18
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f522 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>24\tlong\t\t>0\t\tlength %d")
  out = append(out, "length %d")
  goto s521
f522:
s521:
  goto s518
f521:
s518:
  goto s517
f518:
s517:
  goto s516
f517:
s516:
  goto end
f516:
  // 0	leshort		0x223e9f78	TNEF
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x223e9f78)) { goto f523 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x223e9f78\tTNEF")
  out = append(out, "TNEF")
  goto end
f523:
  // 0	string		NG\0\001
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x47, 0x0, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f524 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tNG\\0\\001")
  // >2	ulelong		0x00000100	Norton Guide
  off = pageOff + 0x2
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f525 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">2\tulelong\t\t0x00000100\tNorton Guide")
  out = append(out, "Norton Guide")
  // >>8	string		>\0		"%-.40s"
  off = pageOff + 0x8
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f526 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>8\tstring\t\t>\\0\t\t\"%-.40s\"")
  out = append(out, "\"%-.40s\"")
  goto s525
f526:
  // >>48	string		>\0		\b, %-.66s
  off = pageOff + 0x30
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f527 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>48\tstring\t\t>\\0\t\t\\b, %-.66s")
  out = append(out, "\\b, %-.66s")
  goto s525
f527:
  // >>114	string		>\0		%-.66s
  off = pageOff + 0x72
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f528 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>114\tstring\t\t>\\0\t\t%-.66s")
  out = append(out, "%-.66s")
  goto s525
f528:
s525:
  goto s524
f525:
s524:
  goto end
f524:
  // 0	ulelong	0x48443408		4DOS help file
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x48443408)) { goto f529 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tulelong\t0x48443408\t\t4DOS help file")
  out = append(out, "4DOS help file")
  // >4	string	x			\b, version %-4.4s
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f530 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\tx\t\t\t\\b, version %-4.4s")
  out = append(out, "\\b, version %-4.4s")
  goto s529
f530:
s529:
  goto end
f529:
  // 0	ulequad	0x3a000000024e4c	MS Advisor help file
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x3a000000024e4c)) { goto f531 }
  }
  gof = off + 8
  fmt.Printf("matched rule: %s\n", "0\tulequad\t0x3a000000024e4c\tMS Advisor help file")
  out = append(out, "MS Advisor help file")
  goto end
f531:
  // 0	string/b	ITSF\003\000\000\000\x60\000\000\000	MS Windows HtmlHelp Data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x53, 0x46, 0x3, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f532 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITSF\\003\\000\\000\\000\\x60\\000\\000\\000\tMS Windows HtmlHelp Data")
  out = append(out, "MS Windows HtmlHelp Data")
  goto end
f532:
  // 2	string/b	GFA-BASIC3	GFA-BASIC 3 data
  off = pageOff + 0x2
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x46, 0x41, 0x2d, 0x42, 0x41, 0x53, 0x49, 0x43, 0x33}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f533 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "2\tstring/b\tGFA-BASIC3\tGFA-BASIC 3 data")
  out = append(out, "GFA-BASIC 3 data")
  goto end
f533:
  // 0	string/b	MSCF\0\0\0\0	Microsoft Cabinet archive data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x46, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f534 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCF\\0\\0\\0\\0\tMicrosoft Cabinet archive data")
  out = append(out, "Microsoft Cabinet archive data")
  // >8	lelong		x		\b, %u bytes
  off = pageOff + 0x8
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">8\tlelong\t\tx\t\t\\b, %u bytes")
  out = append(out, "\\b, %u bytes")
  goto s534
  // >28	leshort		1		\b, 1 file
  off = pageOff + 0x1c
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f536 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">28\tleshort\t\t1\t\t\\b, 1 file")
  out = append(out, "\\b, 1 file")
  goto s534
f536:
  // >28	leshort		>1		\b, %u files
  off = pageOff + 0x1c
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f537 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">28\tleshort\t\t>1\t\t\\b, %u files")
  out = append(out, "\\b, %u files")
  goto s534
f537:
s534:
  goto end
f534:
  // 0	string/b	ISc(		InstallShield Cabinet archive data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x53, 0x63, 0x28}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f538 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tISc(\t\tInstallShield Cabinet archive data")
  out = append(out, "InstallShield Cabinet archive data")
  // >5	byte&0xf0	=0x60		version 6,
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv)&0xf0 == 0x60)) { goto f539 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte&0xf0\t=0x60\t\tversion 6,")
  out = append(out, "version 6,")
  goto s538
f539:
  // >5	byte&0xf0	!0x60		version 4/5,
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv)&0xf0 != 0x60)) { goto f540 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte&0xf0\t!0x60\t\tversion 4/5,")
  out = append(out, "version 4/5,")
  goto s538
f540:
  // >(12.l+40)	lelong	x		%u files
  {
    ra, ok := readU32be(tb, 0xc)
    if !ok { goto f541 }
    off = i64(ra)
    off = off + 0x28
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(12.l+40)\tlelong\tx\t\t%u files")
  out = append(out, "%u files")
  goto s538
f541:
s538:
  goto end
f538:
  // 0	string/b	MSCE\0\0\0\0	Microsoft WinCE install header
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x45, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f542 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCE\\0\\0\\0\\0\tMicrosoft WinCE install header")
  out = append(out, "Microsoft WinCE install header")
  // >20	lelong		0		\b, architecture-independent
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f543 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t0\t\t\\b, architecture-independent")
  out = append(out, "\\b, architecture-independent")
  goto s542
f543:
  // >20	lelong		103		\b, Hitachi SH3
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x67)) { goto f544 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t103\t\t\\b, Hitachi SH3")
  out = append(out, "\\b, Hitachi SH3")
  goto s542
f544:
  // >20	lelong		104		\b, Hitachi SH4
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x68)) { goto f545 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t104\t\t\\b, Hitachi SH4")
  out = append(out, "\\b, Hitachi SH4")
  goto s542
f545:
  // >20	lelong		0xA11		\b, StrongARM
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xa11)) { goto f546 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t0xA11\t\t\\b, StrongARM")
  out = append(out, "\\b, StrongARM")
  goto s542
f546:
  // >20	lelong		4000		\b, MIPS R4000
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xfa0)) { goto f547 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t4000\t\t\\b, MIPS R4000")
  out = append(out, "\\b, MIPS R4000")
  goto s542
f547:
  // >20	lelong		10003		\b, Hitachi SH3
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x2713)) { goto f548 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t10003\t\t\\b, Hitachi SH3")
  out = append(out, "\\b, Hitachi SH3")
  goto s542
f548:
  // >20	lelong		10004		\b, Hitachi SH3E
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x2714)) { goto f549 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t10004\t\t\\b, Hitachi SH3E")
  out = append(out, "\\b, Hitachi SH3E")
  goto s542
f549:
  // >20	lelong		10005		\b, Hitachi SH4
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x2715)) { goto f550 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t10005\t\t\\b, Hitachi SH4")
  out = append(out, "\\b, Hitachi SH4")
  goto s542
f550:
  // >20	lelong		70001		\b, ARM 7TDMI
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x11171)) { goto f551 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t70001\t\t\\b, ARM 7TDMI")
  out = append(out, "\\b, ARM 7TDMI")
  goto s542
f551:
  // >52	leshort		1		\b, 1 file
  off = pageOff + 0x34
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f552 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">52\tleshort\t\t1\t\t\\b, 1 file")
  out = append(out, "\\b, 1 file")
  goto s542
f552:
  // >52	leshort		>1		\b, %u files
  off = pageOff + 0x34
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f553 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">52\tleshort\t\t>1\t\t\\b, %u files")
  out = append(out, "\\b, %u files")
  goto s542
f553:
  // >56	leshort		1		\b, 1 registry entry
  off = pageOff + 0x38
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f554 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">56\tleshort\t\t1\t\t\\b, 1 registry entry")
  out = append(out, "\\b, 1 registry entry")
  goto s542
f554:
  // >56	leshort		>1		\b, %u registry entries
  off = pageOff + 0x38
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f555 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">56\tleshort\t\t>1\t\t\\b, %u registry entries")
  out = append(out, "\\b, %u registry entries")
  goto s542
f555:
s542:
  goto end
f542:
  // 0	ulelong 1
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f556 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", "0\tulelong 1")
  // >40	string	\ EMF		Windows Enhanced Metafile (EMF) image data
  off = pageOff + 0x28
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x45, 0x4d, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f557 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">40\tstring\t\\ EMF\t\tWindows Enhanced Metafile (EMF) image data")
  out = append(out, "Windows Enhanced Metafile (EMF) image data")
  // >>44	ulelong x		version 0x%x
  off = pageOff + 0x2c
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>44\tulelong x\t\tversion 0x%x")
  out = append(out, "version 0x%x")
  goto s557
s557:
  goto s556
f557:
s556:
  goto end
f556:
  // 0	string/b	\320\317\021\340\241\261\032\341	Microsoft Office Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f559 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\tMicrosoft Office Document")
  out = append(out, "Microsoft Office Document")
  // >546	string	bjbj			Microsoft Word Document
  off = pageOff + 0x222
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x62, 0x6a, 0x62, 0x6a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f560 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">546\tstring\tbjbj\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto s559
f560:
  // >546	string	jbjb			Microsoft Word Document
  off = pageOff + 0x222
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x6a, 0x62, 0x6a, 0x62}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f561 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">546\tstring\tjbjb\t\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto s559
f561:
s559:
  goto end
f559:
  // 0	string/b	\224\246\056		Microsoft Word Document
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x94, 0xa6, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f562 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\224\\246\\056\t\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f562:
  // 512	string	R\0o\0o\0t\0\ \0E\0n\0t\0r\0y	Microsoft Word Document
  off = pageOff + 0x200
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x0, 0x6f, 0x0, 0x6f, 0x0, 0x74, 0x0, 0x20, 0x0, 0x45, 0x0, 0x6e, 0x0, 0x74, 0x0, 0x72, 0x0, 0x79}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f563 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "512\tstring\tR\\0o\\0o\\0t\\0\\ \\0E\\0n\\0t\\0r\\0y\tMicrosoft Word Document")
  out = append(out, "Microsoft Word Document")
  goto end
f563:
  // 0	string/b $RBU
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x52, 0x42, 0x55}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f564 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b $RBU")
  // >23	string Dell			%s system BIOS
  off = pageOff + 0x17
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x65, 0x6c, 0x6c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f565 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">23\tstring Dell\t\t\t%s system BIOS")
  out = append(out, "%s system BIOS")
  goto s564
f565:
  // >5	byte   2
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f566 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte   2")
  // >>48	byte   x			version %d.
  off = pageOff + 0x30
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>48\tbyte   x\t\t\tversion %d.")
  out = append(out, "version %d.")
  goto s566
  // >>49	byte   x			\b%d.
  off = pageOff + 0x31
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>49\tbyte   x\t\t\t\\b%d.")
  out = append(out, "\\b%d.")
  goto s566
  // >>50	byte   x			\b%d
  off = pageOff + 0x32
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>50\tbyte   x\t\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s566
s566:
  goto s564
f566:
  // >5	byte   <2
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) < 0x2)) { goto f570 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">5\tbyte   <2")
  // >>48	string x			version %.3s
  off = pageOff + 0x30
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f571 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>48\tstring x\t\t\tversion %.3s")
  out = append(out, "version %.3s")
  goto s570
f571:
s570:
  goto s564
f570:
s564:
  goto end
f564:
  // 0	string/b	DDS\040\174\000\000\000 Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x44, 0x53, 0x20, 0x7c, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f572 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tDDS\\040\\174\\000\\000\\000 Microsoft DirectDraw Surface (DDS),")
  out = append(out, "Microsoft DirectDraw Surface (DDS),")
  // >16	lelong	>0			%d x
  off = pageOff + 0x10
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f573 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">16\tlelong\t>0\t\t\t%d x")
  out = append(out, "%d x")
  goto s572
f573:
  // >12	lelong	>0			%d,
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0x0)) { goto f574 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tlelong\t>0\t\t\t%d,")
  out = append(out, "%d,")
  goto s572
f574:
  // >84	string	x			%.4s
  off = pageOff + 0x54
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f575 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">84\tstring\tx\t\t\t%.4s")
  out = append(out, "%.4s")
  goto s572
f575:
s572:
  goto end
f572:
  // 0	string/b	ITOLITLS		Microsoft Reader eBook Data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x4f, 0x4c, 0x49, 0x54, 0x4c, 0x53}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f576 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITOLITLS\t\tMicrosoft Reader eBook Data")
  out = append(out, "Microsoft Reader eBook Data")
  // >8	lelong	x			\b, version %u
  off = pageOff + 0x8
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">8\tlelong\tx\t\t\t\\b, version %u")
  out = append(out, "\\b, version %u")
  goto s576
s576:
  goto end
f576:
  // 0	string/b	B000FF\n	Windows Embedded CE binary image
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x30, 0x30, 0x30, 0x46, 0x46, 0xa}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f578 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tB000FF\\n\tWindows Embedded CE binary image")
  out = append(out, "Windows Embedded CE binary image")
  goto end
f578:
  // 0	string/b	MSWIM\000\000\000	Windows imaging (WIM) image
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x49, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f579 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSWIM\\000\\000\\000\tWindows imaging (WIM) image")
  out = append(out, "Windows imaging (WIM) image")
  goto end
f579:
  // 0	string/b	WLPWM\000\000\000	Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x4c, 0x50, 0x57, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
    if ml < 0 { goto f580 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tWLPWM\\000\\000\\000\tWindows imaging (WIM) image, wimlib pipable format")
  out = append(out, "Windows imaging (WIM) image, wimlib pipable format")
  goto end
f580:
  // 0	string	\xfc\x03\x00	Mallard BASIC program data (v1.11)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f581 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x00\tMallard BASIC program data (v1.11)")
  out = append(out, "Mallard BASIC program data (v1.11)")
  goto end
f581:
  // 0	string	\xfc\x04\x00	Mallard BASIC program data (v1.29+)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f582 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x00\tMallard BASIC program data (v1.29+)")
  out = append(out, "Mallard BASIC program data (v1.29+)")
  goto end
f582:
  // 0	string	\xfc\x03\x01	Mallard BASIC protected program data (v1.11)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f583 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x01\tMallard BASIC protected program data (v1.11)")
  out = append(out, "Mallard BASIC protected program data (v1.11)")
  goto end
f583:
  // 0	string	\xfc\x04\x01	Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f584 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x01\tMallard BASIC protected program data (v1.29+)")
  out = append(out, "Mallard BASIC protected program data (v1.29+)")
  goto end
f584:
  // 0	string	MIOPEN		Mallard BASIC Jetsam data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x4f, 0x50, 0x45, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f585 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\tMIOPEN\t\tMallard BASIC Jetsam data")
  out = append(out, "Mallard BASIC Jetsam data")
  goto end
f585:
  // 0	string	Jetsam0		Mallard BASIC Jetsam index data
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x4a, 0x65, 0x74, 0x73, 0x61, 0x6d, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f586 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\tJetsam0\t\tMallard BASIC Jetsam index data")
  out = append(out, "Mallard BASIC Jetsam index data")
  goto end
f586:
  // 0x3	ushort	>1979
  off = pageOff + 0x3
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x7bb)) { goto f587 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", "0x3\tushort\t>1979")
  // >0x5	ubyte-1 <31
  off = pageOff + 0x5
  {
    iv, ok := readU8be(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0x1f)) { goto f588 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0x5\tubyte-1 <31")
  // >>0x6	ubyte-1 <12
  off = pageOff + 0x6
  {
    iv, ok := readU8be(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0xc)) { goto f589 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0x6\tubyte-1 <12")
  // >>>0x7	string	\0\0\0\0\0\0\0\0
  off = pageOff + 0x7
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f590 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>0x7\tstring\t\\0\\0\\0\\0\\0\\0\\0\\0")
  // >>>>0x1 ubyte	x	DOS 2.0 backup id file, sequence %d
  off = pageOff + 0x1
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>0x1 ubyte\tx\tDOS 2.0 backup id file, sequence %d")
  out = append(out, "DOS 2.0 backup id file, sequence %d")
  goto s590
  // >>>>0x0 ubyte	0xff	\b, last disk
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f592 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>0x0 ubyte\t0xff\t\\b, last disk")
  out = append(out, "\\b, last disk")
  goto s590
f592:
s590:
  goto s589
f590:
s589:
  goto s588
f589:
s588:
  goto s587
f588:
s587:
  goto end
f587:
  // 0x53	ubyte-1	<80
  off = pageOff + 0x53
  {
    iv, ok := readU8be(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0x50)) { goto f593 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", "0x53\tubyte-1\t<80")
  // >0x54	string	\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0
  off = pageOff + 0x54
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f594 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x54\tstring\t\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0")
  // >>0x5	string	x	DOS 2.0 backed up file %s,
  off = pageOff + 0x5
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x78}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f595 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>0x5\tstring\tx\tDOS 2.0 backed up file %s,")
  out = append(out, "DOS 2.0 backed up file %s,")
  goto s594
f595:
  // >>0	ubyte	0xff	complete file
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f596 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0\tubyte\t0xff\tcomplete file")
  out = append(out, "complete file")
  goto s594
f596:
  // >>0	ubyte	!0xff
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0xff)) { goto f597 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0\tubyte\t!0xff")
  // >>>1	ushort	x	split file, sequence %d
  off = pageOff + 0x1
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>1\tushort\tx\tsplit file, sequence %d")
  out = append(out, "split file, sequence %d")
  goto s597
s597:
  goto s594
f597:
s594:
  goto s593
f594:
s593:
  goto end
f593:
  // 0	string	\x8bBACKUP\x20
  off = pageOff + 0x0
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x8b, 0x42, 0x41, 0x43, 0x4b, 0x55, 0x50, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f599 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\x8bBACKUP\\x20")
  // >0xa	string	\0\0\0\0\0\0\0\0
  off = pageOff + 0xa
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f600 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0xa\tstring\t\\0\\0\\0\\0\\0\\0\\0\\0")
  // >>0x9	ubyte	x	DOS 3.3 backup control file, sequence %d
  off = pageOff + 0x9
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0x9\tubyte\tx\tDOS 3.3 backup control file, sequence %d")
  out = append(out, "DOS 3.3 backup control file, sequence %d")
  goto s600
  // >>0x8a	ubyte	0xff	\b, last disk
  off = pageOff + 0x8a
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xff)) { goto f602 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>0x8a\tubyte\t0xff\t\\b, last disk")
  out = append(out, "\\b, last disk")
  goto s600
f602:
s600:
  goto s599
f600:
s599:
  goto end
f599:
end:
  return out, nil
}

func IdentifyCurEntry(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		cur-entry
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-entry")
  // >0	use		cur-ico-entry
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\tcur-ico-entry")
  goto s0
  // >4	uleshort	x	\b, hotspot @%dx
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort\tx\t\\b, hotspot @%dx")
  out = append(out, "\\b, hotspot @%dx")
  goto s0
  // >6	uleshort	x	\b%d
  off = pageOff + 0x6
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">6\tuleshort\tx\t\\b%d")
  out = append(out, "\\b%d")
  goto s0
s0:
  goto end
end:
  return out, nil
}

func IdentifyCurEntry__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		cur-entry
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-entry")
  // >0	use		cur-ico-entry
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\tcur-ico-entry")
  goto s0
  // >4	uleshort	x	\b, hotspot @%dx
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort\tx\t\\b, hotspot @%dx")
  out = append(out, "\\b, hotspot @%dx")
  goto s0
  // >6	uleshort	x	\b%d
  off = pageOff + 0x6
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">6\tuleshort\tx\t\\b%d")
  out = append(out, "\\b%d")
  goto s0
s0:
  goto end
end:
  return out, nil
}

func IdentifyCurIcoDir(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		cur-ico-dir
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-ico-dir")
  // >18		ulelong		&0x00000006
  off = pageOff + 0x12
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">18\t\tulelong\t\t&0x00000006")
  // >>(18.l)	ulelong		x		MS Windows
  {
    ra, ok := readU32le(tb, 0x12)
    if !ok { goto f2 }
    off = i64(ra)
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>(18.l)\tulelong\t\tx\t\tMS Windows")
  out = append(out, "MS Windows")
  // >>>0		ubelong		0x00000100	icon resource
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f3 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>0\t\tubelong\t\t0x00000100\ticon resource")
  out = append(out, "icon resource")
  // >>>>4 		uleshort	x		- %d icon
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\tx\t\t- %d icon")
  out = append(out, "- %d icon")
  goto s3
  // >>>>4 		uleshort	>1		\bs
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f5 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\t>1\t\t\\bs")
  out = append(out, "\\bs")
  goto s3
f5:
  // >>>>0x06	use		ico-entry
  off = pageOff + 0x6
  {
    ss, _ := IdentifyIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x06\tuse\t\tico-entry")
  goto s3
  // >>>>4 		uleshort	>1
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f7 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\t>1")
  // >>>>>0x16	use		ico-entry
  off = pageOff + 0x16
  {
    ss, _ := IdentifyIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x16\tuse\t\tico-entry")
  goto s7
s7:
  goto s3
f7:
s3:
  goto s2
f3:
  // >>>0		ubelong		0x00000200	cursor resource
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>0\t\tubelong\t\t0x00000200\tcursor resource")
  out = append(out, "cursor resource")
  // >>>>4 		uleshort	x		- %d icon
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\tx\t\t- %d icon")
  out = append(out, "- %d icon")
  goto s9
  // >>>>4 		uleshort	>1		\bs
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f11 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\t>1\t\t\\bs")
  out = append(out, "\\bs")
  goto s9
f11:
  // >>>>0x06	use		cur-entry
  off = pageOff + 0x6
  {
    ss, _ := IdentifyCurEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x06\tuse\t\tcur-entry")
  goto s9
s9:
  goto s2
f9:
s2:
  goto s1
f2:
s1:
  goto s0
f1:
s0:
  goto end
end:
  return out, nil
}

func IdentifyCurIcoDir__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		cur-ico-dir
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-ico-dir")
  // >18		ulelong		&0x00000006
  off = pageOff + 0x12
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">18\t\tulelong\t\t&0x00000006")
  // >>(18.l)	ulelong		x		MS Windows
  {
    ra, ok := readU32be(tb, 0x12)
    if !ok { goto f2 }
    off = i64(ra)
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>(18.l)\tulelong\t\tx\t\tMS Windows")
  out = append(out, "MS Windows")
  // >>>0		ubelong		0x00000100	icon resource
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f3 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>0\t\tubelong\t\t0x00000100\ticon resource")
  out = append(out, "icon resource")
  // >>>>4 		uleshort	x		- %d icon
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\tx\t\t- %d icon")
  out = append(out, "- %d icon")
  goto s3
  // >>>>4 		uleshort	>1		\bs
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f5 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\t>1\t\t\\bs")
  out = append(out, "\\bs")
  goto s3
f5:
  // >>>>0x06	use		ico-entry
  off = pageOff + 0x6
  {
    ss, _ := IdentifyIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x06\tuse\t\tico-entry")
  goto s3
  // >>>>4 		uleshort	>1
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f7 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\t>1")
  // >>>>>0x16	use		ico-entry
  off = pageOff + 0x16
  {
    ss, _ := IdentifyIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>>>0x16\tuse\t\tico-entry")
  goto s7
s7:
  goto s3
f7:
s3:
  goto s2
f3:
  // >>>0		ubelong		0x00000200	cursor resource
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>0\t\tubelong\t\t0x00000200\tcursor resource")
  out = append(out, "cursor resource")
  // >>>>4 		uleshort	x		- %d icon
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\tx\t\t- %d icon")
  out = append(out, "- %d icon")
  goto s9
  // >>>>4 		uleshort	>1		\bs
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f11 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>>4 \t\tuleshort\t>1\t\t\\bs")
  out = append(out, "\\bs")
  goto s9
f11:
  // >>>>0x06	use		cur-entry
  off = pageOff + 0x6
  {
    ss, _ := IdentifyCurEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">>>>0x06\tuse\t\tcur-entry")
  goto s9
s9:
  goto s2
f9:
s2:
  goto s1
f2:
s1:
  goto s0
f1:
s0:
  goto end
end:
  return out, nil
}

func IdentifyCurIcoEntry(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0		name		cur-ico-entry
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\t\tname\t\tcur-ico-entry")
  // >0		byte		=0		\b, 256x
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f1 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\t\tbyte\t\t=0\t\t\\b, 256x")
  out = append(out, "\\b, 256x")
  goto s0
f1:
  // >0		byte		!0		\b, %dx
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f2 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\t\tbyte\t\t!0\t\t\\b, %dx")
  out = append(out, "\\b, %dx")
  goto s0
f2:
  // >1		byte        	=0		\b256
  off = pageOff + 0x1
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f3 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">1\t\tbyte        \t=0\t\t\\b256")
  out = append(out, "\\b256")
  goto s0
f3:
  // >1		byte        	!0		\b%d
  off = pageOff + 0x1
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f4 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">1\t\tbyte        \t!0\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s0
f4:
  // >2		ubyte		!0		\b, %d colors
  off = pageOff + 0x2
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f5 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">2\t\tubyte\t\t!0\t\t\\b, %d colors")
  out = append(out, "\\b, %d colors")
  goto s0
f5:
  // >(12.l)		ubelong		=0x89504e47
  {
    ra, ok := readU32le(tb, 0xc)
    if !ok { goto f6 }
    off = i64(ra)
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x89504e47)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(12.l)\t\tubelong\t\t=0x89504e47")
  goto s0
f6:
  // >(12.l)		ubelong		!0x89504e47
  {
    ra, ok := readU32le(tb, 0xc)
    if !ok { goto f7 }
    off = i64(ra)
  }
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) != 0x89504e47)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(12.l)\t\tubelong\t\t!0x89504e47")
  goto s0
f7:
s0:
  goto end
end:
  return out, nil
}

func IdentifyCurIcoEntry__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0		name		cur-ico-entry
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\t\tname\t\tcur-ico-entry")
  // >0		byte		=0		\b, 256x
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f1 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\t\tbyte\t\t=0\t\t\\b, 256x")
  out = append(out, "\\b, 256x")
  goto s0
f1:
  // >0		byte		!0		\b, %dx
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f2 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\t\tbyte\t\t!0\t\t\\b, %dx")
  out = append(out, "\\b, %dx")
  goto s0
f2:
  // >1		byte        	=0		\b256
  off = pageOff + 0x1
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f3 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">1\t\tbyte        \t=0\t\t\\b256")
  out = append(out, "\\b256")
  goto s0
f3:
  // >1		byte        	!0		\b%d
  off = pageOff + 0x1
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f4 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">1\t\tbyte        \t!0\t\t\\b%d")
  out = append(out, "\\b%d")
  goto s0
f4:
  // >2		ubyte		!0		\b, %d colors
  off = pageOff + 0x2
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f5 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">2\t\tubyte\t\t!0\t\t\\b, %d colors")
  out = append(out, "\\b, %d colors")
  goto s0
f5:
  // >(12.l)		ubelong		=0x89504e47
  {
    ra, ok := readU32be(tb, 0xc)
    if !ok { goto f6 }
    off = i64(ra)
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x89504e47)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(12.l)\t\tubelong\t\t=0x89504e47")
  goto s0
f6:
  // >(12.l)		ubelong		!0x89504e47
  {
    ra, ok := readU32be(tb, 0xc)
    if !ok { goto f7 }
    off = i64(ra)
  }
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) != 0x89504e47)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">(12.l)\t\tubelong\t\t!0x89504e47")
  goto s0
f7:
s0:
  goto end
end:
  return out, nil
}

func IdentifyElfLe(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		elf-le
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\telf-le")
  // >16	leshort		0		no file type,
  off = pageOff + 0x10
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f1 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t0\t\tno file type,")
  out = append(out, "no file type,")
  goto s0
f1:
  // >16	leshort		1		relocatable,
  off = pageOff + 0x10
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f2 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t1\t\trelocatable,")
  out = append(out, "relocatable,")
  goto s0
f2:
  // >16	leshort		2		executable,
  off = pageOff + 0x10
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t2\t\texecutable,")
  out = append(out, "executable,")
  goto s0
f3:
  // >16	leshort		3		shared object,
  off = pageOff + 0x10
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f4 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t3\t\tshared object,")
  out = append(out, "shared object,")
  goto s0
f4:
  // >16	leshort		4		core file
  off = pageOff + 0x10
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f5 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t4\t\tcore file")
  out = append(out, "core file")
  goto s0
f5:
  // >16	leshort		&0xff00		processor-specific,
  off = pageOff + 0x10
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xff00)) { goto f6 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t&0xff00\t\tprocessor-specific,")
  out = append(out, "processor-specific,")
  goto s0
f6:
  // >18	clear		x
  off = pageOff + 0x12
  // uh oh unhandled kind clear
  goto f7
  fmt.Printf("matched rule: %s\n", ">18\tclear\t\tx")
  goto s0
f7:
  // >18	leshort		0		no machine,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f8 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0\t\tno machine,")
  out = append(out, "no machine,")
  goto s0
f8:
  // >18	leshort		1		AT&T WE32100,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f9 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t1\t\tAT&T WE32100,")
  out = append(out, "AT&T WE32100,")
  goto s0
f9:
  // >18	leshort		2		SPARC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f10 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t2\t\tSPARC,")
  out = append(out, "SPARC,")
  goto s0
f10:
  // >18	leshort		3		Intel 80386,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f11 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t3\t\tIntel 80386,")
  out = append(out, "Intel 80386,")
  goto s0
f11:
  // >18	leshort		4		Motorola m68k,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f12 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t4\t\tMotorola m68k,")
  out = append(out, "Motorola m68k,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f13 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong		&0x01000000	68000,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1000000)) { goto f14 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x01000000\t68000,")
  out = append(out, "68000,")
  goto s13
f14:
  // >>>36	lelong		&0x00810000	CPU32,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x810000)) { goto f15 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x00810000\tCPU32,")
  out = append(out, "CPU32,")
  goto s13
f15:
  // >>>36	lelong		0		68020,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f16 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t0\t\t68020,")
  out = append(out, "68020,")
  goto s13
f16:
s13:
  goto s12
f13:
s12:
  goto s0
f12:
  // >18	leshort		5		Motorola m88k,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f17 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t5\t\tMotorola m88k,")
  out = append(out, "Motorola m88k,")
  goto s0
f17:
  // >18	leshort		6		Intel 80486,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f18 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t6\t\tIntel 80486,")
  out = append(out, "Intel 80486,")
  goto s0
f18:
  // >18	leshort		7		Intel 80860,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f19 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t7\t\tIntel 80860,")
  out = append(out, "Intel 80860,")
  goto s0
f19:
  // >18	leshort		8		MIPS,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f20 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t8\t\tMIPS,")
  out = append(out, "MIPS,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f21 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong		&0x20		N32
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x20)) { goto f22 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x20\t\tN32")
  out = append(out, "N32")
  goto s21
f22:
s21:
  goto s20
f21:
s20:
  goto s0
f20:
  // >18	leshort		10		MIPS,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f23 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t10\t\tMIPS,")
  out = append(out, "MIPS,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f24 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong		&0x20		N32
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x20)) { goto f25 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x20\t\tN32")
  out = append(out, "N32")
  goto s24
f25:
s24:
  goto s23
f24:
s23:
  goto s0
f23:
  // >18	leshort		8
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f26 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t8")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f27 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36  lelong&0xf0000000	0x00000000	MIPS-I
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x0)) { goto f28 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x00000000\tMIPS-I")
  out = append(out, "MIPS-I")
  goto s27
f28:
  // >>>36  lelong&0xf0000000	0x10000000	MIPS-II
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x10000000)) { goto f29 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x10000000\tMIPS-II")
  out = append(out, "MIPS-II")
  goto s27
f29:
  // >>>36  lelong&0xf0000000	0x20000000	MIPS-III
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x20000000)) { goto f30 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x20000000\tMIPS-III")
  out = append(out, "MIPS-III")
  goto s27
f30:
  // >>>36  lelong&0xf0000000	0x30000000	MIPS-IV
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x30000000)) { goto f31 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x30000000\tMIPS-IV")
  out = append(out, "MIPS-IV")
  goto s27
f31:
  // >>>36  lelong&0xf0000000	0x40000000	MIPS-V
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x40000000)) { goto f32 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x40000000\tMIPS-V")
  out = append(out, "MIPS-V")
  goto s27
f32:
  // >>>36  lelong&0xf0000000	0x50000000	MIPS32
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x50000000)) { goto f33 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x50000000\tMIPS32")
  out = append(out, "MIPS32")
  goto s27
f33:
  // >>>36  lelong&0xf0000000	0x60000000	MIPS64
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x60000000)) { goto f34 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x60000000\tMIPS64")
  out = append(out, "MIPS64")
  goto s27
f34:
  // >>>36  lelong&0xf0000000	0x70000000	MIPS32 rel2
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x70000000)) { goto f35 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x70000000\tMIPS32 rel2")
  out = append(out, "MIPS32 rel2")
  goto s27
f35:
  // >>>36  lelong&0xf0000000	0x80000000	MIPS64 rel2
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x80000000)) { goto f36 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x80000000\tMIPS64 rel2")
  out = append(out, "MIPS64 rel2")
  goto s27
f36:
s27:
  goto s26
f27:
  // >>4	byte		2
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f37 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t2")
  // >>>48  lelong&0xf0000000	0x00000000	MIPS-I
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x0)) { goto f38 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x00000000\tMIPS-I")
  out = append(out, "MIPS-I")
  goto s37
f38:
  // >>>48  lelong&0xf0000000	0x10000000	MIPS-II
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x10000000)) { goto f39 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x10000000\tMIPS-II")
  out = append(out, "MIPS-II")
  goto s37
f39:
  // >>>48  lelong&0xf0000000	0x20000000	MIPS-III
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x20000000)) { goto f40 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x20000000\tMIPS-III")
  out = append(out, "MIPS-III")
  goto s37
f40:
  // >>>48  lelong&0xf0000000	0x30000000	MIPS-IV
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x30000000)) { goto f41 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x30000000\tMIPS-IV")
  out = append(out, "MIPS-IV")
  goto s37
f41:
  // >>>48  lelong&0xf0000000	0x40000000	MIPS-V
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x40000000)) { goto f42 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x40000000\tMIPS-V")
  out = append(out, "MIPS-V")
  goto s37
f42:
  // >>>48  lelong&0xf0000000	0x50000000	MIPS32
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x50000000)) { goto f43 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x50000000\tMIPS32")
  out = append(out, "MIPS32")
  goto s37
f43:
  // >>>48  lelong&0xf0000000	0x60000000	MIPS64
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x60000000)) { goto f44 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x60000000\tMIPS64")
  out = append(out, "MIPS64")
  goto s37
f44:
  // >>>48  lelong&0xf0000000	0x70000000	MIPS32 rel2
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x70000000)) { goto f45 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x70000000\tMIPS32 rel2")
  out = append(out, "MIPS32 rel2")
  goto s37
f45:
  // >>>48  lelong&0xf0000000	0x80000000	MIPS64 rel2
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x80000000)) { goto f46 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x80000000\tMIPS64 rel2")
  out = append(out, "MIPS64 rel2")
  goto s37
f46:
s37:
  goto s26
f37:
s26:
  goto s0
f26:
  // >18	leshort		9		Amdahl,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f47 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t9\t\tAmdahl,")
  out = append(out, "Amdahl,")
  goto s0
f47:
  // >18	leshort		10		MIPS (deprecated),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f48 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t10\t\tMIPS (deprecated),")
  out = append(out, "MIPS (deprecated),")
  goto s0
f48:
  // >18	leshort		11		RS6000,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f49 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t11\t\tRS6000,")
  out = append(out, "RS6000,")
  goto s0
f49:
  // >18	leshort		15		PA-RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xf)) { goto f50 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t15\t\tPA-RISC,")
  out = append(out, "PA-RISC,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f51 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>38	leshort		0x0214		2.0
  off = pageOff + 0x26
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x214)) { goto f52 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>38\tleshort\t\t0x0214\t\t2.0")
  out = append(out, "2.0")
  goto s51
f52:
  // >>>36	leshort		&0x0008		(LP64)
  off = pageOff + 0x24
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f53 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>36\tleshort\t\t&0x0008\t\t(LP64)")
  out = append(out, "(LP64)")
  goto s51
f53:
s51:
  goto s50
f51:
  // >>4	byte		2
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f54 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t2")
  // >>>50	leshort		0x0214		2.0
  off = pageOff + 0x32
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x214)) { goto f55 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>50\tleshort\t\t0x0214\t\t2.0")
  out = append(out, "2.0")
  goto s54
f55:
  // >>>48	leshort		&0x0008		(LP64)
  off = pageOff + 0x30
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f56 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>48\tleshort\t\t&0x0008\t\t(LP64)")
  out = append(out, "(LP64)")
  goto s54
f56:
s54:
  goto s50
f54:
s50:
  goto s0
f50:
  // >18	leshort		16		nCUBE,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x10)) { goto f57 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t16\t\tnCUBE,")
  out = append(out, "nCUBE,")
  goto s0
f57:
  // >18	leshort		17		Fujitsu VPP500,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x11)) { goto f58 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t17\t\tFujitsu VPP500,")
  out = append(out, "Fujitsu VPP500,")
  goto s0
f58:
  // >18	leshort		18		SPARC32PLUS,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x12)) { goto f59 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t18\t\tSPARC32PLUS,")
  out = append(out, "SPARC32PLUS,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f60 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong&0xffff00	0x000100	V8+ Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x100)) { goto f61 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000100\tV8+ Required,")
  out = append(out, "V8+ Required,")
  goto s60
f61:
  // >>>36	lelong&0xffff00	0x000200	Sun UltraSPARC1 Extensions Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x200)) { goto f62 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000200\tSun UltraSPARC1 Extensions Required,")
  out = append(out, "Sun UltraSPARC1 Extensions Required,")
  goto s60
f62:
  // >>>36	lelong&0xffff00	0x000400	HaL R1 Extensions Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x400)) { goto f63 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000400\tHaL R1 Extensions Required,")
  out = append(out, "HaL R1 Extensions Required,")
  goto s60
f63:
  // >>>36	lelong&0xffff00	0x000800	Sun UltraSPARC3 Extensions Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x800)) { goto f64 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000800\tSun UltraSPARC3 Extensions Required,")
  out = append(out, "Sun UltraSPARC3 Extensions Required,")
  goto s60
f64:
s60:
  goto s59
f60:
s59:
  goto s0
f59:
  // >18	leshort		19		Intel 80960,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x13)) { goto f65 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t19\t\tIntel 80960,")
  out = append(out, "Intel 80960,")
  goto s0
f65:
  // >18	leshort		20		PowerPC or cisco 4500,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x14)) { goto f66 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t20\t\tPowerPC or cisco 4500,")
  out = append(out, "PowerPC or cisco 4500,")
  goto s0
f66:
  // >18	leshort		21		64-bit PowerPC or cisco 7500,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x15)) { goto f67 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t21\t\t64-bit PowerPC or cisco 7500,")
  out = append(out, "64-bit PowerPC or cisco 7500,")
  goto s0
f67:
  // >18	leshort		22		IBM S/390,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x16)) { goto f68 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t22\t\tIBM S/390,")
  out = append(out, "IBM S/390,")
  goto s0
f68:
  // >18	leshort		23		Cell SPU,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x17)) { goto f69 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t23\t\tCell SPU,")
  out = append(out, "Cell SPU,")
  goto s0
f69:
  // >18	leshort		24		cisco SVIP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x18)) { goto f70 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t24\t\tcisco SVIP,")
  out = append(out, "cisco SVIP,")
  goto s0
f70:
  // >18	leshort		25		cisco 7200,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x19)) { goto f71 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t25\t\tcisco 7200,")
  out = append(out, "cisco 7200,")
  goto s0
f71:
  // >18	leshort		36		NEC V800 or cisco 12000,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x24)) { goto f72 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t36\t\tNEC V800 or cisco 12000,")
  out = append(out, "NEC V800 or cisco 12000,")
  goto s0
f72:
  // >18	leshort		37		Fujitsu FR20,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x25)) { goto f73 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t37\t\tFujitsu FR20,")
  out = append(out, "Fujitsu FR20,")
  goto s0
f73:
  // >18	leshort		38		TRW RH-32,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x26)) { goto f74 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t38\t\tTRW RH-32,")
  out = append(out, "TRW RH-32,")
  goto s0
f74:
  // >18	leshort		39		Motorola RCE,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x27)) { goto f75 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t39\t\tMotorola RCE,")
  out = append(out, "Motorola RCE,")
  goto s0
f75:
  // >18	leshort		40		ARM,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x28)) { goto f76 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t40\t\tARM,")
  out = append(out, "ARM,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f77 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong&0xff000000	0x04000000	EABI4
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xff000000 == 0x4000000)) { goto f78 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xff000000\t0x04000000\tEABI4")
  out = append(out, "EABI4")
  goto s77
f78:
  // >>>36	lelong&0xff000000	0x05000000	EABI5
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xff000000 == 0x5000000)) { goto f79 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xff000000\t0x05000000\tEABI5")
  out = append(out, "EABI5")
  goto s77
f79:
  // >>>36	lelong		&0x00800000	BE8
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x800000)) { goto f80 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x00800000\tBE8")
  out = append(out, "BE8")
  goto s77
f80:
  // >>>36	lelong		&0x00400000	LE8
  off = pageOff + 0x24
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x400000)) { goto f81 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x00400000\tLE8")
  out = append(out, "LE8")
  goto s77
f81:
s77:
  goto s76
f77:
s76:
  goto s0
f76:
  // >18	leshort		41		Alpha,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x29)) { goto f82 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t41\t\tAlpha,")
  out = append(out, "Alpha,")
  goto s0
f82:
  // >18	leshort		42		Renesas SH,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2a)) { goto f83 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t42\t\tRenesas SH,")
  out = append(out, "Renesas SH,")
  goto s0
f83:
  // >18	leshort		43		SPARC V9,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2b)) { goto f84 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t43\t\tSPARC V9,")
  out = append(out, "SPARC V9,")
  // >>4	byte		2
  off = pageOff + 0x4
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f85 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t2")
  // >>>48	lelong&0xffff00	0x000200	Sun UltraSPARC1 Extensions Required,
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x200)) { goto f86 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0xffff00\t0x000200\tSun UltraSPARC1 Extensions Required,")
  out = append(out, "Sun UltraSPARC1 Extensions Required,")
  goto s85
f86:
  // >>>48	lelong&0xffff00	0x000400	HaL R1 Extensions Required,
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x400)) { goto f87 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0xffff00\t0x000400\tHaL R1 Extensions Required,")
  out = append(out, "HaL R1 Extensions Required,")
  goto s85
f87:
  // >>>48	lelong&0xffff00	0x000800	Sun UltraSPARC3 Extensions Required,
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x800)) { goto f88 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0xffff00\t0x000800\tSun UltraSPARC3 Extensions Required,")
  out = append(out, "Sun UltraSPARC3 Extensions Required,")
  goto s85
f88:
  // >>>48	lelong&0x3	0		total store ordering,
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x0)) { goto f89 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0x3\t0\t\ttotal store ordering,")
  out = append(out, "total store ordering,")
  goto s85
f89:
  // >>>48	lelong&0x3	1		partial store ordering,
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x1)) { goto f90 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0x3\t1\t\tpartial store ordering,")
  out = append(out, "partial store ordering,")
  goto s85
f90:
  // >>>48	lelong&0x3	2		relaxed memory ordering,
  off = pageOff + 0x30
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x2)) { goto f91 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0x3\t2\t\trelaxed memory ordering,")
  out = append(out, "relaxed memory ordering,")
  goto s85
f91:
s85:
  goto s84
f85:
s84:
  goto s0
f84:
  // >18	leshort		44		Siemens Tricore Embedded Processor,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2c)) { goto f92 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t44\t\tSiemens Tricore Embedded Processor,")
  out = append(out, "Siemens Tricore Embedded Processor,")
  goto s0
f92:
  // >18	leshort		45		Argonaut RISC Core, Argonaut Technologies Inc.,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2d)) { goto f93 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t45\t\tArgonaut RISC Core, Argonaut Technologies Inc.,")
  out = append(out, "Argonaut RISC Core, Argonaut Technologies Inc.,")
  goto s0
f93:
  // >18	leshort		46		Renesas H8/300,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2e)) { goto f94 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t46\t\tRenesas H8/300,")
  out = append(out, "Renesas H8/300,")
  goto s0
f94:
  // >18	leshort		47		Renesas H8/300H,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2f)) { goto f95 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t47\t\tRenesas H8/300H,")
  out = append(out, "Renesas H8/300H,")
  goto s0
f95:
  // >18	leshort		48		Renesas H8S,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x30)) { goto f96 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t48\t\tRenesas H8S,")
  out = append(out, "Renesas H8S,")
  goto s0
f96:
  // >18	leshort		49		Renesas H8/500,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x31)) { goto f97 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t49\t\tRenesas H8/500,")
  out = append(out, "Renesas H8/500,")
  goto s0
f97:
  // >18	leshort		50		IA-64,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x32)) { goto f98 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t50\t\tIA-64,")
  out = append(out, "IA-64,")
  goto s0
f98:
  // >18	leshort		51		Stanford MIPS-X,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x33)) { goto f99 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t51\t\tStanford MIPS-X,")
  out = append(out, "Stanford MIPS-X,")
  goto s0
f99:
  // >18	leshort		52		Motorola Coldfire,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x34)) { goto f100 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t52\t\tMotorola Coldfire,")
  out = append(out, "Motorola Coldfire,")
  goto s0
f100:
  // >18	leshort		53		Motorola M68HC12,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x35)) { goto f101 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t53\t\tMotorola M68HC12,")
  out = append(out, "Motorola M68HC12,")
  goto s0
f101:
  // >18	leshort		54		Fujitsu MMA,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x36)) { goto f102 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t54\t\tFujitsu MMA,")
  out = append(out, "Fujitsu MMA,")
  goto s0
f102:
  // >18	leshort		55		Siemens PCP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x37)) { goto f103 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t55\t\tSiemens PCP,")
  out = append(out, "Siemens PCP,")
  goto s0
f103:
  // >18	leshort		56		Sony nCPU,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x38)) { goto f104 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t56\t\tSony nCPU,")
  out = append(out, "Sony nCPU,")
  goto s0
f104:
  // >18	leshort		57		Denso NDR1,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x39)) { goto f105 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t57\t\tDenso NDR1,")
  out = append(out, "Denso NDR1,")
  goto s0
f105:
  // >18	leshort		58		Start*Core,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3a)) { goto f106 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t58\t\tStart*Core,")
  out = append(out, "Start*Core,")
  goto s0
f106:
  // >18	leshort		59		Toyota ME16,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3b)) { goto f107 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t59\t\tToyota ME16,")
  out = append(out, "Toyota ME16,")
  goto s0
f107:
  // >18	leshort		60		ST100,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3c)) { goto f108 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t60\t\tST100,")
  out = append(out, "ST100,")
  goto s0
f108:
  // >18	leshort		61		Tinyj emb.,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3d)) { goto f109 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t61\t\tTinyj emb.,")
  out = append(out, "Tinyj emb.,")
  goto s0
f109:
  // >18	leshort		62		x86-64,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3e)) { goto f110 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t62\t\tx86-64,")
  out = append(out, "x86-64,")
  goto s0
f110:
  // >18	leshort		63		Sony DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3f)) { goto f111 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t63\t\tSony DSP,")
  out = append(out, "Sony DSP,")
  goto s0
f111:
  // >18	leshort		64		DEC PDP-10,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x40)) { goto f112 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t64\t\tDEC PDP-10,")
  out = append(out, "DEC PDP-10,")
  goto s0
f112:
  // >18	leshort		65		DEC PDP-11,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x41)) { goto f113 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t65\t\tDEC PDP-11,")
  out = append(out, "DEC PDP-11,")
  goto s0
f113:
  // >18	leshort		66		FX66,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x42)) { goto f114 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t66\t\tFX66,")
  out = append(out, "FX66,")
  goto s0
f114:
  // >18	leshort		67		ST9+ 8/16 bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x43)) { goto f115 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t67\t\tST9+ 8/16 bit,")
  out = append(out, "ST9+ 8/16 bit,")
  goto s0
f115:
  // >18	leshort		68		ST7 8 bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x44)) { goto f116 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t68\t\tST7 8 bit,")
  out = append(out, "ST7 8 bit,")
  goto s0
f116:
  // >18	leshort		69		MC68HC16,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x45)) { goto f117 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t69\t\tMC68HC16,")
  out = append(out, "MC68HC16,")
  goto s0
f117:
  // >18	leshort		70		MC68HC11,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x46)) { goto f118 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t70\t\tMC68HC11,")
  out = append(out, "MC68HC11,")
  goto s0
f118:
  // >18	leshort		71		MC68HC08,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x47)) { goto f119 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t71\t\tMC68HC08,")
  out = append(out, "MC68HC08,")
  goto s0
f119:
  // >18	leshort		72		MC68HC05,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x48)) { goto f120 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t72\t\tMC68HC05,")
  out = append(out, "MC68HC05,")
  goto s0
f120:
  // >18	leshort		73		SGI SVx or Cray NV1,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x49)) { goto f121 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t73\t\tSGI SVx or Cray NV1,")
  out = append(out, "SGI SVx or Cray NV1,")
  goto s0
f121:
  // >18	leshort		74		ST19 8 bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4a)) { goto f122 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t74\t\tST19 8 bit,")
  out = append(out, "ST19 8 bit,")
  goto s0
f122:
  // >18	leshort		75		Digital VAX,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4b)) { goto f123 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t75\t\tDigital VAX,")
  out = append(out, "Digital VAX,")
  goto s0
f123:
  // >18	leshort		76		Axis cris,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4c)) { goto f124 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t76\t\tAxis cris,")
  out = append(out, "Axis cris,")
  goto s0
f124:
  // >18	leshort		77		Infineon 32-bit embedded,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4d)) { goto f125 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t77\t\tInfineon 32-bit embedded,")
  out = append(out, "Infineon 32-bit embedded,")
  goto s0
f125:
  // >18	leshort		78		Element 14 64-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4e)) { goto f126 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t78\t\tElement 14 64-bit DSP,")
  out = append(out, "Element 14 64-bit DSP,")
  goto s0
f126:
  // >18	leshort		79		LSI Logic 16-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4f)) { goto f127 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t79\t\tLSI Logic 16-bit DSP,")
  out = append(out, "LSI Logic 16-bit DSP,")
  goto s0
f127:
  // >18	leshort		80		MMIX,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x50)) { goto f128 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t80\t\tMMIX,")
  out = append(out, "MMIX,")
  goto s0
f128:
  // >18	leshort		81		Harvard machine-independent,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x51)) { goto f129 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t81\t\tHarvard machine-independent,")
  out = append(out, "Harvard machine-independent,")
  goto s0
f129:
  // >18	leshort		82		SiTera Prism,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x52)) { goto f130 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t82\t\tSiTera Prism,")
  out = append(out, "SiTera Prism,")
  goto s0
f130:
  // >18	leshort		83		Atmel AVR 8-bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x53)) { goto f131 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t83\t\tAtmel AVR 8-bit,")
  out = append(out, "Atmel AVR 8-bit,")
  goto s0
f131:
  // >18	leshort		84		Fujitsu FR30,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x54)) { goto f132 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t84\t\tFujitsu FR30,")
  out = append(out, "Fujitsu FR30,")
  goto s0
f132:
  // >18	leshort		85		Mitsubishi D10V,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x55)) { goto f133 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t85\t\tMitsubishi D10V,")
  out = append(out, "Mitsubishi D10V,")
  goto s0
f133:
  // >18	leshort		86		Mitsubishi D30V,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x56)) { goto f134 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t86\t\tMitsubishi D30V,")
  out = append(out, "Mitsubishi D30V,")
  goto s0
f134:
  // >18	leshort		87		NEC v850,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x57)) { goto f135 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t87\t\tNEC v850,")
  out = append(out, "NEC v850,")
  goto s0
f135:
  // >18	leshort		88		Renesas M32R,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x58)) { goto f136 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t88\t\tRenesas M32R,")
  out = append(out, "Renesas M32R,")
  goto s0
f136:
  // >18	leshort		89		Matsushita MN10300,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x59)) { goto f137 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t89\t\tMatsushita MN10300,")
  out = append(out, "Matsushita MN10300,")
  goto s0
f137:
  // >18	leshort		90		Matsushita MN10200,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5a)) { goto f138 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t90\t\tMatsushita MN10200,")
  out = append(out, "Matsushita MN10200,")
  goto s0
f138:
  // >18	leshort		91		picoJava,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5b)) { goto f139 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t91\t\tpicoJava,")
  out = append(out, "picoJava,")
  goto s0
f139:
  // >18	leshort		92		OpenRISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5c)) { goto f140 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t92\t\tOpenRISC,")
  out = append(out, "OpenRISC,")
  goto s0
f140:
  // >18	leshort		93		ARC Cores Tangent-A5,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5d)) { goto f141 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t93\t\tARC Cores Tangent-A5,")
  out = append(out, "ARC Cores Tangent-A5,")
  goto s0
f141:
  // >18	leshort		94		Tensilica Xtensa,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5e)) { goto f142 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t94\t\tTensilica Xtensa,")
  out = append(out, "Tensilica Xtensa,")
  goto s0
f142:
  // >18	leshort		95		Alphamosaic VideoCore,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5f)) { goto f143 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t95\t\tAlphamosaic VideoCore,")
  out = append(out, "Alphamosaic VideoCore,")
  goto s0
f143:
  // >18	leshort		96		Thompson Multimedia,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x60)) { goto f144 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t96\t\tThompson Multimedia,")
  out = append(out, "Thompson Multimedia,")
  goto s0
f144:
  // >18	leshort		97		NatSemi 32k,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x61)) { goto f145 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t97\t\tNatSemi 32k,")
  out = append(out, "NatSemi 32k,")
  goto s0
f145:
  // >18	leshort		98		Tenor Network TPC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x62)) { goto f146 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t98\t\tTenor Network TPC,")
  out = append(out, "Tenor Network TPC,")
  goto s0
f146:
  // >18	leshort		99		Trebia SNP 1000,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x63)) { goto f147 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t99\t\tTrebia SNP 1000,")
  out = append(out, "Trebia SNP 1000,")
  goto s0
f147:
  // >18	leshort		100		STMicroelectronics ST200,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x64)) { goto f148 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t100\t\tSTMicroelectronics ST200,")
  out = append(out, "STMicroelectronics ST200,")
  goto s0
f148:
  // >18	leshort		101		Ubicom IP2022,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x65)) { goto f149 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t101\t\tUbicom IP2022,")
  out = append(out, "Ubicom IP2022,")
  goto s0
f149:
  // >18	leshort		102		MAX Processor,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x66)) { goto f150 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t102\t\tMAX Processor,")
  out = append(out, "MAX Processor,")
  goto s0
f150:
  // >18	leshort		103		NatSemi CompactRISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x67)) { goto f151 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t103\t\tNatSemi CompactRISC,")
  out = append(out, "NatSemi CompactRISC,")
  goto s0
f151:
  // >18	leshort		104		Fujitsu F2MC16,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x68)) { goto f152 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t104\t\tFujitsu F2MC16,")
  out = append(out, "Fujitsu F2MC16,")
  goto s0
f152:
  // >18	leshort		105		TI msp430,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x69)) { goto f153 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t105\t\tTI msp430,")
  out = append(out, "TI msp430,")
  goto s0
f153:
  // >18	leshort		106		Analog Devices Blackfin,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6a)) { goto f154 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t106\t\tAnalog Devices Blackfin,")
  out = append(out, "Analog Devices Blackfin,")
  goto s0
f154:
  // >18	leshort		107		S1C33 Family of Seiko Epson,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6b)) { goto f155 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t107\t\tS1C33 Family of Seiko Epson,")
  out = append(out, "S1C33 Family of Seiko Epson,")
  goto s0
f155:
  // >18	leshort		108		Sharp embedded,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6c)) { goto f156 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t108\t\tSharp embedded,")
  out = append(out, "Sharp embedded,")
  goto s0
f156:
  // >18	leshort		109		Arca RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6d)) { goto f157 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t109\t\tArca RISC,")
  out = append(out, "Arca RISC,")
  goto s0
f157:
  // >18	leshort		110		PKU-Unity Ltd.,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6e)) { goto f158 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t110\t\tPKU-Unity Ltd.,")
  out = append(out, "PKU-Unity Ltd.,")
  goto s0
f158:
  // >18	leshort		111		eXcess: 16/32/64-bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x6f)) { goto f159 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t111\t\teXcess: 16/32/64-bit,")
  out = append(out, "eXcess: 16/32/64-bit,")
  goto s0
f159:
  // >18	leshort		112		Icera Deep Execution Processor,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x70)) { goto f160 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t112\t\tIcera Deep Execution Processor,")
  out = append(out, "Icera Deep Execution Processor,")
  goto s0
f160:
  // >18	leshort		113		Altera Nios II,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x71)) { goto f161 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t113\t\tAltera Nios II,")
  out = append(out, "Altera Nios II,")
  goto s0
f161:
  // >18	leshort		114		NatSemi CRX,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x72)) { goto f162 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t114\t\tNatSemi CRX,")
  out = append(out, "NatSemi CRX,")
  goto s0
f162:
  // >18	leshort		115		Motorola XGATE,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x73)) { goto f163 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t115\t\tMotorola XGATE,")
  out = append(out, "Motorola XGATE,")
  goto s0
f163:
  // >18	leshort		116		Infineon C16x/XC16x,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x74)) { goto f164 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t116\t\tInfineon C16x/XC16x,")
  out = append(out, "Infineon C16x/XC16x,")
  goto s0
f164:
  // >18	leshort		117		Renesas M16C series,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x75)) { goto f165 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t117\t\tRenesas M16C series,")
  out = append(out, "Renesas M16C series,")
  goto s0
f165:
  // >18	leshort		118		Microchip dsPIC30F,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x76)) { goto f166 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t118\t\tMicrochip dsPIC30F,")
  out = append(out, "Microchip dsPIC30F,")
  goto s0
f166:
  // >18	leshort		119		Freescale RISC core,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x77)) { goto f167 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t119\t\tFreescale RISC core,")
  out = append(out, "Freescale RISC core,")
  goto s0
f167:
  // >18	leshort		120		Renesas M32C series,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x78)) { goto f168 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t120\t\tRenesas M32C series,")
  out = append(out, "Renesas M32C series,")
  goto s0
f168:
  // >18	leshort		131		Altium TSK3000 core,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x83)) { goto f169 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t131\t\tAltium TSK3000 core,")
  out = append(out, "Altium TSK3000 core,")
  goto s0
f169:
  // >18	leshort		132		Freescale RS08,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x84)) { goto f170 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t132\t\tFreescale RS08,")
  out = append(out, "Freescale RS08,")
  goto s0
f170:
  // >18	leshort		134		Cyan Technology eCOG2,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x86)) { goto f171 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t134\t\tCyan Technology eCOG2,")
  out = append(out, "Cyan Technology eCOG2,")
  goto s0
f171:
  // >18	leshort		135		Sunplus S+core7 RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x87)) { goto f172 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t135\t\tSunplus S+core7 RISC,")
  out = append(out, "Sunplus S+core7 RISC,")
  goto s0
f172:
  // >18	leshort		136		New Japan Radio (NJR) 24-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x88)) { goto f173 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t136\t\tNew Japan Radio (NJR) 24-bit DSP,")
  out = append(out, "New Japan Radio (NJR) 24-bit DSP,")
  goto s0
f173:
  // >18	leshort		137		Broadcom VideoCore III,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x89)) { goto f174 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t137\t\tBroadcom VideoCore III,")
  out = append(out, "Broadcom VideoCore III,")
  goto s0
f174:
  // >18	leshort		138		LatticeMico32,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8a)) { goto f175 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t138\t\tLatticeMico32,")
  out = append(out, "LatticeMico32,")
  goto s0
f175:
  // >18	leshort		139		Seiko Epson C17 family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8b)) { goto f176 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t139\t\tSeiko Epson C17 family,")
  out = append(out, "Seiko Epson C17 family,")
  goto s0
f176:
  // >18	leshort		140		TI TMS320C6000 DSP family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8c)) { goto f177 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t140\t\tTI TMS320C6000 DSP family,")
  out = append(out, "TI TMS320C6000 DSP family,")
  goto s0
f177:
  // >18	leshort		141		TI TMS320C2000 DSP family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8d)) { goto f178 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t141\t\tTI TMS320C2000 DSP family,")
  out = append(out, "TI TMS320C2000 DSP family,")
  goto s0
f178:
  // >18	leshort		142		TI TMS320C55x DSP family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8e)) { goto f179 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t142\t\tTI TMS320C55x DSP family,")
  out = append(out, "TI TMS320C55x DSP family,")
  goto s0
f179:
  // >18	leshort		160		STMicroelectronics 64bit VLIW DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa0)) { goto f180 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t160\t\tSTMicroelectronics 64bit VLIW DSP,")
  out = append(out, "STMicroelectronics 64bit VLIW DSP,")
  goto s0
f180:
  // >18	leshort		161		Cypress M8C,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa1)) { goto f181 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t161\t\tCypress M8C,")
  out = append(out, "Cypress M8C,")
  goto s0
f181:
  // >18	leshort		162		Renesas R32C series,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa2)) { goto f182 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t162\t\tRenesas R32C series,")
  out = append(out, "Renesas R32C series,")
  goto s0
f182:
  // >18	leshort		163		NXP TriMedia family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa3)) { goto f183 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t163\t\tNXP TriMedia family,")
  out = append(out, "NXP TriMedia family,")
  goto s0
f183:
  // >18	leshort		164		QUALCOMM DSP6,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa4)) { goto f184 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t164\t\tQUALCOMM DSP6,")
  out = append(out, "QUALCOMM DSP6,")
  goto s0
f184:
  // >18	leshort		165		Intel 8051 and variants,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa5)) { goto f185 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t165\t\tIntel 8051 and variants,")
  out = append(out, "Intel 8051 and variants,")
  goto s0
f185:
  // >18	leshort		166		STMicroelectronics STxP7x family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa6)) { goto f186 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t166\t\tSTMicroelectronics STxP7x family,")
  out = append(out, "STMicroelectronics STxP7x family,")
  goto s0
f186:
  // >18	leshort		167		Andes embedded RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa7)) { goto f187 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t167\t\tAndes embedded RISC,")
  out = append(out, "Andes embedded RISC,")
  goto s0
f187:
  // >18	leshort		168		Cyan eCOG1X family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa8)) { goto f188 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t168\t\tCyan eCOG1X family,")
  out = append(out, "Cyan eCOG1X family,")
  goto s0
f188:
  // >18	leshort		169		Dallas MAXQ30,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa9)) { goto f189 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t169\t\tDallas MAXQ30,")
  out = append(out, "Dallas MAXQ30,")
  goto s0
f189:
  // >18	leshort		170		New Japan Radio (NJR) 16-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xaa)) { goto f190 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t170\t\tNew Japan Radio (NJR) 16-bit DSP,")
  out = append(out, "New Japan Radio (NJR) 16-bit DSP,")
  goto s0
f190:
  // >18	leshort		171		M2000 Reconfigurable RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xab)) { goto f191 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t171\t\tM2000 Reconfigurable RISC,")
  out = append(out, "M2000 Reconfigurable RISC,")
  goto s0
f191:
  // >18	leshort		172		Cray NV2 vector architecture,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xac)) { goto f192 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t172\t\tCray NV2 vector architecture,")
  out = append(out, "Cray NV2 vector architecture,")
  goto s0
f192:
  // >18	leshort		173		Renesas RX family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xad)) { goto f193 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t173\t\tRenesas RX family,")
  out = append(out, "Renesas RX family,")
  goto s0
f193:
  // >18	leshort		174		META,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xae)) { goto f194 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t174\t\tMETA,")
  out = append(out, "META,")
  goto s0
f194:
  // >18	leshort		175		MCST Elbrus,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xaf)) { goto f195 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t175\t\tMCST Elbrus,")
  out = append(out, "MCST Elbrus,")
  goto s0
f195:
  // >18	leshort		176		Cyan Technology eCOG16 family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb0)) { goto f196 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t176\t\tCyan Technology eCOG16 family,")
  out = append(out, "Cyan Technology eCOG16 family,")
  goto s0
f196:
  // >18	leshort		177		NatSemi CompactRISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb1)) { goto f197 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t177\t\tNatSemi CompactRISC,")
  out = append(out, "NatSemi CompactRISC,")
  goto s0
f197:
  // >18	leshort		178		Freescale Extended Time Processing Unit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb2)) { goto f198 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t178\t\tFreescale Extended Time Processing Unit,")
  out = append(out, "Freescale Extended Time Processing Unit,")
  goto s0
f198:
  // >18	leshort		179		Infineon SLE9X,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb3)) { goto f199 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t179\t\tInfineon SLE9X,")
  out = append(out, "Infineon SLE9X,")
  goto s0
f199:
  // >18	leshort		180		Intel L1OM,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb4)) { goto f200 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t180\t\tIntel L1OM,")
  out = append(out, "Intel L1OM,")
  goto s0
f200:
  // >18	leshort		181		Intel K1OM,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb5)) { goto f201 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t181\t\tIntel K1OM,")
  out = append(out, "Intel K1OM,")
  goto s0
f201:
  // >18	leshort		183		ARM aarch64,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb7)) { goto f202 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t183\t\tARM aarch64,")
  out = append(out, "ARM aarch64,")
  goto s0
f202:
  // >18	leshort		185		Atmel 32-bit family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xb9)) { goto f203 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t185\t\tAtmel 32-bit family,")
  out = append(out, "Atmel 32-bit family,")
  goto s0
f203:
  // >18	leshort		186		STMicroeletronics STM8 8-bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xba)) { goto f204 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t186\t\tSTMicroeletronics STM8 8-bit,")
  out = append(out, "STMicroeletronics STM8 8-bit,")
  goto s0
f204:
  // >18	leshort		187		Tilera TILE64,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbb)) { goto f205 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t187\t\tTilera TILE64,")
  out = append(out, "Tilera TILE64,")
  goto s0
f205:
  // >18	leshort		188		Tilera TILEPro,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbc)) { goto f206 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t188\t\tTilera TILEPro,")
  out = append(out, "Tilera TILEPro,")
  goto s0
f206:
  // >18	leshort		189		Xilinx MicroBlaze 32-bit RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbd)) { goto f207 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t189\t\tXilinx MicroBlaze 32-bit RISC,")
  out = append(out, "Xilinx MicroBlaze 32-bit RISC,")
  goto s0
f207:
  // >18	leshort		190		NVIDIA CUDA architecture,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbe)) { goto f208 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t190\t\tNVIDIA CUDA architecture,")
  out = append(out, "NVIDIA CUDA architecture,")
  goto s0
f208:
  // >18	leshort		191		Tilera TILE-Gx,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbf)) { goto f209 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t191\t\tTilera TILE-Gx,")
  out = append(out, "Tilera TILE-Gx,")
  goto s0
f209:
  // >18	leshort		197		Renesas RL78 family,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xc5)) { goto f210 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t197\t\tRenesas RL78 family,")
  out = append(out, "Renesas RL78 family,")
  goto s0
f210:
  // >18	leshort		199		Renesas 78K0R,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xc7)) { goto f211 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t199\t\tRenesas 78K0R,")
  out = append(out, "Renesas 78K0R,")
  goto s0
f211:
  // >18	leshort		0x1057		AVR (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1057)) { goto f212 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x1057\t\tAVR (unofficial),")
  out = append(out, "AVR (unofficial),")
  goto s0
f212:
  // >18	leshort		0x1059		MSP430 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1059)) { goto f213 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x1059\t\tMSP430 (unofficial),")
  out = append(out, "MSP430 (unofficial),")
  goto s0
f213:
  // >18	leshort		0x1223		Adapteva Epiphany (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1223)) { goto f214 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x1223\t\tAdapteva Epiphany (unofficial),")
  out = append(out, "Adapteva Epiphany (unofficial),")
  goto s0
f214:
  // >18	leshort		0x2530		Morpho MT (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x2530)) { goto f215 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x2530\t\tMorpho MT (unofficial),")
  out = append(out, "Morpho MT (unofficial),")
  goto s0
f215:
  // >18	leshort		0x3330		FR30 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3330)) { goto f216 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x3330\t\tFR30 (unofficial),")
  out = append(out, "FR30 (unofficial),")
  goto s0
f216:
  // >18	leshort		0x3426		OpenRISC (obsolete),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x3426)) { goto f217 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x3426\t\tOpenRISC (obsolete),")
  out = append(out, "OpenRISC (obsolete),")
  goto s0
f217:
  // >18	leshort		0x4688		Infineon C166 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x4688)) { goto f218 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x4688\t\tInfineon C166 (unofficial),")
  out = append(out, "Infineon C166 (unofficial),")
  goto s0
f218:
  // >18	leshort		0x5441		Cygnus FRV (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5441)) { goto f219 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x5441\t\tCygnus FRV (unofficial),")
  out = append(out, "Cygnus FRV (unofficial),")
  goto s0
f219:
  // >18	leshort		0x5aa5		DLX (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x5aa5)) { goto f220 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x5aa5\t\tDLX (unofficial),")
  out = append(out, "DLX (unofficial),")
  goto s0
f220:
  // >18	leshort		0x7650		Cygnus D10V (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x7650)) { goto f221 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x7650\t\tCygnus D10V (unofficial),")
  out = append(out, "Cygnus D10V (unofficial),")
  goto s0
f221:
  // >18	leshort		0x7676		Cygnus D30V (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x7676)) { goto f222 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x7676\t\tCygnus D30V (unofficial),")
  out = append(out, "Cygnus D30V (unofficial),")
  goto s0
f222:
  // >18	leshort		0x8217		Ubicom IP2xxx (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8217)) { goto f223 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x8217\t\tUbicom IP2xxx (unofficial),")
  out = append(out, "Ubicom IP2xxx (unofficial),")
  goto s0
f223:
  // >18	leshort		0x8472		OpenRISC (obsolete),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x8472)) { goto f224 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x8472\t\tOpenRISC (obsolete),")
  out = append(out, "OpenRISC (obsolete),")
  goto s0
f224:
  // >18	leshort		0x9025		Cygnus PowerPC (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x9025)) { goto f225 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9025\t\tCygnus PowerPC (unofficial),")
  out = append(out, "Cygnus PowerPC (unofficial),")
  goto s0
f225:
  // >18	leshort		0x9026		Alpha (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x9026)) { goto f226 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9026\t\tAlpha (unofficial),")
  out = append(out, "Alpha (unofficial),")
  goto s0
f226:
  // >18	leshort		0x9041		Cygnus M32R (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x9041)) { goto f227 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9041\t\tCygnus M32R (unofficial),")
  out = append(out, "Cygnus M32R (unofficial),")
  goto s0
f227:
  // >18	leshort		0x9080		Cygnus V850 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x9080)) { goto f228 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9080\t\tCygnus V850 (unofficial),")
  out = append(out, "Cygnus V850 (unofficial),")
  goto s0
f228:
  // >18	leshort		0xa390		IBM S/390 (obsolete),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xa390)) { goto f229 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xa390\t\tIBM S/390 (obsolete),")
  out = append(out, "IBM S/390 (obsolete),")
  goto s0
f229:
  // >18	leshort		0xabc7		Old Xtensa (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xabc7)) { goto f230 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xabc7\t\tOld Xtensa (unofficial),")
  out = append(out, "Old Xtensa (unofficial),")
  goto s0
f230:
  // >18	leshort		0xad45		xstormy16 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xad45)) { goto f231 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xad45\t\txstormy16 (unofficial),")
  out = append(out, "xstormy16 (unofficial),")
  goto s0
f231:
  // >18	leshort		0xbaab		Old MicroBlaze (unofficial),,
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbaab)) { goto f232 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xbaab\t\tOld MicroBlaze (unofficial),,")
  out = append(out, "Old MicroBlaze (unofficial),,")
  goto s0
f232:
  // >18	leshort		0xbeef		Cygnus MN10300 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xbeef)) { goto f233 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xbeef\t\tCygnus MN10300 (unofficial),")
  out = append(out, "Cygnus MN10300 (unofficial),")
  goto s0
f233:
  // >18	leshort		0xdead		Cygnus MN10200 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xdead)) { goto f234 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xdead\t\tCygnus MN10200 (unofficial),")
  out = append(out, "Cygnus MN10200 (unofficial),")
  goto s0
f234:
  // >18	leshort		0xf00d		Toshiba MeP (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xf00d)) { goto f235 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xf00d\t\tToshiba MeP (unofficial),")
  out = append(out, "Toshiba MeP (unofficial),")
  goto s0
f235:
  // >18	leshort		0xfeb0		Renesas M32C (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xfeb0)) { goto f236 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfeb0\t\tRenesas M32C (unofficial),")
  out = append(out, "Renesas M32C (unofficial),")
  goto s0
f236:
  // >18	leshort		0xfeba		Vitesse IQ2000 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xfeba)) { goto f237 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfeba\t\tVitesse IQ2000 (unofficial),")
  out = append(out, "Vitesse IQ2000 (unofficial),")
  goto s0
f237:
  // >18	leshort		0xfebb		NIOS (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xfebb)) { goto f238 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfebb\t\tNIOS (unofficial),")
  out = append(out, "NIOS (unofficial),")
  goto s0
f238:
  // >18	leshort		0xfeed		Moxie (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xfeed)) { goto f239 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfeed\t\tMoxie (unofficial),")
  out = append(out, "Moxie (unofficial),")
  goto s0
f239:
  // >18	default		x
  off = pageOff + 0x12
  // uh oh unhandled kind default
  goto f240
  fmt.Printf("matched rule: %s\n", ">18\tdefault\t\tx")
  // >>18	leshort		x		*unknown arch 0x%x*
  off = pageOff + 0x12
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>18\tleshort\t\tx\t\t*unknown arch 0x%x*")
  out = append(out, "*unknown arch 0x%x*")
  goto s240
s240:
  goto s0
f240:
  // >20	lelong		0		invalid version
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f242 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t0\t\tinvalid version")
  out = append(out, "invalid version")
  goto s0
f242:
  // >20	lelong		1		version 1
  off = pageOff + 0x14
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f243 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t1\t\tversion 1")
  out = append(out, "version 1")
  goto s0
f243:
s0:
  goto end
end:
  return out, nil
}

func IdentifyElfLe__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		elf-le
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\telf-le")
  // >16	leshort		0		no file type,
  off = pageOff + 0x10
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f1 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t0\t\tno file type,")
  out = append(out, "no file type,")
  goto s0
f1:
  // >16	leshort		1		relocatable,
  off = pageOff + 0x10
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f2 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t1\t\trelocatable,")
  out = append(out, "relocatable,")
  goto s0
f2:
  // >16	leshort		2		executable,
  off = pageOff + 0x10
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t2\t\texecutable,")
  out = append(out, "executable,")
  goto s0
f3:
  // >16	leshort		3		shared object,
  off = pageOff + 0x10
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f4 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t3\t\tshared object,")
  out = append(out, "shared object,")
  goto s0
f4:
  // >16	leshort		4		core file
  off = pageOff + 0x10
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f5 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t4\t\tcore file")
  out = append(out, "core file")
  goto s0
f5:
  // >16	leshort		&0xff00		processor-specific,
  off = pageOff + 0x10
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xff00)) { goto f6 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">16\tleshort\t\t&0xff00\t\tprocessor-specific,")
  out = append(out, "processor-specific,")
  goto s0
f6:
  // >18	clear		x
  off = pageOff + 0x12
  // uh oh unhandled kind clear
  goto f7
  fmt.Printf("matched rule: %s\n", ">18\tclear\t\tx")
  goto s0
f7:
  // >18	leshort		0		no machine,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f8 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0\t\tno machine,")
  out = append(out, "no machine,")
  goto s0
f8:
  // >18	leshort		1		AT&T WE32100,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f9 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t1\t\tAT&T WE32100,")
  out = append(out, "AT&T WE32100,")
  goto s0
f9:
  // >18	leshort		2		SPARC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f10 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t2\t\tSPARC,")
  out = append(out, "SPARC,")
  goto s0
f10:
  // >18	leshort		3		Intel 80386,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f11 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t3\t\tIntel 80386,")
  out = append(out, "Intel 80386,")
  goto s0
f11:
  // >18	leshort		4		Motorola m68k,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f12 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t4\t\tMotorola m68k,")
  out = append(out, "Motorola m68k,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f13 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong		&0x01000000	68000,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1000000)) { goto f14 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x01000000\t68000,")
  out = append(out, "68000,")
  goto s13
f14:
  // >>>36	lelong		&0x00810000	CPU32,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x810000)) { goto f15 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x00810000\tCPU32,")
  out = append(out, "CPU32,")
  goto s13
f15:
  // >>>36	lelong		0		68020,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f16 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t0\t\t68020,")
  out = append(out, "68020,")
  goto s13
f16:
s13:
  goto s12
f13:
s12:
  goto s0
f12:
  // >18	leshort		5		Motorola m88k,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f17 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t5\t\tMotorola m88k,")
  out = append(out, "Motorola m88k,")
  goto s0
f17:
  // >18	leshort		6		Intel 80486,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f18 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t6\t\tIntel 80486,")
  out = append(out, "Intel 80486,")
  goto s0
f18:
  // >18	leshort		7		Intel 80860,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f19 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t7\t\tIntel 80860,")
  out = append(out, "Intel 80860,")
  goto s0
f19:
  // >18	leshort		8		MIPS,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f20 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t8\t\tMIPS,")
  out = append(out, "MIPS,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f21 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong		&0x20		N32
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x20)) { goto f22 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x20\t\tN32")
  out = append(out, "N32")
  goto s21
f22:
s21:
  goto s20
f21:
s20:
  goto s0
f20:
  // >18	leshort		10		MIPS,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f23 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t10\t\tMIPS,")
  out = append(out, "MIPS,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f24 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong		&0x20		N32
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x20)) { goto f25 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x20\t\tN32")
  out = append(out, "N32")
  goto s24
f25:
s24:
  goto s23
f24:
s23:
  goto s0
f23:
  // >18	leshort		8
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f26 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t8")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f27 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36  lelong&0xf0000000	0x00000000	MIPS-I
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x0)) { goto f28 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x00000000\tMIPS-I")
  out = append(out, "MIPS-I")
  goto s27
f28:
  // >>>36  lelong&0xf0000000	0x10000000	MIPS-II
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x10000000)) { goto f29 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x10000000\tMIPS-II")
  out = append(out, "MIPS-II")
  goto s27
f29:
  // >>>36  lelong&0xf0000000	0x20000000	MIPS-III
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x20000000)) { goto f30 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x20000000\tMIPS-III")
  out = append(out, "MIPS-III")
  goto s27
f30:
  // >>>36  lelong&0xf0000000	0x30000000	MIPS-IV
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x30000000)) { goto f31 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x30000000\tMIPS-IV")
  out = append(out, "MIPS-IV")
  goto s27
f31:
  // >>>36  lelong&0xf0000000	0x40000000	MIPS-V
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x40000000)) { goto f32 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x40000000\tMIPS-V")
  out = append(out, "MIPS-V")
  goto s27
f32:
  // >>>36  lelong&0xf0000000	0x50000000	MIPS32
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x50000000)) { goto f33 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x50000000\tMIPS32")
  out = append(out, "MIPS32")
  goto s27
f33:
  // >>>36  lelong&0xf0000000	0x60000000	MIPS64
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x60000000)) { goto f34 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x60000000\tMIPS64")
  out = append(out, "MIPS64")
  goto s27
f34:
  // >>>36  lelong&0xf0000000	0x70000000	MIPS32 rel2
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x70000000)) { goto f35 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x70000000\tMIPS32 rel2")
  out = append(out, "MIPS32 rel2")
  goto s27
f35:
  // >>>36  lelong&0xf0000000	0x80000000	MIPS64 rel2
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x80000000)) { goto f36 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36  lelong&0xf0000000\t0x80000000\tMIPS64 rel2")
  out = append(out, "MIPS64 rel2")
  goto s27
f36:
s27:
  goto s26
f27:
  // >>4	byte		2
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f37 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t2")
  // >>>48  lelong&0xf0000000	0x00000000	MIPS-I
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x0)) { goto f38 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x00000000\tMIPS-I")
  out = append(out, "MIPS-I")
  goto s37
f38:
  // >>>48  lelong&0xf0000000	0x10000000	MIPS-II
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x10000000)) { goto f39 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x10000000\tMIPS-II")
  out = append(out, "MIPS-II")
  goto s37
f39:
  // >>>48  lelong&0xf0000000	0x20000000	MIPS-III
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x20000000)) { goto f40 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x20000000\tMIPS-III")
  out = append(out, "MIPS-III")
  goto s37
f40:
  // >>>48  lelong&0xf0000000	0x30000000	MIPS-IV
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x30000000)) { goto f41 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x30000000\tMIPS-IV")
  out = append(out, "MIPS-IV")
  goto s37
f41:
  // >>>48  lelong&0xf0000000	0x40000000	MIPS-V
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x40000000)) { goto f42 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x40000000\tMIPS-V")
  out = append(out, "MIPS-V")
  goto s37
f42:
  // >>>48  lelong&0xf0000000	0x50000000	MIPS32
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x50000000)) { goto f43 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x50000000\tMIPS32")
  out = append(out, "MIPS32")
  goto s37
f43:
  // >>>48  lelong&0xf0000000	0x60000000	MIPS64
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x60000000)) { goto f44 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x60000000\tMIPS64")
  out = append(out, "MIPS64")
  goto s37
f44:
  // >>>48  lelong&0xf0000000	0x70000000	MIPS32 rel2
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x70000000)) { goto f45 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x70000000\tMIPS32 rel2")
  out = append(out, "MIPS32 rel2")
  goto s37
f45:
  // >>>48  lelong&0xf0000000	0x80000000	MIPS64 rel2
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf0000000 == 0x80000000)) { goto f46 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48  lelong&0xf0000000\t0x80000000\tMIPS64 rel2")
  out = append(out, "MIPS64 rel2")
  goto s37
f46:
s37:
  goto s26
f37:
s26:
  goto s0
f26:
  // >18	leshort		9		Amdahl,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f47 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t9\t\tAmdahl,")
  out = append(out, "Amdahl,")
  goto s0
f47:
  // >18	leshort		10		MIPS (deprecated),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f48 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t10\t\tMIPS (deprecated),")
  out = append(out, "MIPS (deprecated),")
  goto s0
f48:
  // >18	leshort		11		RS6000,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f49 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t11\t\tRS6000,")
  out = append(out, "RS6000,")
  goto s0
f49:
  // >18	leshort		15		PA-RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xf)) { goto f50 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t15\t\tPA-RISC,")
  out = append(out, "PA-RISC,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f51 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>38	leshort		0x0214		2.0
  off = pageOff + 0x26
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x214)) { goto f52 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>38\tleshort\t\t0x0214\t\t2.0")
  out = append(out, "2.0")
  goto s51
f52:
  // >>>36	leshort		&0x0008		(LP64)
  off = pageOff + 0x24
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f53 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>36\tleshort\t\t&0x0008\t\t(LP64)")
  out = append(out, "(LP64)")
  goto s51
f53:
s51:
  goto s50
f51:
  // >>4	byte		2
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f54 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t2")
  // >>>50	leshort		0x0214		2.0
  off = pageOff + 0x32
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x214)) { goto f55 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>50\tleshort\t\t0x0214\t\t2.0")
  out = append(out, "2.0")
  goto s54
f55:
  // >>>48	leshort		&0x0008		(LP64)
  off = pageOff + 0x30
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f56 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>48\tleshort\t\t&0x0008\t\t(LP64)")
  out = append(out, "(LP64)")
  goto s54
f56:
s54:
  goto s50
f54:
s50:
  goto s0
f50:
  // >18	leshort		16		nCUBE,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x10)) { goto f57 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t16\t\tnCUBE,")
  out = append(out, "nCUBE,")
  goto s0
f57:
  // >18	leshort		17		Fujitsu VPP500,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x11)) { goto f58 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t17\t\tFujitsu VPP500,")
  out = append(out, "Fujitsu VPP500,")
  goto s0
f58:
  // >18	leshort		18		SPARC32PLUS,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x12)) { goto f59 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t18\t\tSPARC32PLUS,")
  out = append(out, "SPARC32PLUS,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f60 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong&0xffff00	0x000100	V8+ Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x100)) { goto f61 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000100\tV8+ Required,")
  out = append(out, "V8+ Required,")
  goto s60
f61:
  // >>>36	lelong&0xffff00	0x000200	Sun UltraSPARC1 Extensions Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x200)) { goto f62 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000200\tSun UltraSPARC1 Extensions Required,")
  out = append(out, "Sun UltraSPARC1 Extensions Required,")
  goto s60
f62:
  // >>>36	lelong&0xffff00	0x000400	HaL R1 Extensions Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x400)) { goto f63 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000400\tHaL R1 Extensions Required,")
  out = append(out, "HaL R1 Extensions Required,")
  goto s60
f63:
  // >>>36	lelong&0xffff00	0x000800	Sun UltraSPARC3 Extensions Required,
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x800)) { goto f64 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xffff00\t0x000800\tSun UltraSPARC3 Extensions Required,")
  out = append(out, "Sun UltraSPARC3 Extensions Required,")
  goto s60
f64:
s60:
  goto s59
f60:
s59:
  goto s0
f59:
  // >18	leshort		19		Intel 80960,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x13)) { goto f65 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t19\t\tIntel 80960,")
  out = append(out, "Intel 80960,")
  goto s0
f65:
  // >18	leshort		20		PowerPC or cisco 4500,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x14)) { goto f66 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t20\t\tPowerPC or cisco 4500,")
  out = append(out, "PowerPC or cisco 4500,")
  goto s0
f66:
  // >18	leshort		21		64-bit PowerPC or cisco 7500,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x15)) { goto f67 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t21\t\t64-bit PowerPC or cisco 7500,")
  out = append(out, "64-bit PowerPC or cisco 7500,")
  goto s0
f67:
  // >18	leshort		22		IBM S/390,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x16)) { goto f68 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t22\t\tIBM S/390,")
  out = append(out, "IBM S/390,")
  goto s0
f68:
  // >18	leshort		23		Cell SPU,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x17)) { goto f69 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t23\t\tCell SPU,")
  out = append(out, "Cell SPU,")
  goto s0
f69:
  // >18	leshort		24		cisco SVIP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x18)) { goto f70 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t24\t\tcisco SVIP,")
  out = append(out, "cisco SVIP,")
  goto s0
f70:
  // >18	leshort		25		cisco 7200,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x19)) { goto f71 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t25\t\tcisco 7200,")
  out = append(out, "cisco 7200,")
  goto s0
f71:
  // >18	leshort		36		NEC V800 or cisco 12000,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x24)) { goto f72 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t36\t\tNEC V800 or cisco 12000,")
  out = append(out, "NEC V800 or cisco 12000,")
  goto s0
f72:
  // >18	leshort		37		Fujitsu FR20,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x25)) { goto f73 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t37\t\tFujitsu FR20,")
  out = append(out, "Fujitsu FR20,")
  goto s0
f73:
  // >18	leshort		38		TRW RH-32,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x26)) { goto f74 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t38\t\tTRW RH-32,")
  out = append(out, "TRW RH-32,")
  goto s0
f74:
  // >18	leshort		39		Motorola RCE,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x27)) { goto f75 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t39\t\tMotorola RCE,")
  out = append(out, "Motorola RCE,")
  goto s0
f75:
  // >18	leshort		40		ARM,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x28)) { goto f76 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t40\t\tARM,")
  out = append(out, "ARM,")
  // >>4	byte		1
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f77 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t1")
  // >>>36	lelong&0xff000000	0x04000000	EABI4
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xff000000 == 0x4000000)) { goto f78 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xff000000\t0x04000000\tEABI4")
  out = append(out, "EABI4")
  goto s77
f78:
  // >>>36	lelong&0xff000000	0x05000000	EABI5
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xff000000 == 0x5000000)) { goto f79 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong&0xff000000\t0x05000000\tEABI5")
  out = append(out, "EABI5")
  goto s77
f79:
  // >>>36	lelong		&0x00800000	BE8
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x800000)) { goto f80 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x00800000\tBE8")
  out = append(out, "BE8")
  goto s77
f80:
  // >>>36	lelong		&0x00400000	LE8
  off = pageOff + 0x24
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x400000)) { goto f81 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>36\tlelong\t\t&0x00400000\tLE8")
  out = append(out, "LE8")
  goto s77
f81:
s77:
  goto s76
f77:
s76:
  goto s0
f76:
  // >18	leshort		41		Alpha,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x29)) { goto f82 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t41\t\tAlpha,")
  out = append(out, "Alpha,")
  goto s0
f82:
  // >18	leshort		42		Renesas SH,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2a)) { goto f83 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t42\t\tRenesas SH,")
  out = append(out, "Renesas SH,")
  goto s0
f83:
  // >18	leshort		43		SPARC V9,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2b)) { goto f84 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t43\t\tSPARC V9,")
  out = append(out, "SPARC V9,")
  // >>4	byte		2
  off = pageOff + 0x4
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f85 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>4\tbyte\t\t2")
  // >>>48	lelong&0xffff00	0x000200	Sun UltraSPARC1 Extensions Required,
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x200)) { goto f86 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0xffff00\t0x000200\tSun UltraSPARC1 Extensions Required,")
  out = append(out, "Sun UltraSPARC1 Extensions Required,")
  goto s85
f86:
  // >>>48	lelong&0xffff00	0x000400	HaL R1 Extensions Required,
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x400)) { goto f87 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0xffff00\t0x000400\tHaL R1 Extensions Required,")
  out = append(out, "HaL R1 Extensions Required,")
  goto s85
f87:
  // >>>48	lelong&0xffff00	0x000800	Sun UltraSPARC3 Extensions Required,
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffff00 == 0x800)) { goto f88 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0xffff00\t0x000800\tSun UltraSPARC3 Extensions Required,")
  out = append(out, "Sun UltraSPARC3 Extensions Required,")
  goto s85
f88:
  // >>>48	lelong&0x3	0		total store ordering,
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x0)) { goto f89 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0x3\t0\t\ttotal store ordering,")
  out = append(out, "total store ordering,")
  goto s85
f89:
  // >>>48	lelong&0x3	1		partial store ordering,
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x1)) { goto f90 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0x3\t1\t\tpartial store ordering,")
  out = append(out, "partial store ordering,")
  goto s85
f90:
  // >>>48	lelong&0x3	2		relaxed memory ordering,
  off = pageOff + 0x30
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x2)) { goto f91 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>48\tlelong&0x3\t2\t\trelaxed memory ordering,")
  out = append(out, "relaxed memory ordering,")
  goto s85
f91:
s85:
  goto s84
f85:
s84:
  goto s0
f84:
  // >18	leshort		44		Siemens Tricore Embedded Processor,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2c)) { goto f92 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t44\t\tSiemens Tricore Embedded Processor,")
  out = append(out, "Siemens Tricore Embedded Processor,")
  goto s0
f92:
  // >18	leshort		45		Argonaut RISC Core, Argonaut Technologies Inc.,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2d)) { goto f93 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t45\t\tArgonaut RISC Core, Argonaut Technologies Inc.,")
  out = append(out, "Argonaut RISC Core, Argonaut Technologies Inc.,")
  goto s0
f93:
  // >18	leshort		46		Renesas H8/300,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2e)) { goto f94 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t46\t\tRenesas H8/300,")
  out = append(out, "Renesas H8/300,")
  goto s0
f94:
  // >18	leshort		47		Renesas H8/300H,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2f)) { goto f95 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t47\t\tRenesas H8/300H,")
  out = append(out, "Renesas H8/300H,")
  goto s0
f95:
  // >18	leshort		48		Renesas H8S,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x30)) { goto f96 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t48\t\tRenesas H8S,")
  out = append(out, "Renesas H8S,")
  goto s0
f96:
  // >18	leshort		49		Renesas H8/500,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x31)) { goto f97 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t49\t\tRenesas H8/500,")
  out = append(out, "Renesas H8/500,")
  goto s0
f97:
  // >18	leshort		50		IA-64,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x32)) { goto f98 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t50\t\tIA-64,")
  out = append(out, "IA-64,")
  goto s0
f98:
  // >18	leshort		51		Stanford MIPS-X,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x33)) { goto f99 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t51\t\tStanford MIPS-X,")
  out = append(out, "Stanford MIPS-X,")
  goto s0
f99:
  // >18	leshort		52		Motorola Coldfire,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x34)) { goto f100 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t52\t\tMotorola Coldfire,")
  out = append(out, "Motorola Coldfire,")
  goto s0
f100:
  // >18	leshort		53		Motorola M68HC12,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x35)) { goto f101 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t53\t\tMotorola M68HC12,")
  out = append(out, "Motorola M68HC12,")
  goto s0
f101:
  // >18	leshort		54		Fujitsu MMA,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x36)) { goto f102 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t54\t\tFujitsu MMA,")
  out = append(out, "Fujitsu MMA,")
  goto s0
f102:
  // >18	leshort		55		Siemens PCP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x37)) { goto f103 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t55\t\tSiemens PCP,")
  out = append(out, "Siemens PCP,")
  goto s0
f103:
  // >18	leshort		56		Sony nCPU,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x38)) { goto f104 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t56\t\tSony nCPU,")
  out = append(out, "Sony nCPU,")
  goto s0
f104:
  // >18	leshort		57		Denso NDR1,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x39)) { goto f105 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t57\t\tDenso NDR1,")
  out = append(out, "Denso NDR1,")
  goto s0
f105:
  // >18	leshort		58		Start*Core,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3a)) { goto f106 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t58\t\tStart*Core,")
  out = append(out, "Start*Core,")
  goto s0
f106:
  // >18	leshort		59		Toyota ME16,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3b)) { goto f107 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t59\t\tToyota ME16,")
  out = append(out, "Toyota ME16,")
  goto s0
f107:
  // >18	leshort		60		ST100,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3c)) { goto f108 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t60\t\tST100,")
  out = append(out, "ST100,")
  goto s0
f108:
  // >18	leshort		61		Tinyj emb.,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3d)) { goto f109 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t61\t\tTinyj emb.,")
  out = append(out, "Tinyj emb.,")
  goto s0
f109:
  // >18	leshort		62		x86-64,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3e)) { goto f110 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t62\t\tx86-64,")
  out = append(out, "x86-64,")
  goto s0
f110:
  // >18	leshort		63		Sony DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3f)) { goto f111 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t63\t\tSony DSP,")
  out = append(out, "Sony DSP,")
  goto s0
f111:
  // >18	leshort		64		DEC PDP-10,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x40)) { goto f112 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t64\t\tDEC PDP-10,")
  out = append(out, "DEC PDP-10,")
  goto s0
f112:
  // >18	leshort		65		DEC PDP-11,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x41)) { goto f113 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t65\t\tDEC PDP-11,")
  out = append(out, "DEC PDP-11,")
  goto s0
f113:
  // >18	leshort		66		FX66,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x42)) { goto f114 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t66\t\tFX66,")
  out = append(out, "FX66,")
  goto s0
f114:
  // >18	leshort		67		ST9+ 8/16 bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x43)) { goto f115 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t67\t\tST9+ 8/16 bit,")
  out = append(out, "ST9+ 8/16 bit,")
  goto s0
f115:
  // >18	leshort		68		ST7 8 bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x44)) { goto f116 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t68\t\tST7 8 bit,")
  out = append(out, "ST7 8 bit,")
  goto s0
f116:
  // >18	leshort		69		MC68HC16,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x45)) { goto f117 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t69\t\tMC68HC16,")
  out = append(out, "MC68HC16,")
  goto s0
f117:
  // >18	leshort		70		MC68HC11,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x46)) { goto f118 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t70\t\tMC68HC11,")
  out = append(out, "MC68HC11,")
  goto s0
f118:
  // >18	leshort		71		MC68HC08,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x47)) { goto f119 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t71\t\tMC68HC08,")
  out = append(out, "MC68HC08,")
  goto s0
f119:
  // >18	leshort		72		MC68HC05,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x48)) { goto f120 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t72\t\tMC68HC05,")
  out = append(out, "MC68HC05,")
  goto s0
f120:
  // >18	leshort		73		SGI SVx or Cray NV1,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x49)) { goto f121 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t73\t\tSGI SVx or Cray NV1,")
  out = append(out, "SGI SVx or Cray NV1,")
  goto s0
f121:
  // >18	leshort		74		ST19 8 bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4a)) { goto f122 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t74\t\tST19 8 bit,")
  out = append(out, "ST19 8 bit,")
  goto s0
f122:
  // >18	leshort		75		Digital VAX,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4b)) { goto f123 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t75\t\tDigital VAX,")
  out = append(out, "Digital VAX,")
  goto s0
f123:
  // >18	leshort		76		Axis cris,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4c)) { goto f124 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t76\t\tAxis cris,")
  out = append(out, "Axis cris,")
  goto s0
f124:
  // >18	leshort		77		Infineon 32-bit embedded,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4d)) { goto f125 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t77\t\tInfineon 32-bit embedded,")
  out = append(out, "Infineon 32-bit embedded,")
  goto s0
f125:
  // >18	leshort		78		Element 14 64-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4e)) { goto f126 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t78\t\tElement 14 64-bit DSP,")
  out = append(out, "Element 14 64-bit DSP,")
  goto s0
f126:
  // >18	leshort		79		LSI Logic 16-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4f)) { goto f127 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t79\t\tLSI Logic 16-bit DSP,")
  out = append(out, "LSI Logic 16-bit DSP,")
  goto s0
f127:
  // >18	leshort		80		MMIX,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x50)) { goto f128 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t80\t\tMMIX,")
  out = append(out, "MMIX,")
  goto s0
f128:
  // >18	leshort		81		Harvard machine-independent,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x51)) { goto f129 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t81\t\tHarvard machine-independent,")
  out = append(out, "Harvard machine-independent,")
  goto s0
f129:
  // >18	leshort		82		SiTera Prism,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x52)) { goto f130 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t82\t\tSiTera Prism,")
  out = append(out, "SiTera Prism,")
  goto s0
f130:
  // >18	leshort		83		Atmel AVR 8-bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x53)) { goto f131 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t83\t\tAtmel AVR 8-bit,")
  out = append(out, "Atmel AVR 8-bit,")
  goto s0
f131:
  // >18	leshort		84		Fujitsu FR30,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x54)) { goto f132 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t84\t\tFujitsu FR30,")
  out = append(out, "Fujitsu FR30,")
  goto s0
f132:
  // >18	leshort		85		Mitsubishi D10V,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x55)) { goto f133 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t85\t\tMitsubishi D10V,")
  out = append(out, "Mitsubishi D10V,")
  goto s0
f133:
  // >18	leshort		86		Mitsubishi D30V,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x56)) { goto f134 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t86\t\tMitsubishi D30V,")
  out = append(out, "Mitsubishi D30V,")
  goto s0
f134:
  // >18	leshort		87		NEC v850,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x57)) { goto f135 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t87\t\tNEC v850,")
  out = append(out, "NEC v850,")
  goto s0
f135:
  // >18	leshort		88		Renesas M32R,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x58)) { goto f136 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t88\t\tRenesas M32R,")
  out = append(out, "Renesas M32R,")
  goto s0
f136:
  // >18	leshort		89		Matsushita MN10300,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x59)) { goto f137 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t89\t\tMatsushita MN10300,")
  out = append(out, "Matsushita MN10300,")
  goto s0
f137:
  // >18	leshort		90		Matsushita MN10200,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5a)) { goto f138 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t90\t\tMatsushita MN10200,")
  out = append(out, "Matsushita MN10200,")
  goto s0
f138:
  // >18	leshort		91		picoJava,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5b)) { goto f139 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t91\t\tpicoJava,")
  out = append(out, "picoJava,")
  goto s0
f139:
  // >18	leshort		92		OpenRISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5c)) { goto f140 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t92\t\tOpenRISC,")
  out = append(out, "OpenRISC,")
  goto s0
f140:
  // >18	leshort		93		ARC Cores Tangent-A5,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5d)) { goto f141 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t93\t\tARC Cores Tangent-A5,")
  out = append(out, "ARC Cores Tangent-A5,")
  goto s0
f141:
  // >18	leshort		94		Tensilica Xtensa,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5e)) { goto f142 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t94\t\tTensilica Xtensa,")
  out = append(out, "Tensilica Xtensa,")
  goto s0
f142:
  // >18	leshort		95		Alphamosaic VideoCore,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5f)) { goto f143 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t95\t\tAlphamosaic VideoCore,")
  out = append(out, "Alphamosaic VideoCore,")
  goto s0
f143:
  // >18	leshort		96		Thompson Multimedia,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x60)) { goto f144 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t96\t\tThompson Multimedia,")
  out = append(out, "Thompson Multimedia,")
  goto s0
f144:
  // >18	leshort		97		NatSemi 32k,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x61)) { goto f145 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t97\t\tNatSemi 32k,")
  out = append(out, "NatSemi 32k,")
  goto s0
f145:
  // >18	leshort		98		Tenor Network TPC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x62)) { goto f146 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t98\t\tTenor Network TPC,")
  out = append(out, "Tenor Network TPC,")
  goto s0
f146:
  // >18	leshort		99		Trebia SNP 1000,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x63)) { goto f147 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t99\t\tTrebia SNP 1000,")
  out = append(out, "Trebia SNP 1000,")
  goto s0
f147:
  // >18	leshort		100		STMicroelectronics ST200,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x64)) { goto f148 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t100\t\tSTMicroelectronics ST200,")
  out = append(out, "STMicroelectronics ST200,")
  goto s0
f148:
  // >18	leshort		101		Ubicom IP2022,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x65)) { goto f149 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t101\t\tUbicom IP2022,")
  out = append(out, "Ubicom IP2022,")
  goto s0
f149:
  // >18	leshort		102		MAX Processor,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x66)) { goto f150 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t102\t\tMAX Processor,")
  out = append(out, "MAX Processor,")
  goto s0
f150:
  // >18	leshort		103		NatSemi CompactRISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x67)) { goto f151 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t103\t\tNatSemi CompactRISC,")
  out = append(out, "NatSemi CompactRISC,")
  goto s0
f151:
  // >18	leshort		104		Fujitsu F2MC16,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x68)) { goto f152 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t104\t\tFujitsu F2MC16,")
  out = append(out, "Fujitsu F2MC16,")
  goto s0
f152:
  // >18	leshort		105		TI msp430,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x69)) { goto f153 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t105\t\tTI msp430,")
  out = append(out, "TI msp430,")
  goto s0
f153:
  // >18	leshort		106		Analog Devices Blackfin,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6a)) { goto f154 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t106\t\tAnalog Devices Blackfin,")
  out = append(out, "Analog Devices Blackfin,")
  goto s0
f154:
  // >18	leshort		107		S1C33 Family of Seiko Epson,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6b)) { goto f155 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t107\t\tS1C33 Family of Seiko Epson,")
  out = append(out, "S1C33 Family of Seiko Epson,")
  goto s0
f155:
  // >18	leshort		108		Sharp embedded,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6c)) { goto f156 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t108\t\tSharp embedded,")
  out = append(out, "Sharp embedded,")
  goto s0
f156:
  // >18	leshort		109		Arca RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6d)) { goto f157 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t109\t\tArca RISC,")
  out = append(out, "Arca RISC,")
  goto s0
f157:
  // >18	leshort		110		PKU-Unity Ltd.,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6e)) { goto f158 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t110\t\tPKU-Unity Ltd.,")
  out = append(out, "PKU-Unity Ltd.,")
  goto s0
f158:
  // >18	leshort		111		eXcess: 16/32/64-bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x6f)) { goto f159 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t111\t\teXcess: 16/32/64-bit,")
  out = append(out, "eXcess: 16/32/64-bit,")
  goto s0
f159:
  // >18	leshort		112		Icera Deep Execution Processor,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x70)) { goto f160 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t112\t\tIcera Deep Execution Processor,")
  out = append(out, "Icera Deep Execution Processor,")
  goto s0
f160:
  // >18	leshort		113		Altera Nios II,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x71)) { goto f161 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t113\t\tAltera Nios II,")
  out = append(out, "Altera Nios II,")
  goto s0
f161:
  // >18	leshort		114		NatSemi CRX,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x72)) { goto f162 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t114\t\tNatSemi CRX,")
  out = append(out, "NatSemi CRX,")
  goto s0
f162:
  // >18	leshort		115		Motorola XGATE,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x73)) { goto f163 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t115\t\tMotorola XGATE,")
  out = append(out, "Motorola XGATE,")
  goto s0
f163:
  // >18	leshort		116		Infineon C16x/XC16x,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x74)) { goto f164 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t116\t\tInfineon C16x/XC16x,")
  out = append(out, "Infineon C16x/XC16x,")
  goto s0
f164:
  // >18	leshort		117		Renesas M16C series,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x75)) { goto f165 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t117\t\tRenesas M16C series,")
  out = append(out, "Renesas M16C series,")
  goto s0
f165:
  // >18	leshort		118		Microchip dsPIC30F,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x76)) { goto f166 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t118\t\tMicrochip dsPIC30F,")
  out = append(out, "Microchip dsPIC30F,")
  goto s0
f166:
  // >18	leshort		119		Freescale RISC core,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x77)) { goto f167 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t119\t\tFreescale RISC core,")
  out = append(out, "Freescale RISC core,")
  goto s0
f167:
  // >18	leshort		120		Renesas M32C series,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x78)) { goto f168 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t120\t\tRenesas M32C series,")
  out = append(out, "Renesas M32C series,")
  goto s0
f168:
  // >18	leshort		131		Altium TSK3000 core,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x83)) { goto f169 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t131\t\tAltium TSK3000 core,")
  out = append(out, "Altium TSK3000 core,")
  goto s0
f169:
  // >18	leshort		132		Freescale RS08,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x84)) { goto f170 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t132\t\tFreescale RS08,")
  out = append(out, "Freescale RS08,")
  goto s0
f170:
  // >18	leshort		134		Cyan Technology eCOG2,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x86)) { goto f171 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t134\t\tCyan Technology eCOG2,")
  out = append(out, "Cyan Technology eCOG2,")
  goto s0
f171:
  // >18	leshort		135		Sunplus S+core7 RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x87)) { goto f172 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t135\t\tSunplus S+core7 RISC,")
  out = append(out, "Sunplus S+core7 RISC,")
  goto s0
f172:
  // >18	leshort		136		New Japan Radio (NJR) 24-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x88)) { goto f173 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t136\t\tNew Japan Radio (NJR) 24-bit DSP,")
  out = append(out, "New Japan Radio (NJR) 24-bit DSP,")
  goto s0
f173:
  // >18	leshort		137		Broadcom VideoCore III,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x89)) { goto f174 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t137\t\tBroadcom VideoCore III,")
  out = append(out, "Broadcom VideoCore III,")
  goto s0
f174:
  // >18	leshort		138		LatticeMico32,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8a)) { goto f175 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t138\t\tLatticeMico32,")
  out = append(out, "LatticeMico32,")
  goto s0
f175:
  // >18	leshort		139		Seiko Epson C17 family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8b)) { goto f176 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t139\t\tSeiko Epson C17 family,")
  out = append(out, "Seiko Epson C17 family,")
  goto s0
f176:
  // >18	leshort		140		TI TMS320C6000 DSP family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8c)) { goto f177 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t140\t\tTI TMS320C6000 DSP family,")
  out = append(out, "TI TMS320C6000 DSP family,")
  goto s0
f177:
  // >18	leshort		141		TI TMS320C2000 DSP family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8d)) { goto f178 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t141\t\tTI TMS320C2000 DSP family,")
  out = append(out, "TI TMS320C2000 DSP family,")
  goto s0
f178:
  // >18	leshort		142		TI TMS320C55x DSP family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8e)) { goto f179 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t142\t\tTI TMS320C55x DSP family,")
  out = append(out, "TI TMS320C55x DSP family,")
  goto s0
f179:
  // >18	leshort		160		STMicroelectronics 64bit VLIW DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa0)) { goto f180 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t160\t\tSTMicroelectronics 64bit VLIW DSP,")
  out = append(out, "STMicroelectronics 64bit VLIW DSP,")
  goto s0
f180:
  // >18	leshort		161		Cypress M8C,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa1)) { goto f181 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t161\t\tCypress M8C,")
  out = append(out, "Cypress M8C,")
  goto s0
f181:
  // >18	leshort		162		Renesas R32C series,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa2)) { goto f182 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t162\t\tRenesas R32C series,")
  out = append(out, "Renesas R32C series,")
  goto s0
f182:
  // >18	leshort		163		NXP TriMedia family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa3)) { goto f183 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t163\t\tNXP TriMedia family,")
  out = append(out, "NXP TriMedia family,")
  goto s0
f183:
  // >18	leshort		164		QUALCOMM DSP6,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa4)) { goto f184 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t164\t\tQUALCOMM DSP6,")
  out = append(out, "QUALCOMM DSP6,")
  goto s0
f184:
  // >18	leshort		165		Intel 8051 and variants,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa5)) { goto f185 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t165\t\tIntel 8051 and variants,")
  out = append(out, "Intel 8051 and variants,")
  goto s0
f185:
  // >18	leshort		166		STMicroelectronics STxP7x family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa6)) { goto f186 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t166\t\tSTMicroelectronics STxP7x family,")
  out = append(out, "STMicroelectronics STxP7x family,")
  goto s0
f186:
  // >18	leshort		167		Andes embedded RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa7)) { goto f187 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t167\t\tAndes embedded RISC,")
  out = append(out, "Andes embedded RISC,")
  goto s0
f187:
  // >18	leshort		168		Cyan eCOG1X family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa8)) { goto f188 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t168\t\tCyan eCOG1X family,")
  out = append(out, "Cyan eCOG1X family,")
  goto s0
f188:
  // >18	leshort		169		Dallas MAXQ30,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa9)) { goto f189 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t169\t\tDallas MAXQ30,")
  out = append(out, "Dallas MAXQ30,")
  goto s0
f189:
  // >18	leshort		170		New Japan Radio (NJR) 16-bit DSP,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xaa)) { goto f190 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t170\t\tNew Japan Radio (NJR) 16-bit DSP,")
  out = append(out, "New Japan Radio (NJR) 16-bit DSP,")
  goto s0
f190:
  // >18	leshort		171		M2000 Reconfigurable RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xab)) { goto f191 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t171\t\tM2000 Reconfigurable RISC,")
  out = append(out, "M2000 Reconfigurable RISC,")
  goto s0
f191:
  // >18	leshort		172		Cray NV2 vector architecture,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xac)) { goto f192 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t172\t\tCray NV2 vector architecture,")
  out = append(out, "Cray NV2 vector architecture,")
  goto s0
f192:
  // >18	leshort		173		Renesas RX family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xad)) { goto f193 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t173\t\tRenesas RX family,")
  out = append(out, "Renesas RX family,")
  goto s0
f193:
  // >18	leshort		174		META,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xae)) { goto f194 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t174\t\tMETA,")
  out = append(out, "META,")
  goto s0
f194:
  // >18	leshort		175		MCST Elbrus,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xaf)) { goto f195 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t175\t\tMCST Elbrus,")
  out = append(out, "MCST Elbrus,")
  goto s0
f195:
  // >18	leshort		176		Cyan Technology eCOG16 family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb0)) { goto f196 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t176\t\tCyan Technology eCOG16 family,")
  out = append(out, "Cyan Technology eCOG16 family,")
  goto s0
f196:
  // >18	leshort		177		NatSemi CompactRISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb1)) { goto f197 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t177\t\tNatSemi CompactRISC,")
  out = append(out, "NatSemi CompactRISC,")
  goto s0
f197:
  // >18	leshort		178		Freescale Extended Time Processing Unit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb2)) { goto f198 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t178\t\tFreescale Extended Time Processing Unit,")
  out = append(out, "Freescale Extended Time Processing Unit,")
  goto s0
f198:
  // >18	leshort		179		Infineon SLE9X,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb3)) { goto f199 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t179\t\tInfineon SLE9X,")
  out = append(out, "Infineon SLE9X,")
  goto s0
f199:
  // >18	leshort		180		Intel L1OM,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb4)) { goto f200 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t180\t\tIntel L1OM,")
  out = append(out, "Intel L1OM,")
  goto s0
f200:
  // >18	leshort		181		Intel K1OM,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb5)) { goto f201 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t181\t\tIntel K1OM,")
  out = append(out, "Intel K1OM,")
  goto s0
f201:
  // >18	leshort		183		ARM aarch64,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb7)) { goto f202 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t183\t\tARM aarch64,")
  out = append(out, "ARM aarch64,")
  goto s0
f202:
  // >18	leshort		185		Atmel 32-bit family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xb9)) { goto f203 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t185\t\tAtmel 32-bit family,")
  out = append(out, "Atmel 32-bit family,")
  goto s0
f203:
  // >18	leshort		186		STMicroeletronics STM8 8-bit,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xba)) { goto f204 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t186\t\tSTMicroeletronics STM8 8-bit,")
  out = append(out, "STMicroeletronics STM8 8-bit,")
  goto s0
f204:
  // >18	leshort		187		Tilera TILE64,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbb)) { goto f205 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t187\t\tTilera TILE64,")
  out = append(out, "Tilera TILE64,")
  goto s0
f205:
  // >18	leshort		188		Tilera TILEPro,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbc)) { goto f206 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t188\t\tTilera TILEPro,")
  out = append(out, "Tilera TILEPro,")
  goto s0
f206:
  // >18	leshort		189		Xilinx MicroBlaze 32-bit RISC,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbd)) { goto f207 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t189\t\tXilinx MicroBlaze 32-bit RISC,")
  out = append(out, "Xilinx MicroBlaze 32-bit RISC,")
  goto s0
f207:
  // >18	leshort		190		NVIDIA CUDA architecture,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbe)) { goto f208 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t190\t\tNVIDIA CUDA architecture,")
  out = append(out, "NVIDIA CUDA architecture,")
  goto s0
f208:
  // >18	leshort		191		Tilera TILE-Gx,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbf)) { goto f209 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t191\t\tTilera TILE-Gx,")
  out = append(out, "Tilera TILE-Gx,")
  goto s0
f209:
  // >18	leshort		197		Renesas RL78 family,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xc5)) { goto f210 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t197\t\tRenesas RL78 family,")
  out = append(out, "Renesas RL78 family,")
  goto s0
f210:
  // >18	leshort		199		Renesas 78K0R,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xc7)) { goto f211 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t199\t\tRenesas 78K0R,")
  out = append(out, "Renesas 78K0R,")
  goto s0
f211:
  // >18	leshort		0x1057		AVR (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1057)) { goto f212 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x1057\t\tAVR (unofficial),")
  out = append(out, "AVR (unofficial),")
  goto s0
f212:
  // >18	leshort		0x1059		MSP430 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1059)) { goto f213 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x1059\t\tMSP430 (unofficial),")
  out = append(out, "MSP430 (unofficial),")
  goto s0
f213:
  // >18	leshort		0x1223		Adapteva Epiphany (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1223)) { goto f214 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x1223\t\tAdapteva Epiphany (unofficial),")
  out = append(out, "Adapteva Epiphany (unofficial),")
  goto s0
f214:
  // >18	leshort		0x2530		Morpho MT (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x2530)) { goto f215 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x2530\t\tMorpho MT (unofficial),")
  out = append(out, "Morpho MT (unofficial),")
  goto s0
f215:
  // >18	leshort		0x3330		FR30 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3330)) { goto f216 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x3330\t\tFR30 (unofficial),")
  out = append(out, "FR30 (unofficial),")
  goto s0
f216:
  // >18	leshort		0x3426		OpenRISC (obsolete),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x3426)) { goto f217 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x3426\t\tOpenRISC (obsolete),")
  out = append(out, "OpenRISC (obsolete),")
  goto s0
f217:
  // >18	leshort		0x4688		Infineon C166 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x4688)) { goto f218 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x4688\t\tInfineon C166 (unofficial),")
  out = append(out, "Infineon C166 (unofficial),")
  goto s0
f218:
  // >18	leshort		0x5441		Cygnus FRV (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5441)) { goto f219 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x5441\t\tCygnus FRV (unofficial),")
  out = append(out, "Cygnus FRV (unofficial),")
  goto s0
f219:
  // >18	leshort		0x5aa5		DLX (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x5aa5)) { goto f220 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x5aa5\t\tDLX (unofficial),")
  out = append(out, "DLX (unofficial),")
  goto s0
f220:
  // >18	leshort		0x7650		Cygnus D10V (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x7650)) { goto f221 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x7650\t\tCygnus D10V (unofficial),")
  out = append(out, "Cygnus D10V (unofficial),")
  goto s0
f221:
  // >18	leshort		0x7676		Cygnus D30V (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x7676)) { goto f222 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x7676\t\tCygnus D30V (unofficial),")
  out = append(out, "Cygnus D30V (unofficial),")
  goto s0
f222:
  // >18	leshort		0x8217		Ubicom IP2xxx (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8217)) { goto f223 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x8217\t\tUbicom IP2xxx (unofficial),")
  out = append(out, "Ubicom IP2xxx (unofficial),")
  goto s0
f223:
  // >18	leshort		0x8472		OpenRISC (obsolete),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x8472)) { goto f224 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x8472\t\tOpenRISC (obsolete),")
  out = append(out, "OpenRISC (obsolete),")
  goto s0
f224:
  // >18	leshort		0x9025		Cygnus PowerPC (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x9025)) { goto f225 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9025\t\tCygnus PowerPC (unofficial),")
  out = append(out, "Cygnus PowerPC (unofficial),")
  goto s0
f225:
  // >18	leshort		0x9026		Alpha (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x9026)) { goto f226 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9026\t\tAlpha (unofficial),")
  out = append(out, "Alpha (unofficial),")
  goto s0
f226:
  // >18	leshort		0x9041		Cygnus M32R (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x9041)) { goto f227 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9041\t\tCygnus M32R (unofficial),")
  out = append(out, "Cygnus M32R (unofficial),")
  goto s0
f227:
  // >18	leshort		0x9080		Cygnus V850 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x9080)) { goto f228 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0x9080\t\tCygnus V850 (unofficial),")
  out = append(out, "Cygnus V850 (unofficial),")
  goto s0
f228:
  // >18	leshort		0xa390		IBM S/390 (obsolete),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xa390)) { goto f229 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xa390\t\tIBM S/390 (obsolete),")
  out = append(out, "IBM S/390 (obsolete),")
  goto s0
f229:
  // >18	leshort		0xabc7		Old Xtensa (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xabc7)) { goto f230 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xabc7\t\tOld Xtensa (unofficial),")
  out = append(out, "Old Xtensa (unofficial),")
  goto s0
f230:
  // >18	leshort		0xad45		xstormy16 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xad45)) { goto f231 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xad45\t\txstormy16 (unofficial),")
  out = append(out, "xstormy16 (unofficial),")
  goto s0
f231:
  // >18	leshort		0xbaab		Old MicroBlaze (unofficial),,
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbaab)) { goto f232 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xbaab\t\tOld MicroBlaze (unofficial),,")
  out = append(out, "Old MicroBlaze (unofficial),,")
  goto s0
f232:
  // >18	leshort		0xbeef		Cygnus MN10300 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xbeef)) { goto f233 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xbeef\t\tCygnus MN10300 (unofficial),")
  out = append(out, "Cygnus MN10300 (unofficial),")
  goto s0
f233:
  // >18	leshort		0xdead		Cygnus MN10200 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xdead)) { goto f234 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xdead\t\tCygnus MN10200 (unofficial),")
  out = append(out, "Cygnus MN10200 (unofficial),")
  goto s0
f234:
  // >18	leshort		0xf00d		Toshiba MeP (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xf00d)) { goto f235 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xf00d\t\tToshiba MeP (unofficial),")
  out = append(out, "Toshiba MeP (unofficial),")
  goto s0
f235:
  // >18	leshort		0xfeb0		Renesas M32C (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xfeb0)) { goto f236 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfeb0\t\tRenesas M32C (unofficial),")
  out = append(out, "Renesas M32C (unofficial),")
  goto s0
f236:
  // >18	leshort		0xfeba		Vitesse IQ2000 (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xfeba)) { goto f237 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfeba\t\tVitesse IQ2000 (unofficial),")
  out = append(out, "Vitesse IQ2000 (unofficial),")
  goto s0
f237:
  // >18	leshort		0xfebb		NIOS (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xfebb)) { goto f238 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfebb\t\tNIOS (unofficial),")
  out = append(out, "NIOS (unofficial),")
  goto s0
f238:
  // >18	leshort		0xfeed		Moxie (unofficial),
  off = pageOff + 0x12
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xfeed)) { goto f239 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">18\tleshort\t\t0xfeed\t\tMoxie (unofficial),")
  out = append(out, "Moxie (unofficial),")
  goto s0
f239:
  // >18	default		x
  off = pageOff + 0x12
  // uh oh unhandled kind default
  goto f240
  fmt.Printf("matched rule: %s\n", ">18\tdefault\t\tx")
  // >>18	leshort		x		*unknown arch 0x%x*
  off = pageOff + 0x12
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>18\tleshort\t\tx\t\t*unknown arch 0x%x*")
  out = append(out, "*unknown arch 0x%x*")
  goto s240
s240:
  goto s0
f240:
  // >20	lelong		0		invalid version
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f242 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t0\t\tinvalid version")
  out = append(out, "invalid version")
  goto s0
f242:
  // >20	lelong		1		version 1
  off = pageOff + 0x14
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f243 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">20\tlelong\t\t1\t\tversion 1")
  out = append(out, "version 1")
  goto s0
f243:
s0:
  goto end
end:
  return out, nil
}

func IdentifyIcoEntry(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		ico-entry
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tico-entry")
  // >0			use	cur-ico-entry
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\t\t\tuse\tcur-ico-entry")
  goto s0
  // >4	uleshort	>1	\b, %d planes
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f2 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort\t>1\t\\b, %d planes")
  out = append(out, "\\b, %d planes")
  goto s0
f2:
  // >6	uleshort	>1	\b, %d bits/pixel
  off = pageOff + 0x6
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">6\tuleshort\t>1\t\\b, %d bits/pixel")
  out = append(out, "\\b, %d bits/pixel")
  goto s0
f3:
s0:
  goto end
end:
  return out, nil
}

func IdentifyIcoEntry__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		ico-entry
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tico-entry")
  // >0			use	cur-ico-entry
  off = pageOff + 0x0
  {
    ss, _ := IdentifyCurIcoEntry(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\t\t\tuse\tcur-ico-entry")
  goto s0
  // >4	uleshort	>1	\b, %d planes
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f2 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort\t>1\t\\b, %d planes")
  out = append(out, "\\b, %d planes")
  goto s0
f2:
  // >6	uleshort	>1	\b, %d bits/pixel
  off = pageOff + 0x6
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x1)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">6\tuleshort\t>1\t\\b, %d bits/pixel")
  out = append(out, "\\b, %d bits/pixel")
  goto s0
f3:
s0:
  goto end
end:
  return out, nil
}

func IdentifyLotusCells(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		lotus-cells
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tlotus-cells")
  // >0	ubelong	0x06000800	\b, cell range
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x6000800)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tubelong\t0x06000800\t\\b, cell range")
  out = append(out, "\\b, cell range")
  // >>4	ulong		!0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f2 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tulong\t\t!0")
  // >>>4	uleshort	x	\b%d,
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s2
  // >>>6	uleshort	x	\b%d-
  off = pageOff + 0x6
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>6\tuleshort\tx\t\\b%d-")
  out = append(out, "\\b%d-")
  goto s2
s2:
  goto s1
f2:
  // >>8	uleshort	x	\b%d,
  off = pageOff + 0x8
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>8\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s1
  // >>10	uleshort	x	\b%d
  off = pageOff + 0xa
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>10\tuleshort\tx\t\\b%d")
  out = append(out, "\\b%d")
  goto s1
s1:
  goto s0
f1:
s0:
  goto end
end:
  return out, nil
}

func IdentifyLotusCells__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		lotus-cells
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tlotus-cells")
  // >0	ubelong	0x06000800	\b, cell range
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x6000800)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tubelong\t0x06000800\t\\b, cell range")
  out = append(out, "\\b, cell range")
  // >>4	ulong		!0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) != 0x0)) { goto f2 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>4\tulong\t\t!0")
  // >>>4	uleshort	x	\b%d,
  off = pageOff + 0x4
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s2
  // >>>6	uleshort	x	\b%d-
  off = pageOff + 0x6
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>6\tuleshort\tx\t\\b%d-")
  out = append(out, "\\b%d-")
  goto s2
s2:
  goto s1
f2:
  // >>8	uleshort	x	\b%d,
  off = pageOff + 0x8
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>8\tuleshort\tx\t\\b%d,")
  out = append(out, "\\b%d,")
  goto s1
  // >>10	uleshort	x	\b%d
  off = pageOff + 0xa
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>10\tuleshort\tx\t\\b%d")
  out = append(out, "\\b%d")
  goto s1
s1:
  goto s0
f1:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMachO(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		mach-o		\b [
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o\t\t\\b [")
  out = append(out, "\\b [")
  // >0	use		mach-o-cpu	\b
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMachOCpu(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\tmach-o-cpu\t\\b")
  out = append(out, "\\b")
  goto s0
  // >0	belong		x		\b]
  off = pageOff + 0x0
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tbelong\t\tx\t\t\\b]")
  out = append(out, "\\b]")
  goto s0
s0:
  goto end
end:
  return out, nil
}

func IdentifyMachO__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		mach-o		\b [
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o\t\t\\b [")
  out = append(out, "\\b [")
  // >0	use		mach-o-cpu	\b
  off = pageOff + 0x0
  {
    ss, _ := IdentifyMachOCpu(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">0\tuse\t\tmach-o-cpu\t\\b")
  out = append(out, "\\b")
  goto s0
  // >0	belong		x		\b]
  off = pageOff + 0x0
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tbelong\t\tx\t\t\\b]")
  out = append(out, "\\b]")
  goto s0
s0:
  goto end
end:
  return out, nil
}

func IdentifyMachOBe(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		mach-o-be
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o-be")
  // >0	byte		0xcf		64-bit
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xcf)) { goto f1 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tbyte\t\t0xcf\t\t64-bit")
  out = append(out, "64-bit")
  goto s0
f1:
  // >4	use		mach-o-cpu
  off = pageOff + 0x4
  {
    ss, _ := IdentifyMachOCpu(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">4\tuse\t\tmach-o-cpu")
  goto s0
  // >12	belong		1		object
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f3 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t1\t\tobject")
  out = append(out, "object")
  goto s0
f3:
  // >12	belong		2		executable
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f4 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t2\t\texecutable")
  out = append(out, "executable")
  goto s0
f4:
  // >12	belong		3		fixed virtual memory shared library
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f5 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t3\t\tfixed virtual memory shared library")
  out = append(out, "fixed virtual memory shared library")
  goto s0
f5:
  // >12	belong		4		core
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t4\t\tcore")
  out = append(out, "core")
  goto s0
f6:
  // >12	belong		5		preload executable
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t5\t\tpreload executable")
  out = append(out, "preload executable")
  goto s0
f7:
  // >12	belong		6		dynamically linked shared library
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f8 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t6\t\tdynamically linked shared library")
  out = append(out, "dynamically linked shared library")
  goto s0
f8:
  // >12	belong		7		dynamic linker
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t7\t\tdynamic linker")
  out = append(out, "dynamic linker")
  goto s0
f9:
  // >12	belong		8		bundle
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f10 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t8\t\tbundle")
  out = append(out, "bundle")
  goto s0
f10:
  // >12	belong		9		dynamically linked shared library stub
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f11 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t9\t\tdynamically linked shared library stub")
  out = append(out, "dynamically linked shared library stub")
  goto s0
f11:
  // >12	belong		10		dSYM companion file
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f12 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t10\t\tdSYM companion file")
  out = append(out, "dSYM companion file")
  goto s0
f12:
  // >12	belong		11		kext bundle
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f13 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t11\t\tkext bundle")
  out = append(out, "kext bundle")
  goto s0
f13:
  // >12	belong		>11
  off = pageOff + 0xc
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv)) > 0xb)) { goto f14 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t>11")
  // >>12	belong		x		filetype=%ld
  off = pageOff + 0xc
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>12\tbelong\t\tx\t\tfiletype=%ld")
  out = append(out, "filetype=%ld")
  goto s14
s14:
  goto s0
f14:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMachOBe__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name		mach-o-be
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o-be")
  // >0	byte		0xcf		64-bit
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xcf)) { goto f1 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tbyte\t\t0xcf\t\t64-bit")
  out = append(out, "64-bit")
  goto s0
f1:
  // >4	use		mach-o-cpu
  off = pageOff + 0x4
  {
    ss, _ := IdentifyMachOCpu(tb, off)
    out = append(out, ss...)
  }
  fmt.Printf("matched rule: %s\n", ">4\tuse\t\tmach-o-cpu")
  goto s0
  // >12	belong		1		object
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f3 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t1\t\tobject")
  out = append(out, "object")
  goto s0
f3:
  // >12	belong		2		executable
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x2)) { goto f4 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t2\t\texecutable")
  out = append(out, "executable")
  goto s0
f4:
  // >12	belong		3		fixed virtual memory shared library
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x3)) { goto f5 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t3\t\tfixed virtual memory shared library")
  out = append(out, "fixed virtual memory shared library")
  goto s0
f5:
  // >12	belong		4		core
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t4\t\tcore")
  out = append(out, "core")
  goto s0
f6:
  // >12	belong		5		preload executable
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t5\t\tpreload executable")
  out = append(out, "preload executable")
  goto s0
f7:
  // >12	belong		6		dynamically linked shared library
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x6)) { goto f8 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t6\t\tdynamically linked shared library")
  out = append(out, "dynamically linked shared library")
  goto s0
f8:
  // >12	belong		7		dynamic linker
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x7)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t7\t\tdynamic linker")
  out = append(out, "dynamic linker")
  goto s0
f9:
  // >12	belong		8		bundle
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x8)) { goto f10 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t8\t\tbundle")
  out = append(out, "bundle")
  goto s0
f10:
  // >12	belong		9		dynamically linked shared library stub
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x9)) { goto f11 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t9\t\tdynamically linked shared library stub")
  out = append(out, "dynamically linked shared library stub")
  goto s0
f11:
  // >12	belong		10		dSYM companion file
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xa)) { goto f12 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t10\t\tdSYM companion file")
  out = append(out, "dSYM companion file")
  goto s0
f12:
  // >12	belong		11		kext bundle
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xb)) { goto f13 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t11\t\tkext bundle")
  out = append(out, "kext bundle")
  goto s0
f13:
  // >12	belong		>11
  off = pageOff + 0xc
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv)) > 0xb)) { goto f14 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">12\tbelong\t\t>11")
  // >>12	belong		x		filetype=%ld
  off = pageOff + 0xc
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>12\tbelong\t\tx\t\tfiletype=%ld")
  out = append(out, "filetype=%ld")
  goto s14
s14:
  goto s0
f14:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMachOCpu(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name	mach-o-cpu
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\tmach-o-cpu")
  // >0	belong&0x01000000	0
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x1000000 == 0x0)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tbelong&0x01000000\t0")
  // >>0	belong&0x00ffffff	1
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f2 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t1")
  // >>>4		belong&0x00ffffff	0	vax
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f3 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\tvax")
  out = append(out, "vax")
  goto s2
f3:
  // >>>4		belong&0x00ffffff	1	vax11/780
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f4 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tvax11/780")
  out = append(out, "vax11/780")
  goto s2
f4:
  // >>>4		belong&0x00ffffff	2	vax11/785
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f5 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tvax11/785")
  out = append(out, "vax11/785")
  goto s2
f5:
  // >>>4		belong&0x00ffffff	3	vax11/750
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\tvax11/750")
  out = append(out, "vax11/750")
  goto s2
f6:
  // >>>4		belong&0x00ffffff	4	vax11/730
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\tvax11/730")
  out = append(out, "vax11/730")
  goto s2
f7:
  // >>>4		belong&0x00ffffff	5	uvaxI
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f8 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\tuvaxI")
  out = append(out, "uvaxI")
  goto s2
f8:
  // >>>4		belong&0x00ffffff	6	uvaxII
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\tuvaxII")
  out = append(out, "uvaxII")
  goto s2
f9:
  // >>>4		belong&0x00ffffff	7	vax8200
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f10 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\tvax8200")
  out = append(out, "vax8200")
  goto s2
f10:
  // >>>4		belong&0x00ffffff	8	vax8500
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f11 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\tvax8500")
  out = append(out, "vax8500")
  goto s2
f11:
  // >>>4		belong&0x00ffffff	9	vax8600
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f12 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\tvax8600")
  out = append(out, "vax8600")
  goto s2
f12:
  // >>>4		belong&0x00ffffff	10	vax8650
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f13 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\tvax8650")
  out = append(out, "vax8650")
  goto s2
f13:
  // >>>4		belong&0x00ffffff	11	vax8800
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f14 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\tvax8800")
  out = append(out, "vax8800")
  goto s2
f14:
  // >>>4		belong&0x00ffffff	12	uvaxIII
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f15 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t12\tuvaxIII")
  out = append(out, "uvaxIII")
  goto s2
f15:
  // >>>4		belong&0x00ffffff	>12	vax subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0xc)) { goto f16 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>12\tvax subarchitecture=%ld")
  out = append(out, "vax subarchitecture=%ld")
  goto s2
f16:
s2:
  goto s1
f2:
  // >>0	belong&0x00ffffff	2	romp
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f17 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t2\tromp")
  out = append(out, "romp")
  goto s1
f17:
  // >>0	belong&0x00ffffff	3	architecture=3
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f18 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t3\tarchitecture=3")
  out = append(out, "architecture=3")
  goto s1
f18:
  // >>0	belong&0x00ffffff	4	ns32032
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f19 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t4\tns32032")
  out = append(out, "ns32032")
  goto s1
f19:
  // >>0	belong&0x00ffffff	5	ns32332
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f20 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t5\tns32332")
  out = append(out, "ns32332")
  goto s1
f20:
  // >>0	belong&0x00ffffff	6	m68k
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f21 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t6\tm68k")
  out = append(out, "m68k")
  goto s1
f21:
  // >>0	belong&0x00ffffff	7
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f22 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t7")
  // >>>4	belong&0x0000000f	3		i386
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x3)) { goto f23 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t3\t\ti386")
  out = append(out, "i386")
  goto s22
f23:
  // >>>4	belong&0x0000000f	4		i486
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x4)) { goto f24 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t4\t\ti486")
  out = append(out, "i486")
  // >>>>4	belong&0x00fffff0	0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f25 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0")
  goto s24
f25:
  // >>>>4	belong&0x00fffff0	0x80		\bsx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x80)) { goto f26 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x80\t\t\\bsx")
  out = append(out, "\\bsx")
  goto s24
f26:
s24:
  goto s22
f24:
  // >>>4	belong&0x0000000f	5		i586
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x5)) { goto f27 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t5\t\ti586")
  out = append(out, "i586")
  goto s22
f27:
  // >>>4	belong&0x0000000f	6
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x6)) { goto f28 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t6")
  // >>>>4	belong&0x00fffff0	0		p6
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f29 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0\t\tp6")
  out = append(out, "p6")
  goto s28
f29:
  // >>>>4	belong&0x00fffff0	0x10		pentium_pro
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f30 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\tpentium_pro")
  out = append(out, "pentium_pro")
  goto s28
f30:
  // >>>>4	belong&0x00fffff0	0x20		pentium_2_m0x20
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x20)) { goto f31 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x20\t\tpentium_2_m0x20")
  out = append(out, "pentium_2_m0x20")
  goto s28
f31:
  // >>>>4	belong&0x00fffff0	0x30		pentium_2_m3
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x30)) { goto f32 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x30\t\tpentium_2_m3")
  out = append(out, "pentium_2_m3")
  goto s28
f32:
  // >>>>4	belong&0x00fffff0	0x40		pentium_2_m0x40
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x40)) { goto f33 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x40\t\tpentium_2_m0x40")
  out = append(out, "pentium_2_m0x40")
  goto s28
f33:
  // >>>>4	belong&0x00fffff0	0x50		pentium_2_m5
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x50)) { goto f34 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x50\t\tpentium_2_m5")
  out = append(out, "pentium_2_m5")
  goto s28
f34:
  // >>>>4	belong&0x00fffff0	>0x50		pentium_2_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x50)) { goto f35 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x50\t\tpentium_2_m0x%lx")
  out = append(out, "pentium_2_m0x%lx")
  goto s28
f35:
s28:
  goto s22
f28:
  // >>>4	belong&0x0000000f	7		celeron
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x7)) { goto f36 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t7\t\tceleron")
  out = append(out, "celeron")
  // >>>>4	belong&0x00fffff0	0x00		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f37 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f37:
  // >>>>4	belong&0x00fffff0	0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f38 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f38:
  // >>>>4	belong&0x00fffff0	0x20		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x20)) { goto f39 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x20\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f39:
  // >>>>4	belong&0x00fffff0	0x30		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x30)) { goto f40 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x30\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f40:
  // >>>>4	belong&0x00fffff0	0x40		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x40)) { goto f41 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x40\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f41:
  // >>>>4	belong&0x00fffff0	0x50		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x50)) { goto f42 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x50\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f42:
  // >>>>4	belong&0x00fffff0	0x60
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x60)) { goto f43 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x60")
  goto s36
f43:
  // >>>>4	belong&0x00fffff0	0x70		\b_mobile
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x70)) { goto f44 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x70\t\t\\b_mobile")
  out = append(out, "\\b_mobile")
  goto s36
f44:
  // >>>>4	belong&0x00fffff0	>0x70		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x70)) { goto f45 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x70\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f45:
s36:
  goto s22
f36:
  // >>>4	belong&0x0000000f	8		pentium_3
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x8)) { goto f46 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t8\t\tpentium_3")
  out = append(out, "pentium_3")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f47 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s46
f47:
  // >>>>4	belong&0x00fffff0	0x10		\b_m
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f48 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_m")
  out = append(out, "\\b_m")
  goto s46
f48:
  // >>>>4	belong&0x00fffff0	0x20		\b_xeon
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x20)) { goto f49 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x20\t\t\\b_xeon")
  out = append(out, "\\b_xeon")
  goto s46
f49:
  // >>>>4	belong&0x00fffff0	>0x20		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x20)) { goto f50 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x20\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s46
f50:
s46:
  goto s22
f46:
  // >>>4	belong&0x0000000f	9		pentiumM
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0x9)) { goto f51 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t9\t\tpentiumM")
  out = append(out, "pentiumM")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f52 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s51
f52:
  // >>>>4	belong&0x00fffff0	>0x00		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x0)) { goto f53 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x00\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s51
f53:
s51:
  goto s22
f51:
  // >>>4	belong&0x0000000f	10		pentium_4
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0xa)) { goto f54 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t10\t\tpentium_4")
  out = append(out, "pentium_4")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f55 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s54
f55:
  // >>>>4	belong&0x00fffff0	0x10		\b_m
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f56 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_m")
  out = append(out, "\\b_m")
  goto s54
f56:
  // >>>>4	belong&0x00fffff0	>0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x10)) { goto f57 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s54
f57:
s54:
  goto s22
f54:
  // >>>4	belong&0x0000000f	11		itanium
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0xb)) { goto f58 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t11\t\titanium")
  out = append(out, "itanium")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f59 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s58
f59:
  // >>>>4	belong&0x00fffff0	0x10		\b_2
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f60 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_2")
  out = append(out, "\\b_2")
  goto s58
f60:
  // >>>>4	belong&0x00fffff0	>0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x10)) { goto f61 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s58
f61:
s58:
  goto s22
f58:
  // >>>4	belong&0x0000000f	12		xeon
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xf == 0xc)) { goto f62 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t12\t\txeon")
  out = append(out, "xeon")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f63 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s62
f63:
  // >>>>4	belong&0x00fffff0	0x10		\b_mp
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f64 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_mp")
  out = append(out, "\\b_mp")
  goto s62
f64:
  // >>>>4	belong&0x00fffff0	>0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x10)) { goto f65 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s62
f65:
s62:
  goto s22
f62:
  // >>>4	belong&0x0000000f	>12		ia32 family=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xf > 0xc)) { goto f66 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t>12\t\tia32 family=%ld")
  out = append(out, "ia32 family=%ld")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f67 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s66
f67:
  // >>>>4	belong&0x00fffff0	>0x00		model=%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x0)) { goto f68 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x00\t\tmodel=%lx")
  out = append(out, "model=%lx")
  goto s66
f68:
s66:
  goto s22
f66:
s22:
  goto s1
f22:
  // >>0	belong&0x00ffffff	8	mips
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f69 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t8\tmips")
  out = append(out, "mips")
  // >>>4		belong&0x00ffffff	1	R2300
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f70 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tR2300")
  out = append(out, "R2300")
  goto s69
f70:
  // >>>4		belong&0x00ffffff	2	R2600
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f71 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tR2600")
  out = append(out, "R2600")
  goto s69
f71:
  // >>>4		belong&0x00ffffff	3	R2800
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f72 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\tR2800")
  out = append(out, "R2800")
  goto s69
f72:
  // >>>4		belong&0x00ffffff	4	R2000a
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f73 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\tR2000a")
  out = append(out, "R2000a")
  goto s69
f73:
  // >>>4		belong&0x00ffffff	5	R2000
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f74 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\tR2000")
  out = append(out, "R2000")
  goto s69
f74:
  // >>>4		belong&0x00ffffff	6	R3000a
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f75 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\tR3000a")
  out = append(out, "R3000a")
  goto s69
f75:
  // >>>4		belong&0x00ffffff	7	R3000
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f76 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\tR3000")
  out = append(out, "R3000")
  goto s69
f76:
  // >>>4		belong&0x00ffffff	>7	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x7)) { goto f77 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>7\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s69
f77:
s69:
  goto s1
f69:
  // >>0	belong&0x00ffffff	9	ns32532
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f78 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t9\tns32532")
  out = append(out, "ns32532")
  goto s1
f78:
  // >>0	belong&0x00ffffff	10	mc98000
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f79 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t10\tmc98000")
  out = append(out, "mc98000")
  goto s1
f79:
  // >>0	belong&0x00ffffff	11	hppa
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f80 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t11\thppa")
  out = append(out, "hppa")
  // >>>4		belong&0x00ffffff	0	7100
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f81 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\t7100")
  out = append(out, "7100")
  goto s80
f81:
  // >>>4		belong&0x00ffffff	1	7100LC
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f82 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\t7100LC")
  out = append(out, "7100LC")
  goto s80
f82:
  // >>>4		belong&0x00ffffff	>1	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x1)) { goto f83 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>1\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s80
f83:
s80:
  goto s1
f80:
  // >>0	belong&0x00ffffff	12	arm
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f84 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t12\tarm")
  out = append(out, "arm")
  // >>>4		belong&0x00ffffff	0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f85 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0")
  goto s84
f85:
  // >>>4		belong&0x00ffffff	1	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f86 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f86:
  // >>>4		belong&0x00ffffff	2	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f87 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f87:
  // >>>4		belong&0x00ffffff	3	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f88 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f88:
  // >>>4		belong&0x00ffffff	4	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f89 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f89:
  // >>>4		belong&0x00ffffff	5	\b_v4t
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f90 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\t\\b_v4t")
  out = append(out, "\\b_v4t")
  goto s84
f90:
  // >>>4		belong&0x00ffffff	6	\b_v6
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f91 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\t\\b_v6")
  out = append(out, "\\b_v6")
  goto s84
f91:
  // >>>4		belong&0x00ffffff	7	\b_v5tej
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f92 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\t\\b_v5tej")
  out = append(out, "\\b_v5tej")
  goto s84
f92:
  // >>>4		belong&0x00ffffff	8	\b_xscale
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f93 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\t\\b_xscale")
  out = append(out, "\\b_xscale")
  goto s84
f93:
  // >>>4		belong&0x00ffffff	9	\b_v7
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f94 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\t\\b_v7")
  out = append(out, "\\b_v7")
  goto s84
f94:
  // >>>4		belong&0x00ffffff	10	\b_v7f
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f95 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\t\\b_v7f")
  out = append(out, "\\b_v7f")
  goto s84
f95:
  // >>>4		belong&0x00ffffff	11	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f96 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f96:
  // >>>4		belong&0x00ffffff	12	\b_v7k
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f97 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t12\t\\b_v7k")
  out = append(out, "\\b_v7k")
  goto s84
f97:
  // >>>4		belong&0x00ffffff	>12	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0xc)) { goto f98 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>12\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f98:
s84:
  goto s1
f84:
  // >>0	belong&0x00ffffff	13
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xd)) { goto f99 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t13")
  // >>>4		belong&0x00ffffff	0	mc88000
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f100 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\tmc88000")
  out = append(out, "mc88000")
  goto s99
f100:
  // >>>4		belong&0x00ffffff	1	mc88100
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f101 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tmc88100")
  out = append(out, "mc88100")
  goto s99
f101:
  // >>>4		belong&0x00ffffff	2	mc88110
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f102 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tmc88110")
  out = append(out, "mc88110")
  goto s99
f102:
  // >>>4		belong&0x00ffffff	>2	mc88000 subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x2)) { goto f103 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>2\tmc88000 subarchitecture=%ld")
  out = append(out, "mc88000 subarchitecture=%ld")
  goto s99
f103:
s99:
  goto s1
f99:
  // >>0	belong&0x00ffffff	14	sparc
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xe)) { goto f104 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t14\tsparc")
  out = append(out, "sparc")
  goto s1
f104:
  // >>0	belong&0x00ffffff	15	i860g
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xf)) { goto f105 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t15\ti860g")
  out = append(out, "i860g")
  goto s1
f105:
  // >>0	belong&0x00ffffff	16	alpha
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x10)) { goto f106 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t16\talpha")
  out = append(out, "alpha")
  goto s1
f106:
  // >>0	belong&0x00ffffff	17	rs6000
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x11)) { goto f107 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t17\trs6000")
  out = append(out, "rs6000")
  goto s1
f107:
  // >>0	belong&0x00ffffff	18	ppc
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x12)) { goto f108 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t18\tppc")
  out = append(out, "ppc")
  // >>>4		belong&0x00ffffff	0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f109 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0")
  goto s108
f109:
  // >>>4		belong&0x00ffffff	1	\b_601
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f110 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\t\\b_601")
  out = append(out, "\\b_601")
  goto s108
f110:
  // >>>4		belong&0x00ffffff	2	\b_602
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f111 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\t\\b_602")
  out = append(out, "\\b_602")
  goto s108
f111:
  // >>>4		belong&0x00ffffff	3	\b_603
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f112 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\t\\b_603")
  out = append(out, "\\b_603")
  goto s108
f112:
  // >>>4		belong&0x00ffffff	4	\b_603e
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f113 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\t\\b_603e")
  out = append(out, "\\b_603e")
  goto s108
f113:
  // >>>4		belong&0x00ffffff	5	\b_603ev
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f114 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\t\\b_603ev")
  out = append(out, "\\b_603ev")
  goto s108
f114:
  // >>>4		belong&0x00ffffff	6	\b_604
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f115 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\t\\b_604")
  out = append(out, "\\b_604")
  goto s108
f115:
  // >>>4		belong&0x00ffffff	7	\b_604e
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f116 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\t\\b_604e")
  out = append(out, "\\b_604e")
  goto s108
f116:
  // >>>4		belong&0x00ffffff	8	\b_620
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f117 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\t\\b_620")
  out = append(out, "\\b_620")
  goto s108
f117:
  // >>>4		belong&0x00ffffff	9	\b_650
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f118 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\t\\b_650")
  out = append(out, "\\b_650")
  goto s108
f118:
  // >>>4		belong&0x00ffffff	10	\b_7400
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f119 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\t\\b_7400")
  out = append(out, "\\b_7400")
  goto s108
f119:
  // >>>4		belong&0x00ffffff	11	\b_7450
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f120 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\t\\b_7450")
  out = append(out, "\\b_7450")
  goto s108
f120:
  // >>>4		belong&0x00ffffff	100	\b_970
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x64)) { goto f121 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t100\t\\b_970")
  out = append(out, "\\b_970")
  goto s108
f121:
  // >>>4		belong&0x00ffffff	>100	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x64)) { goto f122 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>100\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s108
f122:
s108:
  goto s1
f108:
  // >>0	belong&0x00ffffff	>18	architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x12)) { goto f123 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t>18\tarchitecture=%ld")
  out = append(out, "architecture=%ld")
  goto s1
f123:
s1:
  goto s0
f1:
  // >0	belong&0x01000000	0x01000000
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0x1000000 == 0x1000000)) { goto f124 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tbelong&0x01000000\t0x01000000")
  // >>0	belong&0x00ffffff	0	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f125 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t0\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f125:
  // >>0	belong&0x00ffffff	1	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f126 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t1\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f126:
  // >>0	belong&0x00ffffff	2	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f127 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t2\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f127:
  // >>0	belong&0x00ffffff	3	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f128 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t3\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f128:
  // >>0	belong&0x00ffffff	4	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f129 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t4\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f129:
  // >>0	belong&0x00ffffff	5	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f130 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t5\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f130:
  // >>0	belong&0x00ffffff	6	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f131 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t6\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f131:
  // >>0	belong&0x00ffffff	7	x86_64
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f132 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t7\tx86_64")
  out = append(out, "x86_64")
  // >>>4		belong&0x00ffffff	0	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f133 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f133:
  // >>>4		belong&0x00ffffff	1	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f134 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f134:
  // >>>4		belong&0x00ffffff	2	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f135 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f135:
  // >>>4		belong&0x00ffffff	3
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f136 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3")
  goto s132
f136:
  // >>>4		belong&0x00ffffff	4	\b_arch1
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f137 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\t\\b_arch1")
  out = append(out, "\\b_arch1")
  goto s132
f137:
  // >>>4		belong&0x00ffffff	>4	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x4)) { goto f138 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>4\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f138:
s132:
  goto s124
f132:
  // >>0	belong&0x00ffffff	8	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f139 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t8\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f139:
  // >>0	belong&0x00ffffff	9	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f140 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t9\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f140:
  // >>0	belong&0x00ffffff	10	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f141 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t10\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f141:
  // >>0	belong&0x00ffffff	11	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f142 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t11\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f142:
  // >>0	belong&0x00ffffff	12	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f143 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t12\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f143:
  // >>0	belong&0x00ffffff	13	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xd)) { goto f144 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t13\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f144:
  // >>0	belong&0x00ffffff	14	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xe)) { goto f145 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t14\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f145:
  // >>0	belong&0x00ffffff	15	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xf)) { goto f146 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t15\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f146:
  // >>0	belong&0x00ffffff	16	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x10)) { goto f147 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t16\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f147:
  // >>0	belong&0x00ffffff	17	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x11)) { goto f148 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t17\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f148:
  // >>0	belong&0x00ffffff	18	ppc64
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x12)) { goto f149 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t18\tppc64")
  out = append(out, "ppc64")
  // >>>4		belong&0x00ffffff	0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f150 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0")
  goto s149
f150:
  // >>>4		belong&0x00ffffff	1		\b_601
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f151 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\t\t\\b_601")
  out = append(out, "\\b_601")
  goto s149
f151:
  // >>>4		belong&0x00ffffff	2		\b_602
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f152 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\t\t\\b_602")
  out = append(out, "\\b_602")
  goto s149
f152:
  // >>>4		belong&0x00ffffff	3		\b_603
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f153 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\t\t\\b_603")
  out = append(out, "\\b_603")
  goto s149
f153:
  // >>>4		belong&0x00ffffff	4		\b_603e
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f154 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\t\t\\b_603e")
  out = append(out, "\\b_603e")
  goto s149
f154:
  // >>>4		belong&0x00ffffff	5		\b_603ev
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f155 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\t\t\\b_603ev")
  out = append(out, "\\b_603ev")
  goto s149
f155:
  // >>>4		belong&0x00ffffff	6		\b_604
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f156 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\t\t\\b_604")
  out = append(out, "\\b_604")
  goto s149
f156:
  // >>>4		belong&0x00ffffff	7		\b_604e
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f157 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\t\t\\b_604e")
  out = append(out, "\\b_604e")
  goto s149
f157:
  // >>>4		belong&0x00ffffff	8		\b_620
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f158 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\t\t\\b_620")
  out = append(out, "\\b_620")
  goto s149
f158:
  // >>>4		belong&0x00ffffff	9		\b_650
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f159 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\t\t\\b_650")
  out = append(out, "\\b_650")
  goto s149
f159:
  // >>>4		belong&0x00ffffff	10		\b_7400
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f160 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\t\t\\b_7400")
  out = append(out, "\\b_7400")
  goto s149
f160:
  // >>>4		belong&0x00ffffff	11		\b_7450
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f161 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\t\t\\b_7450")
  out = append(out, "\\b_7450")
  goto s149
f161:
  // >>>4		belong&0x00ffffff	100		\b_970
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x64)) { goto f162 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t100\t\t\\b_970")
  out = append(out, "\\b_970")
  goto s149
f162:
  // >>>4		belong&0x00ffffff	>100		subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x64)) { goto f163 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>100\t\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s149
f163:
s149:
  goto s124
f149:
  // >>0	belong&0x00ffffff	>18	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x12)) { goto f164 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t>18\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f164:
s124:
  goto s0
f124:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMachOCpu__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0	name	mach-o-cpu
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0\tname\tmach-o-cpu")
  // >0	belong&0x01000000	0
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x1000000 == 0x0)) { goto f1 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tbelong&0x01000000\t0")
  // >>0	belong&0x00ffffff	1
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f2 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t1")
  // >>>4		belong&0x00ffffff	0	vax
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f3 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\tvax")
  out = append(out, "vax")
  goto s2
f3:
  // >>>4		belong&0x00ffffff	1	vax11/780
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f4 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tvax11/780")
  out = append(out, "vax11/780")
  goto s2
f4:
  // >>>4		belong&0x00ffffff	2	vax11/785
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f5 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tvax11/785")
  out = append(out, "vax11/785")
  goto s2
f5:
  // >>>4		belong&0x00ffffff	3	vax11/750
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f6 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\tvax11/750")
  out = append(out, "vax11/750")
  goto s2
f6:
  // >>>4		belong&0x00ffffff	4	vax11/730
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f7 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\tvax11/730")
  out = append(out, "vax11/730")
  goto s2
f7:
  // >>>4		belong&0x00ffffff	5	uvaxI
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f8 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\tuvaxI")
  out = append(out, "uvaxI")
  goto s2
f8:
  // >>>4		belong&0x00ffffff	6	uvaxII
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f9 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\tuvaxII")
  out = append(out, "uvaxII")
  goto s2
f9:
  // >>>4		belong&0x00ffffff	7	vax8200
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f10 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\tvax8200")
  out = append(out, "vax8200")
  goto s2
f10:
  // >>>4		belong&0x00ffffff	8	vax8500
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f11 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\tvax8500")
  out = append(out, "vax8500")
  goto s2
f11:
  // >>>4		belong&0x00ffffff	9	vax8600
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f12 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\tvax8600")
  out = append(out, "vax8600")
  goto s2
f12:
  // >>>4		belong&0x00ffffff	10	vax8650
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f13 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\tvax8650")
  out = append(out, "vax8650")
  goto s2
f13:
  // >>>4		belong&0x00ffffff	11	vax8800
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f14 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\tvax8800")
  out = append(out, "vax8800")
  goto s2
f14:
  // >>>4		belong&0x00ffffff	12	uvaxIII
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f15 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t12\tuvaxIII")
  out = append(out, "uvaxIII")
  goto s2
f15:
  // >>>4		belong&0x00ffffff	>12	vax subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0xc)) { goto f16 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>12\tvax subarchitecture=%ld")
  out = append(out, "vax subarchitecture=%ld")
  goto s2
f16:
s2:
  goto s1
f2:
  // >>0	belong&0x00ffffff	2	romp
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f17 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t2\tromp")
  out = append(out, "romp")
  goto s1
f17:
  // >>0	belong&0x00ffffff	3	architecture=3
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f18 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t3\tarchitecture=3")
  out = append(out, "architecture=3")
  goto s1
f18:
  // >>0	belong&0x00ffffff	4	ns32032
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f19 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t4\tns32032")
  out = append(out, "ns32032")
  goto s1
f19:
  // >>0	belong&0x00ffffff	5	ns32332
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f20 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t5\tns32332")
  out = append(out, "ns32332")
  goto s1
f20:
  // >>0	belong&0x00ffffff	6	m68k
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f21 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t6\tm68k")
  out = append(out, "m68k")
  goto s1
f21:
  // >>0	belong&0x00ffffff	7
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f22 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t7")
  // >>>4	belong&0x0000000f	3		i386
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x3)) { goto f23 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t3\t\ti386")
  out = append(out, "i386")
  goto s22
f23:
  // >>>4	belong&0x0000000f	4		i486
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x4)) { goto f24 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t4\t\ti486")
  out = append(out, "i486")
  // >>>>4	belong&0x00fffff0	0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f25 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0")
  goto s24
f25:
  // >>>>4	belong&0x00fffff0	0x80		\bsx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x80)) { goto f26 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x80\t\t\\bsx")
  out = append(out, "\\bsx")
  goto s24
f26:
s24:
  goto s22
f24:
  // >>>4	belong&0x0000000f	5		i586
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x5)) { goto f27 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t5\t\ti586")
  out = append(out, "i586")
  goto s22
f27:
  // >>>4	belong&0x0000000f	6
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x6)) { goto f28 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t6")
  // >>>>4	belong&0x00fffff0	0		p6
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f29 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0\t\tp6")
  out = append(out, "p6")
  goto s28
f29:
  // >>>>4	belong&0x00fffff0	0x10		pentium_pro
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f30 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\tpentium_pro")
  out = append(out, "pentium_pro")
  goto s28
f30:
  // >>>>4	belong&0x00fffff0	0x20		pentium_2_m0x20
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x20)) { goto f31 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x20\t\tpentium_2_m0x20")
  out = append(out, "pentium_2_m0x20")
  goto s28
f31:
  // >>>>4	belong&0x00fffff0	0x30		pentium_2_m3
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x30)) { goto f32 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x30\t\tpentium_2_m3")
  out = append(out, "pentium_2_m3")
  goto s28
f32:
  // >>>>4	belong&0x00fffff0	0x40		pentium_2_m0x40
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x40)) { goto f33 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x40\t\tpentium_2_m0x40")
  out = append(out, "pentium_2_m0x40")
  goto s28
f33:
  // >>>>4	belong&0x00fffff0	0x50		pentium_2_m5
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x50)) { goto f34 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x50\t\tpentium_2_m5")
  out = append(out, "pentium_2_m5")
  goto s28
f34:
  // >>>>4	belong&0x00fffff0	>0x50		pentium_2_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x50)) { goto f35 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x50\t\tpentium_2_m0x%lx")
  out = append(out, "pentium_2_m0x%lx")
  goto s28
f35:
s28:
  goto s22
f28:
  // >>>4	belong&0x0000000f	7		celeron
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x7)) { goto f36 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t7\t\tceleron")
  out = append(out, "celeron")
  // >>>>4	belong&0x00fffff0	0x00		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f37 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f37:
  // >>>>4	belong&0x00fffff0	0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f38 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f38:
  // >>>>4	belong&0x00fffff0	0x20		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x20)) { goto f39 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x20\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f39:
  // >>>>4	belong&0x00fffff0	0x30		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x30)) { goto f40 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x30\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f40:
  // >>>>4	belong&0x00fffff0	0x40		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x40)) { goto f41 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x40\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f41:
  // >>>>4	belong&0x00fffff0	0x50		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x50)) { goto f42 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x50\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f42:
  // >>>>4	belong&0x00fffff0	0x60
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x60)) { goto f43 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x60")
  goto s36
f43:
  // >>>>4	belong&0x00fffff0	0x70		\b_mobile
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x70)) { goto f44 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x70\t\t\\b_mobile")
  out = append(out, "\\b_mobile")
  goto s36
f44:
  // >>>>4	belong&0x00fffff0	>0x70		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x70)) { goto f45 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x70\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s36
f45:
s36:
  goto s22
f36:
  // >>>4	belong&0x0000000f	8		pentium_3
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x8)) { goto f46 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t8\t\tpentium_3")
  out = append(out, "pentium_3")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f47 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s46
f47:
  // >>>>4	belong&0x00fffff0	0x10		\b_m
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f48 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_m")
  out = append(out, "\\b_m")
  goto s46
f48:
  // >>>>4	belong&0x00fffff0	0x20		\b_xeon
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x20)) { goto f49 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x20\t\t\\b_xeon")
  out = append(out, "\\b_xeon")
  goto s46
f49:
  // >>>>4	belong&0x00fffff0	>0x20		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x20)) { goto f50 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x20\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s46
f50:
s46:
  goto s22
f46:
  // >>>4	belong&0x0000000f	9		pentiumM
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0x9)) { goto f51 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t9\t\tpentiumM")
  out = append(out, "pentiumM")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f52 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s51
f52:
  // >>>>4	belong&0x00fffff0	>0x00		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x0)) { goto f53 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x00\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s51
f53:
s51:
  goto s22
f51:
  // >>>4	belong&0x0000000f	10		pentium_4
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0xa)) { goto f54 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t10\t\tpentium_4")
  out = append(out, "pentium_4")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f55 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s54
f55:
  // >>>>4	belong&0x00fffff0	0x10		\b_m
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f56 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_m")
  out = append(out, "\\b_m")
  goto s54
f56:
  // >>>>4	belong&0x00fffff0	>0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x10)) { goto f57 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s54
f57:
s54:
  goto s22
f54:
  // >>>4	belong&0x0000000f	11		itanium
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0xb)) { goto f58 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t11\t\titanium")
  out = append(out, "itanium")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f59 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s58
f59:
  // >>>>4	belong&0x00fffff0	0x10		\b_2
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f60 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_2")
  out = append(out, "\\b_2")
  goto s58
f60:
  // >>>>4	belong&0x00fffff0	>0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x10)) { goto f61 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s58
f61:
s58:
  goto s22
f58:
  // >>>4	belong&0x0000000f	12		xeon
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xf == 0xc)) { goto f62 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t12\t\txeon")
  out = append(out, "xeon")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f63 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s62
f63:
  // >>>>4	belong&0x00fffff0	0x10		\b_mp
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x10)) { goto f64 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x10\t\t\\b_mp")
  out = append(out, "\\b_mp")
  goto s62
f64:
  // >>>>4	belong&0x00fffff0	>0x10		\b_m0x%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x10)) { goto f65 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x10\t\t\\b_m0x%lx")
  out = append(out, "\\b_m0x%lx")
  goto s62
f65:
s62:
  goto s22
f62:
  // >>>4	belong&0x0000000f	>12		ia32 family=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xf > 0xc)) { goto f66 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\tbelong&0x0000000f\t>12\t\tia32 family=%ld")
  out = append(out, "ia32 family=%ld")
  // >>>>4	belong&0x00fffff0	0x00
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffff0 == 0x0)) { goto f67 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t0x00")
  goto s66
f67:
  // >>>>4	belong&0x00fffff0	>0x00		model=%lx
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xfffff0 > 0x0)) { goto f68 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>>4\tbelong&0x00fffff0\t>0x00\t\tmodel=%lx")
  out = append(out, "model=%lx")
  goto s66
f68:
s66:
  goto s22
f66:
s22:
  goto s1
f22:
  // >>0	belong&0x00ffffff	8	mips
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f69 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t8\tmips")
  out = append(out, "mips")
  // >>>4		belong&0x00ffffff	1	R2300
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f70 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tR2300")
  out = append(out, "R2300")
  goto s69
f70:
  // >>>4		belong&0x00ffffff	2	R2600
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f71 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tR2600")
  out = append(out, "R2600")
  goto s69
f71:
  // >>>4		belong&0x00ffffff	3	R2800
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f72 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\tR2800")
  out = append(out, "R2800")
  goto s69
f72:
  // >>>4		belong&0x00ffffff	4	R2000a
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f73 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\tR2000a")
  out = append(out, "R2000a")
  goto s69
f73:
  // >>>4		belong&0x00ffffff	5	R2000
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f74 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\tR2000")
  out = append(out, "R2000")
  goto s69
f74:
  // >>>4		belong&0x00ffffff	6	R3000a
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f75 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\tR3000a")
  out = append(out, "R3000a")
  goto s69
f75:
  // >>>4		belong&0x00ffffff	7	R3000
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f76 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\tR3000")
  out = append(out, "R3000")
  goto s69
f76:
  // >>>4		belong&0x00ffffff	>7	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x7)) { goto f77 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>7\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s69
f77:
s69:
  goto s1
f69:
  // >>0	belong&0x00ffffff	9	ns32532
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f78 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t9\tns32532")
  out = append(out, "ns32532")
  goto s1
f78:
  // >>0	belong&0x00ffffff	10	mc98000
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f79 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t10\tmc98000")
  out = append(out, "mc98000")
  goto s1
f79:
  // >>0	belong&0x00ffffff	11	hppa
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f80 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t11\thppa")
  out = append(out, "hppa")
  // >>>4		belong&0x00ffffff	0	7100
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f81 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\t7100")
  out = append(out, "7100")
  goto s80
f81:
  // >>>4		belong&0x00ffffff	1	7100LC
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f82 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\t7100LC")
  out = append(out, "7100LC")
  goto s80
f82:
  // >>>4		belong&0x00ffffff	>1	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x1)) { goto f83 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>1\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s80
f83:
s80:
  goto s1
f80:
  // >>0	belong&0x00ffffff	12	arm
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f84 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t12\tarm")
  out = append(out, "arm")
  // >>>4		belong&0x00ffffff	0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f85 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0")
  goto s84
f85:
  // >>>4		belong&0x00ffffff	1	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f86 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f86:
  // >>>4		belong&0x00ffffff	2	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f87 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f87:
  // >>>4		belong&0x00ffffff	3	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f88 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f88:
  // >>>4		belong&0x00ffffff	4	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f89 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f89:
  // >>>4		belong&0x00ffffff	5	\b_v4t
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f90 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\t\\b_v4t")
  out = append(out, "\\b_v4t")
  goto s84
f90:
  // >>>4		belong&0x00ffffff	6	\b_v6
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f91 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\t\\b_v6")
  out = append(out, "\\b_v6")
  goto s84
f91:
  // >>>4		belong&0x00ffffff	7	\b_v5tej
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f92 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\t\\b_v5tej")
  out = append(out, "\\b_v5tej")
  goto s84
f92:
  // >>>4		belong&0x00ffffff	8	\b_xscale
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f93 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\t\\b_xscale")
  out = append(out, "\\b_xscale")
  goto s84
f93:
  // >>>4		belong&0x00ffffff	9	\b_v7
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f94 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\t\\b_v7")
  out = append(out, "\\b_v7")
  goto s84
f94:
  // >>>4		belong&0x00ffffff	10	\b_v7f
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f95 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\t\\b_v7f")
  out = append(out, "\\b_v7f")
  goto s84
f95:
  // >>>4		belong&0x00ffffff	11	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f96 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f96:
  // >>>4		belong&0x00ffffff	12	\b_v7k
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f97 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t12\t\\b_v7k")
  out = append(out, "\\b_v7k")
  goto s84
f97:
  // >>>4		belong&0x00ffffff	>12	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0xc)) { goto f98 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>12\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s84
f98:
s84:
  goto s1
f84:
  // >>0	belong&0x00ffffff	13
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xd)) { goto f99 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t13")
  // >>>4		belong&0x00ffffff	0	mc88000
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f100 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\tmc88000")
  out = append(out, "mc88000")
  goto s99
f100:
  // >>>4		belong&0x00ffffff	1	mc88100
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f101 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tmc88100")
  out = append(out, "mc88100")
  goto s99
f101:
  // >>>4		belong&0x00ffffff	2	mc88110
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f102 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tmc88110")
  out = append(out, "mc88110")
  goto s99
f102:
  // >>>4		belong&0x00ffffff	>2	mc88000 subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x2)) { goto f103 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>2\tmc88000 subarchitecture=%ld")
  out = append(out, "mc88000 subarchitecture=%ld")
  goto s99
f103:
s99:
  goto s1
f99:
  // >>0	belong&0x00ffffff	14	sparc
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xe)) { goto f104 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t14\tsparc")
  out = append(out, "sparc")
  goto s1
f104:
  // >>0	belong&0x00ffffff	15	i860g
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xf)) { goto f105 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t15\ti860g")
  out = append(out, "i860g")
  goto s1
f105:
  // >>0	belong&0x00ffffff	16	alpha
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x10)) { goto f106 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t16\talpha")
  out = append(out, "alpha")
  goto s1
f106:
  // >>0	belong&0x00ffffff	17	rs6000
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x11)) { goto f107 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t17\trs6000")
  out = append(out, "rs6000")
  goto s1
f107:
  // >>0	belong&0x00ffffff	18	ppc
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x12)) { goto f108 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t18\tppc")
  out = append(out, "ppc")
  // >>>4		belong&0x00ffffff	0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f109 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0")
  goto s108
f109:
  // >>>4		belong&0x00ffffff	1	\b_601
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f110 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\t\\b_601")
  out = append(out, "\\b_601")
  goto s108
f110:
  // >>>4		belong&0x00ffffff	2	\b_602
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f111 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\t\\b_602")
  out = append(out, "\\b_602")
  goto s108
f111:
  // >>>4		belong&0x00ffffff	3	\b_603
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f112 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\t\\b_603")
  out = append(out, "\\b_603")
  goto s108
f112:
  // >>>4		belong&0x00ffffff	4	\b_603e
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f113 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\t\\b_603e")
  out = append(out, "\\b_603e")
  goto s108
f113:
  // >>>4		belong&0x00ffffff	5	\b_603ev
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f114 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\t\\b_603ev")
  out = append(out, "\\b_603ev")
  goto s108
f114:
  // >>>4		belong&0x00ffffff	6	\b_604
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f115 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\t\\b_604")
  out = append(out, "\\b_604")
  goto s108
f115:
  // >>>4		belong&0x00ffffff	7	\b_604e
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f116 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\t\\b_604e")
  out = append(out, "\\b_604e")
  goto s108
f116:
  // >>>4		belong&0x00ffffff	8	\b_620
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f117 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\t\\b_620")
  out = append(out, "\\b_620")
  goto s108
f117:
  // >>>4		belong&0x00ffffff	9	\b_650
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f118 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\t\\b_650")
  out = append(out, "\\b_650")
  goto s108
f118:
  // >>>4		belong&0x00ffffff	10	\b_7400
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f119 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\t\\b_7400")
  out = append(out, "\\b_7400")
  goto s108
f119:
  // >>>4		belong&0x00ffffff	11	\b_7450
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f120 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\t\\b_7450")
  out = append(out, "\\b_7450")
  goto s108
f120:
  // >>>4		belong&0x00ffffff	100	\b_970
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x64)) { goto f121 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t100\t\\b_970")
  out = append(out, "\\b_970")
  goto s108
f121:
  // >>>4		belong&0x00ffffff	>100	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x64)) { goto f122 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>100\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s108
f122:
s108:
  goto s1
f108:
  // >>0	belong&0x00ffffff	>18	architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x12)) { goto f123 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t>18\tarchitecture=%ld")
  out = append(out, "architecture=%ld")
  goto s1
f123:
s1:
  goto s0
f1:
  // >0	belong&0x01000000	0x01000000
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0x1000000 == 0x1000000)) { goto f124 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">0\tbelong&0x01000000\t0x01000000")
  // >>0	belong&0x00ffffff	0	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f125 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t0\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f125:
  // >>0	belong&0x00ffffff	1	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f126 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t1\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f126:
  // >>0	belong&0x00ffffff	2	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f127 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t2\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f127:
  // >>0	belong&0x00ffffff	3	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f128 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t3\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f128:
  // >>0	belong&0x00ffffff	4	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f129 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t4\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f129:
  // >>0	belong&0x00ffffff	5	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f130 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t5\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f130:
  // >>0	belong&0x00ffffff	6	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f131 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t6\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f131:
  // >>0	belong&0x00ffffff	7	x86_64
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f132 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t7\tx86_64")
  out = append(out, "x86_64")
  // >>>4		belong&0x00ffffff	0	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f133 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f133:
  // >>>4		belong&0x00ffffff	1	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f134 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f134:
  // >>>4		belong&0x00ffffff	2	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f135 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f135:
  // >>>4		belong&0x00ffffff	3
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f136 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3")
  goto s132
f136:
  // >>>4		belong&0x00ffffff	4	\b_arch1
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f137 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\t\\b_arch1")
  out = append(out, "\\b_arch1")
  goto s132
f137:
  // >>>4		belong&0x00ffffff	>4	subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x4)) { goto f138 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>4\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s132
f138:
s132:
  goto s124
f132:
  // >>0	belong&0x00ffffff	8	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f139 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t8\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f139:
  // >>0	belong&0x00ffffff	9	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f140 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t9\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f140:
  // >>0	belong&0x00ffffff	10	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f141 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t10\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f141:
  // >>0	belong&0x00ffffff	11	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f142 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t11\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f142:
  // >>0	belong&0x00ffffff	12	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xc)) { goto f143 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t12\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f143:
  // >>0	belong&0x00ffffff	13	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xd)) { goto f144 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t13\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f144:
  // >>0	belong&0x00ffffff	14	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xe)) { goto f145 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t14\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f145:
  // >>0	belong&0x00ffffff	15	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xf)) { goto f146 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t15\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f146:
  // >>0	belong&0x00ffffff	16	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x10)) { goto f147 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t16\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f147:
  // >>0	belong&0x00ffffff	17	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x11)) { goto f148 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t17\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f148:
  // >>0	belong&0x00ffffff	18	ppc64
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x12)) { goto f149 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t18\tppc64")
  out = append(out, "ppc64")
  // >>>4		belong&0x00ffffff	0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x0)) { goto f150 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t0")
  goto s149
f150:
  // >>>4		belong&0x00ffffff	1		\b_601
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x1)) { goto f151 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t1\t\t\\b_601")
  out = append(out, "\\b_601")
  goto s149
f151:
  // >>>4		belong&0x00ffffff	2		\b_602
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x2)) { goto f152 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t2\t\t\\b_602")
  out = append(out, "\\b_602")
  goto s149
f152:
  // >>>4		belong&0x00ffffff	3		\b_603
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x3)) { goto f153 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t3\t\t\\b_603")
  out = append(out, "\\b_603")
  goto s149
f153:
  // >>>4		belong&0x00ffffff	4		\b_603e
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x4)) { goto f154 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t4\t\t\\b_603e")
  out = append(out, "\\b_603e")
  goto s149
f154:
  // >>>4		belong&0x00ffffff	5		\b_603ev
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x5)) { goto f155 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t5\t\t\\b_603ev")
  out = append(out, "\\b_603ev")
  goto s149
f155:
  // >>>4		belong&0x00ffffff	6		\b_604
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x6)) { goto f156 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t6\t\t\\b_604")
  out = append(out, "\\b_604")
  goto s149
f156:
  // >>>4		belong&0x00ffffff	7		\b_604e
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x7)) { goto f157 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t7\t\t\\b_604e")
  out = append(out, "\\b_604e")
  goto s149
f157:
  // >>>4		belong&0x00ffffff	8		\b_620
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x8)) { goto f158 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t8\t\t\\b_620")
  out = append(out, "\\b_620")
  goto s149
f158:
  // >>>4		belong&0x00ffffff	9		\b_650
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x9)) { goto f159 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t9\t\t\\b_650")
  out = append(out, "\\b_650")
  goto s149
f159:
  // >>>4		belong&0x00ffffff	10		\b_7400
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xa)) { goto f160 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t10\t\t\\b_7400")
  out = append(out, "\\b_7400")
  goto s149
f160:
  // >>>4		belong&0x00ffffff	11		\b_7450
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0xb)) { goto f161 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t11\t\t\\b_7450")
  out = append(out, "\\b_7450")
  goto s149
f161:
  // >>>4		belong&0x00ffffff	100		\b_970
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xffffff == 0x64)) { goto f162 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t100\t\t\\b_970")
  out = append(out, "\\b_970")
  goto s149
f162:
  // >>>4		belong&0x00ffffff	>100		subarchitecture=%ld
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x64)) { goto f163 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>>4\t\tbelong&0x00ffffff\t>100\t\tsubarchitecture=%ld")
  out = append(out, "subarchitecture=%ld")
  goto s149
f163:
s149:
  goto s124
f149:
  // >>0	belong&0x00ffffff	>18	64-bit architecture=%ld
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (i64(i32(iv))&0xffffff > 0x12)) { goto f164 }
  }
  gof = off + 4
  fmt.Printf("matched rule: %s\n", ">>0\tbelong&0x00ffffff\t>18\t64-bit architecture=%ld")
  out = append(out, "64-bit architecture=%ld")
  goto s124
f164:
s124:
  goto s0
f124:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMsdosCom(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0       name    msdos-com
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0       name    msdos-com")
  // >0  byte        x               DOS executable (COM)
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0  byte        x               DOS executable (COM)")
  out = append(out, "DOS executable (COM)")
  goto s0
  // >6	string		SFX\ of\ LHarc	\b, %s
  off = pageOff + 0x6
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x46, 0x58, 0x20, 0x6f, 0x66, 0x20, 0x4c, 0x48, 0x61, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f2 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">6\tstring\t\tSFX\\ of\\ LHarc\t\\b, %s")
  out = append(out, "\\b, %s")
  goto s0
f2:
  // >0x1FE leshort	0xAA55		    \b, boot code
  off = pageOff + 0x1fe
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0xaa55)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">0x1FE leshort\t0xAA55\t\t    \\b, boot code")
  out = append(out, "\\b, boot code")
  goto s0
f3:
  // >85	string		UPX		        \b, UPX compressed
  off = pageOff + 0x55
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f4 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">85\tstring\t\tUPX\t\t        \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s0
f4:
  // >4	string		\ $ARX		    \b, ARX self-extracting archive
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x41, 0x52, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f5 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\t\\ $ARX\t\t    \\b, ARX self-extracting archive")
  out = append(out, "\\b, ARX self-extracting archive")
  goto s0
f5:
  // >4	string		\ $LHarc	    \b, LHarc self-extracting archive
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x4c, 0x48, 0x61, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f6 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\t\\ $LHarc\t    \\b, LHarc self-extracting archive")
  out = append(out, "\\b, LHarc self-extracting archive")
  goto s0
f6:
  // >0x20e string	SFX\ by\ LARC	\b, LARC self-extracting archive
  off = pageOff + 0x20e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x46, 0x58, 0x20, 0x62, 0x79, 0x20, 0x4c, 0x41, 0x52, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f7 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x20e string\tSFX\\ by\\ LARC\t\\b, LARC self-extracting archive")
  out = append(out, "\\b, LARC self-extracting archive")
  goto s0
f7:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMsdosCom__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0       name    msdos-com
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0       name    msdos-com")
  // >0  byte        x               DOS executable (COM)
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0  byte        x               DOS executable (COM)")
  out = append(out, "DOS executable (COM)")
  goto s0
  // >6	string		SFX\ of\ LHarc	\b, %s
  off = pageOff + 0x6
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x46, 0x58, 0x20, 0x6f, 0x66, 0x20, 0x4c, 0x48, 0x61, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f2 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">6\tstring\t\tSFX\\ of\\ LHarc\t\\b, %s")
  out = append(out, "\\b, %s")
  goto s0
f2:
  // >0x1FE leshort	0xAA55		    \b, boot code
  off = pageOff + 0x1fe
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0xaa55)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">0x1FE leshort\t0xAA55\t\t    \\b, boot code")
  out = append(out, "\\b, boot code")
  goto s0
f3:
  // >85	string		UPX		        \b, UPX compressed
  off = pageOff + 0x55
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f4 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">85\tstring\t\tUPX\t\t        \\b, UPX compressed")
  out = append(out, "\\b, UPX compressed")
  goto s0
f4:
  // >4	string		\ $ARX		    \b, ARX self-extracting archive
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x41, 0x52, 0x58}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f5 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\t\\ $ARX\t\t    \\b, ARX self-extracting archive")
  out = append(out, "\\b, ARX self-extracting archive")
  goto s0
f5:
  // >4	string		\ $LHarc	    \b, LHarc self-extracting archive
  off = pageOff + 0x4
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x20, 0x24, 0x4c, 0x48, 0x61, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f6 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">4\tstring\t\t\\ $LHarc\t    \\b, LHarc self-extracting archive")
  out = append(out, "\\b, LHarc self-extracting archive")
  goto s0
f6:
  // >0x20e string	SFX\ by\ LARC	\b, LARC self-extracting archive
  off = pageOff + 0x20e
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x53, 0x46, 0x58, 0x20, 0x62, 0x79, 0x20, 0x4c, 0x41, 0x52, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f7 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">0x20e string\tSFX\\ by\\ LARC\t\\b, LARC self-extracting archive")
  out = append(out, "\\b, LARC self-extracting archive")
  goto s0
f7:
s0:
  goto end
end:
  return out, nil
}

func IdentifyMsdosDriver(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0       name    			msdos-driver		DOS executable (
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0       name    \t\t\tmsdos-driver\t\tDOS executable (")
  out = append(out, "DOS executable (")
  // >40	search/7			UPX!			\bUPX compressed
  off = pageOff + 0x28
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x7, "UPX!"))
    if ml < 0 { goto f1 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">40\tsearch/7\t\t\tUPX!\t\t\t\\bUPX compressed")
  out = append(out, "\\bUPX compressed")
  goto s0
f1:
  // >4	uleshort&0x8000			0x0000			\bblock device driver
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x0)) { goto f2 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x0000\t\t\t\\bblock device driver")
  out = append(out, "\\bblock device driver")
  goto s0
f2:
  // >4	uleshort&0x8000			0x8000			\b
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x8000\t\t\t\\b")
  out = append(out, "\\b")
  // >>4	uleshort&0x0008			0x0008			\bclock
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8 == 0x8)) { goto f4 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0008\t\t\t0x0008\t\t\t\\bclock")
  out = append(out, "\\bclock")
  goto s3
f4:
  // >>4	uleshort&0x0010			0x0010			\bfast
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x10 == 0x10)) { goto f5 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0010\t\t\t0x0010\t\t\t\\bfast")
  out = append(out, "\\bfast")
  goto s3
f5:
  // >>4	uleshort&0x0003			>0			\bstandard
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0x3 > 0x0)) { goto f6 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0003\t\t\t>0\t\t\t\\bstandard")
  out = append(out, "\\bstandard")
  // >>>4	uleshort&0x0001			0x0001			\binput
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x1 == 0x1)) { goto f7 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort&0x0001\t\t\t0x0001\t\t\t\\binput")
  out = append(out, "\\binput")
  goto s6
f7:
  // >>>4	uleshort&0x0003			0x0003			\b/
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x3)) { goto f8 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort&0x0003\t\t\t0x0003\t\t\t\\b/")
  out = append(out, "\\b/")
  goto s6
f8:
  // >>>4	uleshort&0x0002			0x0002			\boutput
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x2 == 0x2)) { goto f9 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort&0x0002\t\t\t0x0002\t\t\t\\boutput")
  out = append(out, "\\boutput")
  goto s6
f9:
s6:
  goto s3
f6:
  // >>4	uleshort&0x8000			0x8000			\bcharacter device driver
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f10 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x8000\t\t\t0x8000\t\t\t\\bcharacter device driver")
  out = append(out, "\\bcharacter device driver")
  goto s3
f10:
s3:
  goto s0
f3:
  // >0	ubyte				x
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tubyte\t\t\t\tx")
  // >>40	search/7			UPX!
  off = pageOff + 0x28
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x7, "UPX!"))
    if ml < 0 { goto f12 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>40\tsearch/7\t\t\tUPX!")
  goto s11
f12:
  // >>40	default				x
  off = pageOff + 0x28
  // uh oh unhandled kind default
  goto f13
  fmt.Printf("matched rule: %s\n", ">>40\tdefault\t\t\t\tx")
  // >>>12		ubyte			>0x2E			\b
  off = pageOff + 0xc
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x2e)) { goto f14 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>12\t\tubyte\t\t\t>0x2E\t\t\t\\b")
  out = append(out, "\\b")
  // >>>>10		ubyte			>0x20
  off = pageOff + 0xa
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f15 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>10\t\tubyte\t\t\t>0x20")
  // >>>>>10		ubyte			!0x2E
  off = pageOff + 0xa
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f16 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>10\t\tubyte\t\t\t!0x2E")
  // >>>>>>10	ubyte			!0x2A			\b%c
  off = pageOff + 0xa
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2a)) { goto f17 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>10\tubyte\t\t\t!0x2A\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s16
f17:
s16:
  goto s15
f16:
s15:
  goto s14
f15:
  // >>>>11		ubyte			>0x20
  off = pageOff + 0xb
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f18 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>11\t\tubyte\t\t\t>0x20")
  // >>>>>11		ubyte			!0x2E			\b%c
  off = pageOff + 0xb
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f19 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>11\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s18
f19:
s18:
  goto s14
f18:
  // >>>>12		ubyte			>0x20
  off = pageOff + 0xc
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f20 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>12\t\tubyte\t\t\t>0x20")
  // >>>>>12		ubyte			!0x39
  off = pageOff + 0xc
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x39)) { goto f21 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>12\t\tubyte\t\t\t!0x39")
  // >>>>>>12	ubyte			!0x2E			\b%c
  off = pageOff + 0xc
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f22 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>12\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s21
f22:
s21:
  goto s20
f21:
s20:
  goto s14
f20:
s14:
  goto s13
f14:
  // >>>13		ubyte			>0x20
  off = pageOff + 0xd
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f23 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>13\t\tubyte\t\t\t>0x20")
  // >>>>13		ubyte			!0x2E			\b%c
  off = pageOff + 0xd
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f24 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>13\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s23
f24:
  // >>>>14		ubyte			>0x20
  off = pageOff + 0xe
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f25 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>14\t\tubyte\t\t\t>0x20")
  // >>>>>14		ubyte			!0x2E			\b%c
  off = pageOff + 0xe
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f26 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>14\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s25
f26:
s25:
  goto s23
f25:
  // >>>>15		ubyte			>0x20
  off = pageOff + 0xf
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f27 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>15\t\tubyte\t\t\t>0x20")
  // >>>>>15		ubyte			!0x2E			\b%c
  off = pageOff + 0xf
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f28 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>15\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s27
f28:
s27:
  goto s23
f27:
  // >>>>16		ubyte			>0x20
  off = pageOff + 0x10
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f29 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>16\t\tubyte\t\t\t>0x20")
  // >>>>>16		ubyte			!0x2E
  off = pageOff + 0x10
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f30 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>16\t\tubyte\t\t\t!0x2E")
  // >>>>>>16	ubyte			<0xCB			\b%c
  off = pageOff + 0x10
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) < 0xcb)) { goto f31 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>16\tubyte\t\t\t<0xCB\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s30
f31:
s30:
  goto s29
f30:
s29:
  goto s23
f29:
  // >>>>17		ubyte			>0x20
  off = pageOff + 0x11
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f32 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>17\t\tubyte\t\t\t>0x20")
  // >>>>>17		ubyte			!0x2E
  off = pageOff + 0x11
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f33 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>17\t\tubyte\t\t\t!0x2E")
  // >>>>>>17	ubyte			<0x90			\b%c
  off = pageOff + 0x11
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) < 0x90)) { goto f34 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>17\tubyte\t\t\t<0x90\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s33
f34:
s33:
  goto s32
f33:
s32:
  goto s23
f32:
s23:
  goto s13
f23:
  // >>>12		ubyte			<0x2F
  off = pageOff + 0xc
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (i64(i8(iv)) < 0x2f)) { goto f35 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>12\t\tubyte\t\t\t<0x2F")
  // >>>>22		string			>\056			%-.6s
  off = pageOff + 0x16
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f36 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>22\t\tstring\t\t\t>\\056\t\t\t%-.6s")
  out = append(out, "%-.6s")
  goto s35
f36:
s35:
  goto s13
f35:
s13:
  goto s11
f13:
s11:
  goto s0
  // >4	uleshort&0x8000			0x0000
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x0)) { goto f37 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x0000")
  // >>4	uleshort&0x0002			0x0002			\b,32-bit sector-
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x2 == 0x2)) { goto f38 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0002\t\t\t0x0002\t\t\t\\b,32-bit sector-")
  out = append(out, "\\b,32-bit sector-")
  goto s37
f38:
s37:
  goto s0
f37:
  // >4	uleshort&0x0040			0x0040			\b,IOCTL-
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x40 == 0x40)) { goto f39 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x0040\t\t\t0x0040\t\t\t\\b,IOCTL-")
  out = append(out, "\\b,IOCTL-")
  goto s0
f39:
  // >4	uleshort&0x0800			0x0800			\b,close media-
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x800 == 0x800)) { goto f40 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x0800\t\t\t0x0800\t\t\t\\b,close media-")
  out = append(out, "\\b,close media-")
  goto s0
f40:
  // >4	uleshort&0x8000			0x8000
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f41 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x8000")
  // >>4	uleshort&0x2000			0x2000			\b,until busy-
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x2000 == 0x2000)) { goto f42 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x2000\t\t\t0x2000\t\t\t\\b,until busy-")
  out = append(out, "\\b,until busy-")
  goto s41
f42:
s41:
  goto s0
f41:
  // >4	uleshort&0x4000			0x4000			\b,control strings-
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x4000 == 0x4000)) { goto f43 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x4000\t\t\t0x4000\t\t\t\\b,control strings-")
  out = append(out, "\\b,control strings-")
  goto s0
f43:
  // >4	uleshort&0x8000			0x8000
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f44 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x8000")
  // >>4	uleshort&0x6840			>0			\bsupport
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0x6840 > 0x0)) { goto f45 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x6840\t\t\t>0\t\t\t\\bsupport")
  out = append(out, "\\bsupport")
  goto s44
f45:
s44:
  goto s0
f44:
  // >4	uleshort&0x8000			0x0000
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x0)) { goto f46 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x0000")
  // >>4	uleshort&0x4842			>0			\bsupport
  off = pageOff + 0x4
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0x4842 > 0x0)) { goto f47 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x4842\t\t\t>0\t\t\t\\bsupport")
  out = append(out, "\\bsupport")
  goto s46
f47:
s46:
  goto s0
f46:
  // >0	ubyte				x			\b)
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tubyte\t\t\t\tx\t\t\t\\b)")
  out = append(out, "\\b)")
  goto s0
s0:
  goto end
end:
  return out, nil
}

func IdentifyMsdosDriver__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64

  // 0       name    			msdos-driver		DOS executable (
  off = pageOff + 0x0
  fmt.Printf("matched rule: %s\n", "0       name    \t\t\tmsdos-driver\t\tDOS executable (")
  out = append(out, "DOS executable (")
  // >40	search/7			UPX!			\bUPX compressed
  off = pageOff + 0x28
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x7, "UPX!"))
    if ml < 0 { goto f1 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">40\tsearch/7\t\t\tUPX!\t\t\t\\bUPX compressed")
  out = append(out, "\\bUPX compressed")
  goto s0
f1:
  // >4	uleshort&0x8000			0x0000			\bblock device driver
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x0)) { goto f2 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x0000\t\t\t\\bblock device driver")
  out = append(out, "\\bblock device driver")
  goto s0
f2:
  // >4	uleshort&0x8000			0x8000			\b
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f3 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x8000\t\t\t\\b")
  out = append(out, "\\b")
  // >>4	uleshort&0x0008			0x0008			\bclock
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8 == 0x8)) { goto f4 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0008\t\t\t0x0008\t\t\t\\bclock")
  out = append(out, "\\bclock")
  goto s3
f4:
  // >>4	uleshort&0x0010			0x0010			\bfast
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x10 == 0x10)) { goto f5 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0010\t\t\t0x0010\t\t\t\\bfast")
  out = append(out, "\\bfast")
  goto s3
f5:
  // >>4	uleshort&0x0003			>0			\bstandard
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0x3 > 0x0)) { goto f6 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0003\t\t\t>0\t\t\t\\bstandard")
  out = append(out, "\\bstandard")
  // >>>4	uleshort&0x0001			0x0001			\binput
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x1 == 0x1)) { goto f7 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort&0x0001\t\t\t0x0001\t\t\t\\binput")
  out = append(out, "\\binput")
  goto s6
f7:
  // >>>4	uleshort&0x0003			0x0003			\b/
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x3 == 0x3)) { goto f8 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort&0x0003\t\t\t0x0003\t\t\t\\b/")
  out = append(out, "\\b/")
  goto s6
f8:
  // >>>4	uleshort&0x0002			0x0002			\boutput
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x2 == 0x2)) { goto f9 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>>4\tuleshort&0x0002\t\t\t0x0002\t\t\t\\boutput")
  out = append(out, "\\boutput")
  goto s6
f9:
s6:
  goto s3
f6:
  // >>4	uleshort&0x8000			0x8000			\bcharacter device driver
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f10 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x8000\t\t\t0x8000\t\t\t\\bcharacter device driver")
  out = append(out, "\\bcharacter device driver")
  goto s3
f10:
s3:
  goto s0
f3:
  // >0	ubyte				x
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tubyte\t\t\t\tx")
  // >>40	search/7			UPX!
  off = pageOff + 0x28
  {
    ml := i64(wizardry.SearchTest(tb, int(off), 0x7, "UPX!"))
    if ml < 0 { goto f12 }
    gof = off + ml + 0x4
  }
  fmt.Printf("matched rule: %s\n", ">>40\tsearch/7\t\t\tUPX!")
  goto s11
f12:
  // >>40	default				x
  off = pageOff + 0x28
  // uh oh unhandled kind default
  goto f13
  fmt.Printf("matched rule: %s\n", ">>40\tdefault\t\t\t\tx")
  // >>>12		ubyte			>0x2E			\b
  off = pageOff + 0xc
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x2e)) { goto f14 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>12\t\tubyte\t\t\t>0x2E\t\t\t\\b")
  out = append(out, "\\b")
  // >>>>10		ubyte			>0x20
  off = pageOff + 0xa
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f15 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>10\t\tubyte\t\t\t>0x20")
  // >>>>>10		ubyte			!0x2E
  off = pageOff + 0xa
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f16 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>10\t\tubyte\t\t\t!0x2E")
  // >>>>>>10	ubyte			!0x2A			\b%c
  off = pageOff + 0xa
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2a)) { goto f17 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>10\tubyte\t\t\t!0x2A\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s16
f17:
s16:
  goto s15
f16:
s15:
  goto s14
f15:
  // >>>>11		ubyte			>0x20
  off = pageOff + 0xb
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f18 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>11\t\tubyte\t\t\t>0x20")
  // >>>>>11		ubyte			!0x2E			\b%c
  off = pageOff + 0xb
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f19 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>11\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s18
f19:
s18:
  goto s14
f18:
  // >>>>12		ubyte			>0x20
  off = pageOff + 0xc
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f20 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>12\t\tubyte\t\t\t>0x20")
  // >>>>>12		ubyte			!0x39
  off = pageOff + 0xc
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x39)) { goto f21 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>12\t\tubyte\t\t\t!0x39")
  // >>>>>>12	ubyte			!0x2E			\b%c
  off = pageOff + 0xc
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f22 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>12\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s21
f22:
s21:
  goto s20
f21:
s20:
  goto s14
f20:
s14:
  goto s13
f14:
  // >>>13		ubyte			>0x20
  off = pageOff + 0xd
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f23 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>13\t\tubyte\t\t\t>0x20")
  // >>>>13		ubyte			!0x2E			\b%c
  off = pageOff + 0xd
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f24 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>13\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s23
f24:
  // >>>>14		ubyte			>0x20
  off = pageOff + 0xe
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f25 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>14\t\tubyte\t\t\t>0x20")
  // >>>>>14		ubyte			!0x2E			\b%c
  off = pageOff + 0xe
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f26 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>14\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s25
f26:
s25:
  goto s23
f25:
  // >>>>15		ubyte			>0x20
  off = pageOff + 0xf
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f27 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>15\t\tubyte\t\t\t>0x20")
  // >>>>>15		ubyte			!0x2E			\b%c
  off = pageOff + 0xf
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f28 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>15\t\tubyte\t\t\t!0x2E\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s27
f28:
s27:
  goto s23
f27:
  // >>>>16		ubyte			>0x20
  off = pageOff + 0x10
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f29 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>16\t\tubyte\t\t\t>0x20")
  // >>>>>16		ubyte			!0x2E
  off = pageOff + 0x10
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f30 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>16\t\tubyte\t\t\t!0x2E")
  // >>>>>>16	ubyte			<0xCB			\b%c
  off = pageOff + 0x10
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) < 0xcb)) { goto f31 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>16\tubyte\t\t\t<0xCB\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s30
f31:
s30:
  goto s29
f30:
s29:
  goto s23
f29:
  // >>>>17		ubyte			>0x20
  off = pageOff + 0x11
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) > 0x20)) { goto f32 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>17\t\tubyte\t\t\t>0x20")
  // >>>>>17		ubyte			!0x2E
  off = pageOff + 0x11
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) != 0x2e)) { goto f33 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>17\t\tubyte\t\t\t!0x2E")
  // >>>>>>17	ubyte			<0x90			\b%c
  off = pageOff + 0x11
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) < 0x90)) { goto f34 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>>>>17\tubyte\t\t\t<0x90\t\t\t\\b%c")
  out = append(out, "\\b%c")
  goto s33
f34:
s33:
  goto s32
f33:
s32:
  goto s23
f32:
s23:
  goto s13
f23:
  // >>>12		ubyte			<0x2F
  off = pageOff + 0xc
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (i64(i8(iv)) < 0x2f)) { goto f35 }
  }
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">>>12\t\tubyte\t\t\t<0x2F")
  // >>>>22		string			>\056			%-.6s
  off = pageOff + 0x16
  {
    ml := i64(wizardry.StringTest(tb, int(off), []byte{0x3e, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
    if ml < 0 { goto f36 }
    gof = off + ml
  }
  fmt.Printf("matched rule: %s\n", ">>>>22\t\tstring\t\t\t>\\056\t\t\t%-.6s")
  out = append(out, "%-.6s")
  goto s35
f36:
s35:
  goto s13
f35:
s13:
  goto s11
f13:
s11:
  goto s0
  // >4	uleshort&0x8000			0x0000
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x0)) { goto f37 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x0000")
  // >>4	uleshort&0x0002			0x0002			\b,32-bit sector-
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x2 == 0x2)) { goto f38 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x0002\t\t\t0x0002\t\t\t\\b,32-bit sector-")
  out = append(out, "\\b,32-bit sector-")
  goto s37
f38:
s37:
  goto s0
f37:
  // >4	uleshort&0x0040			0x0040			\b,IOCTL-
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x40 == 0x40)) { goto f39 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x0040\t\t\t0x0040\t\t\t\\b,IOCTL-")
  out = append(out, "\\b,IOCTL-")
  goto s0
f39:
  // >4	uleshort&0x0800			0x0800			\b,close media-
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x800 == 0x800)) { goto f40 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x0800\t\t\t0x0800\t\t\t\\b,close media-")
  out = append(out, "\\b,close media-")
  goto s0
f40:
  // >4	uleshort&0x8000			0x8000
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f41 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x8000")
  // >>4	uleshort&0x2000			0x2000			\b,until busy-
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x2000 == 0x2000)) { goto f42 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x2000\t\t\t0x2000\t\t\t\\b,until busy-")
  out = append(out, "\\b,until busy-")
  goto s41
f42:
s41:
  goto s0
f41:
  // >4	uleshort&0x4000			0x4000			\b,control strings-
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x4000 == 0x4000)) { goto f43 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x4000\t\t\t0x4000\t\t\t\\b,control strings-")
  out = append(out, "\\b,control strings-")
  goto s0
f43:
  // >4	uleshort&0x8000			0x8000
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x8000)) { goto f44 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x8000")
  // >>4	uleshort&0x6840			>0			\bsupport
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0x6840 > 0x0)) { goto f45 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x6840\t\t\t>0\t\t\t\\bsupport")
  out = append(out, "\\bsupport")
  goto s44
f45:
s44:
  goto s0
f44:
  // >4	uleshort&0x8000			0x0000
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv)&0x8000 == 0x0)) { goto f46 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">4\tuleshort&0x8000\t\t\t0x0000")
  // >>4	uleshort&0x4842			>0			\bsupport
  off = pageOff + 0x4
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0x4842 > 0x0)) { goto f47 }
  }
  gof = off + 2
  fmt.Printf("matched rule: %s\n", ">>4\tuleshort&0x4842\t\t\t>0\t\t\t\\bsupport")
  out = append(out, "\\bsupport")
  goto s46
f47:
s46:
  goto s0
f46:
  // >0	ubyte				x			\b)
  off = pageOff + 0x0
  gof = off + 1
  fmt.Printf("matched rule: %s\n", ">0\tubyte\t\t\t\tx\t\t\t\\b)")
  out = append(out, "\\b)")
  goto s0
s0:
  goto end
end:
  return out, nil
}

