// this file has been generated by github.com/fasterthanlime/wizardry
// from a set of magic rules. you probably don't want to edit it by hand

package wizbook

import (
  "encoding/binary"
  "github.com/fasterthanlime/wizardry/wizardry"
)

var le binary.ByteOrder = binary.LittleEndian
var be binary.ByteOrder = binary.BigEndian

func readUint8be(tb []byte, off int64) (uint8, bool) {
  if int64(len(tb)) < off+1 {
    return 0, false
  }
  pi := uint8(tb[off])
  return pi, true
}

func readUint8le(tb []byte, off int64) (uint8, bool) {
  if int64(len(tb)) < off+1 {
    return 0, false
  }
  pi := uint8(tb[off])
  return pi, true
}

func readUint16be(tb []byte, off int64) (uint16, bool) {
  if int64(len(tb)) < off+2 {
    return 0, false
  }
  pi := be.Uint16(tb[off:])
  return pi, true
}

func readUint16le(tb []byte, off int64) (uint16, bool) {
  if int64(len(tb)) < off+2 {
    return 0, false
  }
  pi := le.Uint16(tb[off:])
  return pi, true
}

func readUint32be(tb []byte, off int64) (uint32, bool) {
  if int64(len(tb)) < off+4 {
    return 0, false
  }
  pi := be.Uint32(tb[off:])
  return pi, true
}

func readUint32le(tb []byte, off int64) (uint32, bool) {
  if int64(len(tb)) < off+4 {
    return 0, false
  }
  pi := le.Uint32(tb[off:])
  return pi, true
}

func readUint64be(tb []byte, off int64) (uint64, bool) {
  if int64(len(tb)) < off+8 {
    return 0, false
  }
  pi := be.Uint64(tb[off:])
  return pi, true
}

func readUint64le(tb []byte, off int64) (uint64, bool) {
  if int64(len(tb)) < off+8 {
    return 0, false
  }
  pi := le.Uint64(tb[off:])
  return pi, true
}

func IdentifyElfLe(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x10    shortle    0    no file type,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with no file type,
    }

    // >0x10    shortle    1    relocatable,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with relocatable,
    }

    // >0x10    shortle    2    executable,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with executable,
    }

    // >0x10    shortle    3    shared object,
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      // do something with shared object,
    }

    // >0x10    shortle    4    core file
    off = pageOff + 16
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      // do something with core file
    }

    // >0x12    clear    
    off = pageOff + 18
    // uh oh unhandled kind

    // >0x12    shortle    0    no machine,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with no machine,
    }

    // >0x12    shortle    1    AT&T WE32100,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with AT&T WE32100,
    }

    // >0x12    shortle    2    SPARC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with SPARC,
    }

    // >0x12    shortle    3    Intel 80386,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      // do something with Intel 80386,
    }

    // >0x12    shortle    4    Motorola m68k,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      // do something with Motorola m68k,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0    68020,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with 68020,
        }

      }
    }
    // >0x12    shortle    5    Motorola m88k,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5)
    }
    if m1 {
      // do something with Motorola m88k,
    }

    // >0x12    shortle    6    Intel 80486,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6)
    }
    if m1 {
      // do something with Intel 80486,
    }

    // >0x12    shortle    7    Intel 80860,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x7)
    }
    if m1 {
      // do something with Intel 80860,
    }

    // >0x12    shortle    8    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }
    if m1 {
      // do something with MIPS,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    a    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      // do something with MIPS,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    8    
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0&0xf0000000    MIPS-I
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with MIPS-I
        }

        // >>>0x24    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          // do something with MIPS-II
        }

        // >>>0x24    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          // do something with MIPS-III
        }

        // >>>0x24    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          // do something with MIPS-IV
        }

        // >>>0x24    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          // do something with MIPS-V
        }

        // >>>0x24    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          // do something with MIPS32
        }

        // >>>0x24    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          // do something with MIPS64
        }

        // >>>0x24    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          // do something with MIPS32 rel2
        }

        // >>>0x24    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          // do something with MIPS64 rel2
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    0&0xf0000000    MIPS-I
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with MIPS-I
        }

        // >>>0x30    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          // do something with MIPS-II
        }

        // >>>0x30    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          // do something with MIPS-III
        }

        // >>>0x30    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          // do something with MIPS-IV
        }

        // >>>0x30    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          // do something with MIPS-V
        }

        // >>>0x30    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          // do something with MIPS32
        }

        // >>>0x30    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          // do something with MIPS64
        }

        // >>>0x30    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          // do something with MIPS32 rel2
        }

        // >>>0x30    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          // do something with MIPS64 rel2
        }

      }
    }
    // >0x12    shortle    9    Amdahl,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      // do something with Amdahl,
    }

    // >0x12    shortle    a    MIPS (deprecated),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      // do something with MIPS (deprecated),
    }

    // >0x12    shortle    b    RS6000,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb)
    }
    if m1 {
      // do something with RS6000,
    }

    // >0x12    shortle    f    PA-RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xf)
    }
    if m1 {
      // do something with PA-RISC,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x26    shortle    214    2.0
        off = pageOff + 38
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          // do something with 2.0
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x32    shortle    214    2.0
        off = pageOff + 50
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          // do something with 2.0
        }

      }
    }
    // >0x12    shortle    10    nCUBE,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x10)
    }
    if m1 {
      // do something with nCUBE,
    }

    // >0x12    shortle    11    Fujitsu VPP500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x11)
    }
    if m1 {
      // do something with Fujitsu VPP500,
    }

    // >0x12    shortle    12    SPARC32PLUS,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x12)
    }
    if m1 {
      // do something with SPARC32PLUS,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    100&0xffff00    V8+ Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          // do something with V8+ Required,
        }

        // >>>0x24    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with Sun UltraSPARC1 Extensions Required,
        }

        // >>>0x24    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          // do something with HaL R1 Extensions Required,
        }

        // >>>0x24    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          // do something with Sun UltraSPARC3 Extensions Required,
        }

      }
    }
    // >0x12    shortle    13    Intel 80960,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x13)
    }
    if m1 {
      // do something with Intel 80960,
    }

    // >0x12    shortle    14    PowerPC or cisco 4500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x14)
    }
    if m1 {
      // do something with PowerPC or cisco 4500,
    }

    // >0x12    shortle    15    64-bit PowerPC or cisco 7500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x15)
    }
    if m1 {
      // do something with 64-bit PowerPC or cisco 7500,
    }

    // >0x12    shortle    16    IBM S/390,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x16)
    }
    if m1 {
      // do something with IBM S/390,
    }

    // >0x12    shortle    17    Cell SPU,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x17)
    }
    if m1 {
      // do something with Cell SPU,
    }

    // >0x12    shortle    18    cisco SVIP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x18)
    }
    if m1 {
      // do something with cisco SVIP,
    }

    // >0x12    shortle    19    cisco 7200,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x19)
    }
    if m1 {
      // do something with cisco 7200,
    }

    // >0x12    shortle    24    NEC V800 or cisco 12000,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x24)
    }
    if m1 {
      // do something with NEC V800 or cisco 12000,
    }

    // >0x12    shortle    25    Fujitsu FR20,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x25)
    }
    if m1 {
      // do something with Fujitsu FR20,
    }

    // >0x12    shortle    26    TRW RH-32,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x26)
    }
    if m1 {
      // do something with TRW RH-32,
    }

    // >0x12    shortle    27    Motorola RCE,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x27)
    }
    if m1 {
      // do something with Motorola RCE,
    }

    // >0x12    shortle    28    ARM,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x28)
    }
    if m1 {
      // do something with ARM,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    4000000&0xff000000    EABI4
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x4000000)
        }
        if m3 {
          // do something with EABI4
        }

        // >>>0x24    longle    5000000&0xff000000    EABI5
        off = pageOff + 36
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x5000000)
        }
        if m3 {
          // do something with EABI5
        }

      }
    }
    // >0x12    shortle    29    Alpha,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x29)
    }
    if m1 {
      // do something with Alpha,
    }

    // >0x12    shortle    2a    Renesas SH,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2a)
    }
    if m1 {
      // do something with Renesas SH,
    }

    // >0x12    shortle    2b    SPARC V9,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2b)
    }
    if m1 {
      // do something with SPARC V9,
    }

    if m1 {
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with Sun UltraSPARC1 Extensions Required,
        }

        // >>>0x30    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          // do something with HaL R1 Extensions Required,
        }

        // >>>0x30    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          // do something with Sun UltraSPARC3 Extensions Required,
        }

        // >>>0x30    longle    0&0x3    total store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with total store ordering,
        }

        // >>>0x30    longle    1&0x3    partial store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with partial store ordering,
        }

        // >>>0x30    longle    2&0x3    relaxed memory ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with relaxed memory ordering,
        }

      }
    }
    // >0x12    shortle    2c    Siemens Tricore Embedded Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2c)
    }
    if m1 {
      // do something with Siemens Tricore Embedded Processor,
    }

    // >0x12    shortle    2d    Argonaut RISC Core, Argonaut Technologies Inc.,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2d)
    }
    if m1 {
      // do something with Argonaut RISC Core, Argonaut Technologies Inc.,
    }

    // >0x12    shortle    2e    Renesas H8/300,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2e)
    }
    if m1 {
      // do something with Renesas H8/300,
    }

    // >0x12    shortle    2f    Renesas H8/300H,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2f)
    }
    if m1 {
      // do something with Renesas H8/300H,
    }

    // >0x12    shortle    30    Renesas H8S,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x30)
    }
    if m1 {
      // do something with Renesas H8S,
    }

    // >0x12    shortle    31    Renesas H8/500,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x31)
    }
    if m1 {
      // do something with Renesas H8/500,
    }

    // >0x12    shortle    32    IA-64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x32)
    }
    if m1 {
      // do something with IA-64,
    }

    // >0x12    shortle    33    Stanford MIPS-X,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x33)
    }
    if m1 {
      // do something with Stanford MIPS-X,
    }

    // >0x12    shortle    34    Motorola Coldfire,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x34)
    }
    if m1 {
      // do something with Motorola Coldfire,
    }

    // >0x12    shortle    35    Motorola M68HC12,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x35)
    }
    if m1 {
      // do something with Motorola M68HC12,
    }

    // >0x12    shortle    36    Fujitsu MMA,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x36)
    }
    if m1 {
      // do something with Fujitsu MMA,
    }

    // >0x12    shortle    37    Siemens PCP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x37)
    }
    if m1 {
      // do something with Siemens PCP,
    }

    // >0x12    shortle    38    Sony nCPU,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x38)
    }
    if m1 {
      // do something with Sony nCPU,
    }

    // >0x12    shortle    39    Denso NDR1,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x39)
    }
    if m1 {
      // do something with Denso NDR1,
    }

    // >0x12    shortle    3a    Start*Core,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3a)
    }
    if m1 {
      // do something with Start*Core,
    }

    // >0x12    shortle    3b    Toyota ME16,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3b)
    }
    if m1 {
      // do something with Toyota ME16,
    }

    // >0x12    shortle    3c    ST100,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3c)
    }
    if m1 {
      // do something with ST100,
    }

    // >0x12    shortle    3d    Tinyj emb.,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3d)
    }
    if m1 {
      // do something with Tinyj emb.,
    }

    // >0x12    shortle    3e    x86-64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3e)
    }
    if m1 {
      // do something with x86-64,
    }

    // >0x12    shortle    3f    Sony DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3f)
    }
    if m1 {
      // do something with Sony DSP,
    }

    // >0x12    shortle    40    DEC PDP-10,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      // do something with DEC PDP-10,
    }

    // >0x12    shortle    41    DEC PDP-11,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x41)
    }
    if m1 {
      // do something with DEC PDP-11,
    }

    // >0x12    shortle    42    FX66,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x42)
    }
    if m1 {
      // do something with FX66,
    }

    // >0x12    shortle    43    ST9+ 8/16 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x43)
    }
    if m1 {
      // do something with ST9+ 8/16 bit,
    }

    // >0x12    shortle    44    ST7 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x44)
    }
    if m1 {
      // do something with ST7 8 bit,
    }

    // >0x12    shortle    45    MC68HC16,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x45)
    }
    if m1 {
      // do something with MC68HC16,
    }

    // >0x12    shortle    46    MC68HC11,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x46)
    }
    if m1 {
      // do something with MC68HC11,
    }

    // >0x12    shortle    47    MC68HC08,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x47)
    }
    if m1 {
      // do something with MC68HC08,
    }

    // >0x12    shortle    48    MC68HC05,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x48)
    }
    if m1 {
      // do something with MC68HC05,
    }

    // >0x12    shortle    49    SGI SVx or Cray NV1,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x49)
    }
    if m1 {
      // do something with SGI SVx or Cray NV1,
    }

    // >0x12    shortle    4a    ST19 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4a)
    }
    if m1 {
      // do something with ST19 8 bit,
    }

    // >0x12    shortle    4b    Digital VAX,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4b)
    }
    if m1 {
      // do something with Digital VAX,
    }

    // >0x12    shortle    4c    Axis cris,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4c)
    }
    if m1 {
      // do something with Axis cris,
    }

    // >0x12    shortle    4d    Infineon 32-bit embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4d)
    }
    if m1 {
      // do something with Infineon 32-bit embedded,
    }

    // >0x12    shortle    4e    Element 14 64-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4e)
    }
    if m1 {
      // do something with Element 14 64-bit DSP,
    }

    // >0x12    shortle    4f    LSI Logic 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4f)
    }
    if m1 {
      // do something with LSI Logic 16-bit DSP,
    }

    // >0x12    shortle    50    MMIX,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x50)
    }
    if m1 {
      // do something with MMIX,
    }

    // >0x12    shortle    51    Harvard machine-independent,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x51)
    }
    if m1 {
      // do something with Harvard machine-independent,
    }

    // >0x12    shortle    52    SiTera Prism,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x52)
    }
    if m1 {
      // do something with SiTera Prism,
    }

    // >0x12    shortle    53    Atmel AVR 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x53)
    }
    if m1 {
      // do something with Atmel AVR 8-bit,
    }

    // >0x12    shortle    54    Fujitsu FR30,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x54)
    }
    if m1 {
      // do something with Fujitsu FR30,
    }

    // >0x12    shortle    55    Mitsubishi D10V,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x55)
    }
    if m1 {
      // do something with Mitsubishi D10V,
    }

    // >0x12    shortle    56    Mitsubishi D30V,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x56)
    }
    if m1 {
      // do something with Mitsubishi D30V,
    }

    // >0x12    shortle    57    NEC v850,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x57)
    }
    if m1 {
      // do something with NEC v850,
    }

    // >0x12    shortle    58    Renesas M32R,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x58)
    }
    if m1 {
      // do something with Renesas M32R,
    }

    // >0x12    shortle    59    Matsushita MN10300,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x59)
    }
    if m1 {
      // do something with Matsushita MN10300,
    }

    // >0x12    shortle    5a    Matsushita MN10200,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5a)
    }
    if m1 {
      // do something with Matsushita MN10200,
    }

    // >0x12    shortle    5b    picoJava,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5b)
    }
    if m1 {
      // do something with picoJava,
    }

    // >0x12    shortle    5c    OpenRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5c)
    }
    if m1 {
      // do something with OpenRISC,
    }

    // >0x12    shortle    5d    ARC Cores Tangent-A5,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5d)
    }
    if m1 {
      // do something with ARC Cores Tangent-A5,
    }

    // >0x12    shortle    5e    Tensilica Xtensa,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5e)
    }
    if m1 {
      // do something with Tensilica Xtensa,
    }

    // >0x12    shortle    5f    Alphamosaic VideoCore,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5f)
    }
    if m1 {
      // do something with Alphamosaic VideoCore,
    }

    // >0x12    shortle    60    Thompson Multimedia,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      // do something with Thompson Multimedia,
    }

    // >0x12    shortle    61    NatSemi 32k,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x61)
    }
    if m1 {
      // do something with NatSemi 32k,
    }

    // >0x12    shortle    62    Tenor Network TPC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x62)
    }
    if m1 {
      // do something with Tenor Network TPC,
    }

    // >0x12    shortle    63    Trebia SNP 1000,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x63)
    }
    if m1 {
      // do something with Trebia SNP 1000,
    }

    // >0x12    shortle    64    STMicroelectronics ST200,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x64)
    }
    if m1 {
      // do something with STMicroelectronics ST200,
    }

    // >0x12    shortle    65    Ubicom IP2022,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x65)
    }
    if m1 {
      // do something with Ubicom IP2022,
    }

    // >0x12    shortle    66    MAX Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x66)
    }
    if m1 {
      // do something with MAX Processor,
    }

    // >0x12    shortle    67    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      // do something with NatSemi CompactRISC,
    }

    // >0x12    shortle    68    Fujitsu F2MC16,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      // do something with Fujitsu F2MC16,
    }

    // >0x12    shortle    69    TI msp430,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x69)
    }
    if m1 {
      // do something with TI msp430,
    }

    // >0x12    shortle    6a    Analog Devices Blackfin,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6a)
    }
    if m1 {
      // do something with Analog Devices Blackfin,
    }

    // >0x12    shortle    6b    S1C33 Family of Seiko Epson,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6b)
    }
    if m1 {
      // do something with S1C33 Family of Seiko Epson,
    }

    // >0x12    shortle    6c    Sharp embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6c)
    }
    if m1 {
      // do something with Sharp embedded,
    }

    // >0x12    shortle    6d    Arca RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6d)
    }
    if m1 {
      // do something with Arca RISC,
    }

    // >0x12    shortle    6e    PKU-Unity Ltd.,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6e)
    }
    if m1 {
      // do something with PKU-Unity Ltd.,
    }

    // >0x12    shortle    6f    eXcess: 16/32/64-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x6f)
    }
    if m1 {
      // do something with eXcess: 16/32/64-bit,
    }

    // >0x12    shortle    70    Icera Deep Execution Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x70)
    }
    if m1 {
      // do something with Icera Deep Execution Processor,
    }

    // >0x12    shortle    71    Altera Nios II,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x71)
    }
    if m1 {
      // do something with Altera Nios II,
    }

    // >0x12    shortle    72    NatSemi CRX,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x72)
    }
    if m1 {
      // do something with NatSemi CRX,
    }

    // >0x12    shortle    73    Motorola XGATE,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x73)
    }
    if m1 {
      // do something with Motorola XGATE,
    }

    // >0x12    shortle    74    Infineon C16x/XC16x,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x74)
    }
    if m1 {
      // do something with Infineon C16x/XC16x,
    }

    // >0x12    shortle    75    Renesas M16C series,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x75)
    }
    if m1 {
      // do something with Renesas M16C series,
    }

    // >0x12    shortle    76    Microchip dsPIC30F,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x76)
    }
    if m1 {
      // do something with Microchip dsPIC30F,
    }

    // >0x12    shortle    77    Freescale RISC core,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x77)
    }
    if m1 {
      // do something with Freescale RISC core,
    }

    // >0x12    shortle    78    Renesas M32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x78)
    }
    if m1 {
      // do something with Renesas M32C series,
    }

    // >0x12    shortle    83    Altium TSK3000 core,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x83)
    }
    if m1 {
      // do something with Altium TSK3000 core,
    }

    // >0x12    shortle    84    Freescale RS08,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x84)
    }
    if m1 {
      // do something with Freescale RS08,
    }

    // >0x12    shortle    86    Cyan Technology eCOG2,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x86)
    }
    if m1 {
      // do something with Cyan Technology eCOG2,
    }

    // >0x12    shortle    87    Sunplus S+core7 RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x87)
    }
    if m1 {
      // do something with Sunplus S+core7 RISC,
    }

    // >0x12    shortle    88    New Japan Radio (NJR) 24-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x88)
    }
    if m1 {
      // do something with New Japan Radio (NJR) 24-bit DSP,
    }

    // >0x12    shortle    89    Broadcom VideoCore III,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x89)
    }
    if m1 {
      // do something with Broadcom VideoCore III,
    }

    // >0x12    shortle    8a    LatticeMico32,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8a)
    }
    if m1 {
      // do something with LatticeMico32,
    }

    // >0x12    shortle    8b    Seiko Epson C17 family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8b)
    }
    if m1 {
      // do something with Seiko Epson C17 family,
    }

    // >0x12    shortle    8c    TI TMS320C6000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8c)
    }
    if m1 {
      // do something with TI TMS320C6000 DSP family,
    }

    // >0x12    shortle    8d    TI TMS320C2000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8d)
    }
    if m1 {
      // do something with TI TMS320C2000 DSP family,
    }

    // >0x12    shortle    8e    TI TMS320C55x DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8e)
    }
    if m1 {
      // do something with TI TMS320C55x DSP family,
    }

    // >0x12    shortle    a0    STMicroelectronics 64bit VLIW DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa0)
    }
    if m1 {
      // do something with STMicroelectronics 64bit VLIW DSP,
    }

    // >0x12    shortle    a1    Cypress M8C,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa1)
    }
    if m1 {
      // do something with Cypress M8C,
    }

    // >0x12    shortle    a2    Renesas R32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa2)
    }
    if m1 {
      // do something with Renesas R32C series,
    }

    // >0x12    shortle    a3    NXP TriMedia family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa3)
    }
    if m1 {
      // do something with NXP TriMedia family,
    }

    // >0x12    shortle    a4    QUALCOMM DSP6,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa4)
    }
    if m1 {
      // do something with QUALCOMM DSP6,
    }

    // >0x12    shortle    a5    Intel 8051 and variants,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa5)
    }
    if m1 {
      // do something with Intel 8051 and variants,
    }

    // >0x12    shortle    a6    STMicroelectronics STxP7x family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa6)
    }
    if m1 {
      // do something with STMicroelectronics STxP7x family,
    }

    // >0x12    shortle    a7    Andes embedded RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa7)
    }
    if m1 {
      // do something with Andes embedded RISC,
    }

    // >0x12    shortle    a8    Cyan eCOG1X family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa8)
    }
    if m1 {
      // do something with Cyan eCOG1X family,
    }

    // >0x12    shortle    a9    Dallas MAXQ30,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa9)
    }
    if m1 {
      // do something with Dallas MAXQ30,
    }

    // >0x12    shortle    aa    New Japan Radio (NJR) 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xaa)
    }
    if m1 {
      // do something with New Japan Radio (NJR) 16-bit DSP,
    }

    // >0x12    shortle    ab    M2000 Reconfigurable RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xab)
    }
    if m1 {
      // do something with M2000 Reconfigurable RISC,
    }

    // >0x12    shortle    ac    Cray NV2 vector architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xac)
    }
    if m1 {
      // do something with Cray NV2 vector architecture,
    }

    // >0x12    shortle    ad    Renesas RX family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xad)
    }
    if m1 {
      // do something with Renesas RX family,
    }

    // >0x12    shortle    ae    META,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xae)
    }
    if m1 {
      // do something with META,
    }

    // >0x12    shortle    af    MCST Elbrus,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xaf)
    }
    if m1 {
      // do something with MCST Elbrus,
    }

    // >0x12    shortle    b0    Cyan Technology eCOG16 family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb0)
    }
    if m1 {
      // do something with Cyan Technology eCOG16 family,
    }

    // >0x12    shortle    b1    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb1)
    }
    if m1 {
      // do something with NatSemi CompactRISC,
    }

    // >0x12    shortle    b2    Freescale Extended Time Processing Unit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb2)
    }
    if m1 {
      // do something with Freescale Extended Time Processing Unit,
    }

    // >0x12    shortle    b3    Infineon SLE9X,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb3)
    }
    if m1 {
      // do something with Infineon SLE9X,
    }

    // >0x12    shortle    b4    Intel L1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb4)
    }
    if m1 {
      // do something with Intel L1OM,
    }

    // >0x12    shortle    b5    Intel K1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb5)
    }
    if m1 {
      // do something with Intel K1OM,
    }

    // >0x12    shortle    b7    ARM aarch64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb7)
    }
    if m1 {
      // do something with ARM aarch64,
    }

    // >0x12    shortle    b9    Atmel 32-bit family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xb9)
    }
    if m1 {
      // do something with Atmel 32-bit family,
    }

    // >0x12    shortle    ba    STMicroeletronics STM8 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xba)
    }
    if m1 {
      // do something with STMicroeletronics STM8 8-bit,
    }

    // >0x12    shortle    bb    Tilera TILE64,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbb)
    }
    if m1 {
      // do something with Tilera TILE64,
    }

    // >0x12    shortle    bc    Tilera TILEPro,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbc)
    }
    if m1 {
      // do something with Tilera TILEPro,
    }

    // >0x12    shortle    bd    Xilinx MicroBlaze 32-bit RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbd)
    }
    if m1 {
      // do something with Xilinx MicroBlaze 32-bit RISC,
    }

    // >0x12    shortle    be    NVIDIA CUDA architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbe)
    }
    if m1 {
      // do something with NVIDIA CUDA architecture,
    }

    // >0x12    shortle    bf    Tilera TILE-Gx,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbf)
    }
    if m1 {
      // do something with Tilera TILE-Gx,
    }

    // >0x12    shortle    c5    Renesas RL78 family,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xc5)
    }
    if m1 {
      // do something with Renesas RL78 family,
    }

    // >0x12    shortle    c7    Renesas 78K0R,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xc7)
    }
    if m1 {
      // do something with Renesas 78K0R,
    }

    // >0x12    shortle    1057    AVR (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1057)
    }
    if m1 {
      // do something with AVR (unofficial),
    }

    // >0x12    shortle    1059    MSP430 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1059)
    }
    if m1 {
      // do something with MSP430 (unofficial),
    }

    // >0x12    shortle    1223    Adapteva Epiphany (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1223)
    }
    if m1 {
      // do something with Adapteva Epiphany (unofficial),
    }

    // >0x12    shortle    2530    Morpho MT (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x2530)
    }
    if m1 {
      // do something with Morpho MT (unofficial),
    }

    // >0x12    shortle    3330    FR30 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3330)
    }
    if m1 {
      // do something with FR30 (unofficial),
    }

    // >0x12    shortle    3426    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x3426)
    }
    if m1 {
      // do something with OpenRISC (obsolete),
    }

    // >0x12    shortle    4688    Infineon C166 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4688)
    }
    if m1 {
      // do something with Infineon C166 (unofficial),
    }

    // >0x12    shortle    5441    Cygnus FRV (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5441)
    }
    if m1 {
      // do something with Cygnus FRV (unofficial),
    }

    // >0x12    shortle    5aa5    DLX (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x5aa5)
    }
    if m1 {
      // do something with DLX (unofficial),
    }

    // >0x12    shortle    7650    Cygnus D10V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x7650)
    }
    if m1 {
      // do something with Cygnus D10V (unofficial),
    }

    // >0x12    shortle    7676    Cygnus D30V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x7676)
    }
    if m1 {
      // do something with Cygnus D30V (unofficial),
    }

    // >0x12    shortle    8217    Ubicom IP2xxx (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8217)
    }
    if m1 {
      // do something with Ubicom IP2xxx (unofficial),
    }

    // >0x12    shortle    8472    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8472)
    }
    if m1 {
      // do something with OpenRISC (obsolete),
    }

    // >0x12    shortle    9025    Cygnus PowerPC (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9025)
    }
    if m1 {
      // do something with Cygnus PowerPC (unofficial),
    }

    // >0x12    shortle    9026    Alpha (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9026)
    }
    if m1 {
      // do something with Alpha (unofficial),
    }

    // >0x12    shortle    9041    Cygnus M32R (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9041)
    }
    if m1 {
      // do something with Cygnus M32R (unofficial),
    }

    // >0x12    shortle    9080    Cygnus V850 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x9080)
    }
    if m1 {
      // do something with Cygnus V850 (unofficial),
    }

    // >0x12    shortle    a390    IBM S/390 (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xa390)
    }
    if m1 {
      // do something with IBM S/390 (obsolete),
    }

    // >0x12    shortle    abc7    Old Xtensa (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xabc7)
    }
    if m1 {
      // do something with Old Xtensa (unofficial),
    }

    // >0x12    shortle    ad45    xstormy16 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xad45)
    }
    if m1 {
      // do something with xstormy16 (unofficial),
    }

    // >0x12    shortle    baab    Old MicroBlaze (unofficial),,
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbaab)
    }
    if m1 {
      // do something with Old MicroBlaze (unofficial),,
    }

    // >0x12    shortle    beef    Cygnus MN10300 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xbeef)
    }
    if m1 {
      // do something with Cygnus MN10300 (unofficial),
    }

    // >0x12    shortle    dead    Cygnus MN10200 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xdead)
    }
    if m1 {
      // do something with Cygnus MN10200 (unofficial),
    }

    // >0x12    shortle    f00d    Toshiba MeP (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xf00d)
    }
    if m1 {
      // do something with Toshiba MeP (unofficial),
    }

    // >0x12    shortle    feb0    Renesas M32C (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfeb0)
    }
    if m1 {
      // do something with Renesas M32C (unofficial),
    }

    // >0x12    shortle    feba    Vitesse IQ2000 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfeba)
    }
    if m1 {
      // do something with Vitesse IQ2000 (unofficial),
    }

    // >0x12    shortle    febb    NIOS (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfebb)
    }
    if m1 {
      // do something with NIOS (unofficial),
    }

    // >0x12    shortle    feed    Moxie (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xfeed)
    }
    if m1 {
      // do something with Moxie (unofficial),
    }

    // >0x12    default    
    off = pageOff + 18
    // uh oh unhandled kind

    if m1 {
      // >>0x12    shortle    0    *unknown arch 0x%x*
      off = pageOff + 18
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with *unknown arch 0x%x*
      }

    }
    // >0x14    longle    0    invalid version
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with invalid version
    }

    // >0x14    longle    1    version 1
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with version 1
    }

  }
  return outStrings, nil
}

func IdentifyLotusCells(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x0    ulongbe    6000800    \b, cell range
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x6000800)
    }
    if m1 {
      // do something with \b, cell range
    }

    if m1 {
      // >>0x4    ulongle    0    
      off = pageOff + 4
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) != 0x0)
      }

      if m2 {
        // >>>0x4    ushortle    0    \b%d,
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with \b%d,
        }

        // >>>0x6    ushortle    0    \b%d-
        off = pageOff + 6
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with \b%d-
        }

      }
      // >>0x8    ushortle    0    \b%d,
      off = pageOff + 8
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d,
      }

      // >>0xa    ushortle    0    \b%d
      off = pageOff + 10
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d
      }

    }
  }
  return outStrings, nil
}

func IdentifyIcoEntry(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    1    \b, %d planes
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %d planes
    }

    // >0x6    ushortle    1    \b, %d bits/pixel
    off = pageOff + 6
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %d bits/pixel
    }

  }
  return outStrings, nil
}

func Identify(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  // 0x0    string    "\u007fELF"    ELF
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    bytele    0    invalid class
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with invalid class
    }

    // >0x4    bytele    1    32-bit
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with 32-bit
    }

    // >0x4    bytele    2    64-bit
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with 64-bit
    }

    // >0x5    bytele    0    invalid byte order
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with invalid byte order
    }

    // >0x5    bytele    1    LSB
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with LSB
    }

    if m1 {
      // >>0x0    use   elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x5    bytele    2    MSB
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with MSB
    }

    if m1 {
      // >>0x0    use   \^elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x4    bytele    80    
    off = pageOff + 4
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x80)
    }

    if m1 {
      // >>0x8    string    ">\x00"    (%s)
      off = pageOff + 8
      // uh oh unhandled kind

    }
    // >0x8    string    "\x00"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    0    (SYSV)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with (SYSV)
      }

      // >>0x7    bytele    1    (HP-UX)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        // do something with (HP-UX)
      }

      // >>0x7    bytele    2    (NetBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        // do something with (NetBSD)
      }

      // >>0x7    bytele    3    (GNU/Linux)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x3)
      }
      if m2 {
        // do something with (GNU/Linux)
      }

      // >>0x7    bytele    4    (GNU/Hurd)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x4)
      }
      if m2 {
        // do something with (GNU/Hurd)
      }

      // >>0x7    bytele    5    (86Open)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x5)
      }
      if m2 {
        // do something with (86Open)
      }

      // >>0x7    bytele    6    (Solaris)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x6)
      }
      if m2 {
        // do something with (Solaris)
      }

      // >>0x7    bytele    7    (Monterey)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x7)
      }
      if m2 {
        // do something with (Monterey)
      }

      // >>0x7    bytele    8    (IRIX)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        // do something with (IRIX)
      }

      // >>0x7    bytele    9    (FreeBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x9)
      }
      if m2 {
        // do something with (FreeBSD)
      }

      // >>0x7    bytele    a    (Tru64)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xa)
      }
      if m2 {
        // do something with (Tru64)
      }

      // >>0x7    bytele    b    (Novell Modesto)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xb)
      }
      if m2 {
        // do something with (Novell Modesto)
      }

      // >>0x7    bytele    c    (OpenBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xc)
      }
      if m2 {
        // do something with (OpenBSD)
      }

    }
    // >0x8    string    "\x02"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    d    (OpenVMS)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xd)
      }
      if m2 {
        // do something with (OpenVMS)
      }

      // >>0x7    bytele    61    (ARM)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x61)
      }
      if m2 {
        // do something with (ARM)
      }

      // >>0x7    bytele    ff    (embedded)
      off = pageOff + 7
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        // do something with (embedded)
      }

    }
  }
  // 0x0    string    "@"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1    string    " echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

    // >0x1    string    "echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

    // >0x1    string    "rem"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

    // >0x1    string    "set "    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

  }
  // 0x64    search/0xffff    "rxfuncadd"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x64    search/0xffff    "say"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x0    shortle    166    MS Windows COFF MIPS R4000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x166)
  }
  if m0 {
    // do something with MS Windows COFF MIPS R4000 object file
  }

  // 0x0    shortle    184    MS Windows COFF Alpha object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x184)
  }
  if m0 {
    // do something with MS Windows COFF Alpha object file
  }

  // 0x0    shortle    268    MS Windows COFF Motorola 68000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x268)
  }
  if m0 {
    // do something with MS Windows COFF Motorola 68000 object file
  }

  // 0x0    shortle    1f0    MS Windows COFF PowerPC object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x1f0)
  }
  if m0 {
    // do something with MS Windows COFF PowerPC object file
  }

  // 0x0    shortle    290    MS Windows COFF PA-RISC object file
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x290)
  }
  if m0 {
    // do something with MS Windows COFF PA-RISC object file
  }

  // 0x0    string    "MZ"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x18    shortle    40    MS-DOS executable
    off = pageOff + 24
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) < 0x40)
    }
    if m1 {
      // do something with MS-DOS executable
    }

    // >0x18    shortle    3f    
    off = pageOff + 24
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x3f)
    }

    if m1 {
      // >>(0x3c.longle)    string    "PE\x00\x00"    PE
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+24)    shortle    10b    \b32 executable
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }
        if m3 {
          // do something with \b32 executable
        }

        // >>>(0x3c.longle+24)    shortle    20b    \b32+ executable
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }
        if m3 {
          // do something with \b32+ executable
        }

        // >>>(0x3c.longle+24)    shortle    107    ROM image
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x107)
        }
        if m3 {
          // do something with ROM image
        }

        // >>>(0x3c.longle+24)    default    Unknown PE signature
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with 0x%x
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x2000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          // do something with (DLL)
        }

        // >>>(0x3c.longle+92)    shortle    1    (native)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with (native)
        }

        // >>>(0x3c.longle+92)    shortle    2    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with (GUI)
        }

        // >>>(0x3c.longle+92)    shortle    3    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with (console)
        }

        // >>>(0x3c.longle+92)    shortle    7    (POSIX)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          // do something with (POSIX)
        }

        // >>>(0x3c.longle+92)    shortle    9    (Windows CE)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x9)
        }
        if m3 {
          // do something with (Windows CE)
        }

        // >>>(0x3c.longle+92)    shortle    a    (EFI application)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xa)
        }
        if m3 {
          // do something with (EFI application)
        }

        // >>>(0x3c.longle+92)    shortle    b    (EFI boot service driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xb)
        }
        if m3 {
          // do something with (EFI boot service driver)
        }

        // >>>(0x3c.longle+92)    shortle    c    (EFI runtime driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xc)
        }
        if m3 {
          // do something with (EFI runtime driver)
        }

        // >>>(0x3c.longle+92)    shortle    d    (EFI ROM)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xd)
        }
        if m3 {
          // do something with (EFI ROM)
        }

        // >>>(0x3c.longle+92)    shortle    e    (XBOX)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xe)
        }
        if m3 {
          // do something with (XBOX)
        }

        // >>>(0x3c.longle+92)    shortle    f    (Windows boot application)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xf)
        }
        if m3 {
          // do something with (Windows boot application)
        }

        // >>>(0x3c.longle+92)    default    (Unknown subsystem
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x0    shortle    0    0x%x)
          off = pageOff + 0
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with 0x%x)
          }

        }
        // >>>(0x3c.longle+4)    shortle    14c    Intel 80386
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x14c)
        }
        if m3 {
          // do something with Intel 80386
        }

        // >>>(0x3c.longle+4)    shortle    166    MIPS R4000
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x166)
        }
        if m3 {
          // do something with MIPS R4000
        }

        // >>>(0x3c.longle+4)    shortle    168    MIPS R10000
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x168)
        }
        if m3 {
          // do something with MIPS R10000
        }

        // >>>(0x3c.longle+4)    shortle    184    Alpha
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x184)
        }
        if m3 {
          // do something with Alpha
        }

        // >>>(0x3c.longle+4)    shortle    1a2    Hitachi SH3
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1a2)
        }
        if m3 {
          // do something with Hitachi SH3
        }

        // >>>(0x3c.longle+4)    shortle    1a6    Hitachi SH4
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1a6)
        }
        if m3 {
          // do something with Hitachi SH4
        }

        // >>>(0x3c.longle+4)    shortle    1c0    ARM
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1c0)
        }
        if m3 {
          // do something with ARM
        }

        // >>>(0x3c.longle+4)    shortle    1c2    ARM Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1c2)
        }
        if m3 {
          // do something with ARM Thumb
        }

        // >>>(0x3c.longle+4)    shortle    1c4    ARMv7 Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1c4)
        }
        if m3 {
          // do something with ARMv7 Thumb
        }

        // >>>(0x3c.longle+4)    shortle    1f0    PowerPC
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1f0)
        }
        if m3 {
          // do something with PowerPC
        }

        // >>>(0x3c.longle+4)    shortle    200    Intel Itanium
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with Intel Itanium
        }

        // >>>(0x3c.longle+4)    shortle    266    MIPS16
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x266)
        }
        if m3 {
          // do something with MIPS16
        }

        // >>>(0x3c.longle+4)    shortle    268    Motorola 68000
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x268)
        }
        if m3 {
          // do something with Motorola 68000
        }

        // >>>(0x3c.longle+4)    shortle    290    PA-RISC
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x290)
        }
        if m3 {
          // do something with PA-RISC
        }

        // >>>(0x3c.longle+4)    shortle    366    MIPSIV
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x366)
        }
        if m3 {
          // do something with MIPSIV
        }

        // >>>(0x3c.longle+4)    shortle    466    MIPS16 with FPU
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x466)
        }
        if m3 {
          // do something with MIPS16 with FPU
        }

        // >>>(0x3c.longle+4)    shortle    ebc    EFI byte code
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xebc)
        }
        if m3 {
          // do something with EFI byte code
        }

        // >>>(0x3c.longle+4)    shortle    8664    x86-64
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8664)
        }
        if m3 {
          // do something with x86-64
        }

        // >>>(0x3c.longle+4)    shortle    c0ee    MSIL
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xc0ee)
        }
        if m3 {
          // do something with MSIL
        }

        // >>>(0x3c.longle+4)    default    Unknown processor type
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with 0x%x
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x200    (stripped to external PDB)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          // do something with (stripped to external PDB)
        }

        // >>>(0x3c.longle+22)    shortle    0&0x1000    system file
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          // do something with system file
        }

        // >>>(0x3c.longle+24)    shortle    10b    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }

        if m3 {
          // >>>>(0x3c.longle+232)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with Mono/.Net assembly
          }

        }
        // >>>(0x3c.longle+24)    shortle    20b    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }

        if m3 {
          // >>>>(0x3c.longle+248)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with Mono/.Net assembly
          }

        }
        // >>>(0x8.shortle*16)    string    "32STUB"    \b, 32rtm DOS extender
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x8.shortle*16)    string    "32STUB"    \b, for MS Windows
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    string    "UPX0"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    search/0x140    "PEC2"    \b, PECompact2 compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    search/0x140    "UPX2"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0x10.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".idata"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xe.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xe.longle+(-4))    string    "ZZ0"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xe.longle+(-4))    string    "ZZ1"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".rsrc"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle+(-4))    string    "a\\\x04\x05"    \b, WinHKI self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xf.longle+(-4))    string    "Rar!"    \b, RAR self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xf.longle+(-4))    search/0x3000    "MSCF"    \b, InstallShield self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xf.longle+(-4))    search/0x20    "Nullsoft"    \b, Nullsoft Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".data"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle)    string    "WEXTRACT"    \b, MS CAB-Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".petite\x00"    \b, Petite compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(0x3c.longle+247)    bytele    0    
          // uh oh indirect offset
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }

          if m4 {
            // >>>>>(&0x104.longle+(-4))    string    "=!sfx!"    \b, ACE self-extracting archive
            // uh oh indirect offset
            // uh oh unhandled kind

          }
        }
        // >>>(0x3c.longle+248)    search/0x140    ".WISE"    \b, WISE installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    search/0x140    ".dz\x00\x00\x00"    \b, Dzip self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>&(0x3c.longle+248)    search/0x100    "_winzip_"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>&(0x3c.longle+248)    search/0x100    "SharedD"    \b, Microsoft Installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>0x30    string    "Inno"    \b, InnoSetup self-extracting archive
        off = pageOff + 48
        // uh oh unhandled kind

      }
      // >>(0x3c.longle)    string    "PE\x00\x00"    MS-DOS executable
      // uh oh indirect offset
      // uh oh unhandled kind

      // >>(0x3c.longle)    string    "NE"    \b, NE
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+54)    bytele    1    for OS/2 1.x
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with for OS/2 1.x
        }

        // >>>(0x3c.longle+54)    bytele    2    for MS Windows 3.x
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with for MS Windows 3.x
        }

        // >>>(0x3c.longle+54)    bytele    3    for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with for MS-DOS
        }

        // >>>(0x3c.longle+54)    bytele    4    for Windows 386
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          // do something with for Windows 386
        }

        // >>>(0x3c.longle+54)    bytele    5    for Borland Operating System Services
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x5)
        }
        if m3 {
          // do something with for Borland Operating System Services
        }

        // >>>(0x3c.longle+54)    default    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(0x3c.longle+54)    bytele    0    (unknown OS %x)
          // uh oh indirect offset
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with (unknown OS %x)
          }

        }
        // >>>(0x3c.longle+54)    bytele    81    for MS-DOS, Phar Lap DOS extender
        // uh oh indirect offset
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (uint64(iv) == 0x81)
        }
        if m3 {
          // do something with for MS-DOS, Phar Lap DOS extender
        }

        // >>>(0x3c.longle+12)    shortle    8002&0x8003    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8002)
        }
        if m3 {
          // do something with (DLL)
        }

        // >>>(0x3c.longle+12)    shortle    8001&0x8003    (driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          // do something with (driver)
        }

        // >>>&(&0x24.shortle-1)    string    "ARJSFX"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+112)    search/0x80    "WinZip(R) Self-Extractor"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind

      }
      // >>(0x3c.longle)    string    "LX\x00\x00"    \b, LX
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) < 0x1)
        }
        if m3 {
          // do something with (unknown OS)
        }

        // >>>(0x3c.longle+10)    shortle    1    for OS/2
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with for OS/2
        }

        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with for MS Windows
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with for DOS
        }

        // >>>(0x3c.longle+10)    shortle    3    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x3)
        }
        if m3 {
          // do something with (unknown OS)
        }

        // >>>(0x3c.longle+16)    longle    8000&0x28000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x8000)
        }
        if m3 {
          // do something with (DLL)
        }

        // >>>(0x3c.longle+16)    longle    0&0x20000    (device driver)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          // do something with (device driver)
        }

        // >>>(0x3c.longle+16)    longle    300&0x300    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x300)
        }
        if m3 {
          // do something with (GUI)
        }

        // >>>(0x3c.longle+16)    longle    300&0x28300    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x300)
        }
        if m3 {
          // do something with (console)
        }

        // >>>(0x3c.longle+8)    shortle    1    i80286
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with i80286
        }

        // >>>(0x3c.longle+8)    shortle    2    i80386
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with i80386
        }

        // >>>(0x3c.longle+8)    shortle    3    i80486
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with i80486
        }

        // >>>(0x8.shortle*16)    string    "emx"    \b, emx
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x1    string    "x"    %s
          off = pageOff + 1
          // uh oh unhandled kind

        }
        // >>>&(&0x54.longle-3)    string    "arjsfx"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

      }
      // >>(0x3c.longle)    string    "W3"    \b, W3 for MS Windows
      // uh oh indirect offset
      // uh oh unhandled kind

      // >>(0x3c.longle)    string    "LE\x00\x00"    \b, LE executable
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }

        if m3 {
          // >>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind

          // >>>>0x240    search/0x200    "WATCOM C/C++"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind

          // >>>>0x440    search/0x100    "CauseWay DOS Extender"    for MS-DOS, CauseWay DOS extender
          off = pageOff + 1088
          // uh oh unhandled kind

          // >>>>0x40    search/0x40    "PMODE/W"    for MS-DOS, PMODE/W DOS extender
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>0x40    search/0x40    "STUB/32A"    for MS-DOS, DOS/32A DOS extender (stub)
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>0x40    search/0x80    "STUB/32C"    for MS-DOS, DOS/32A DOS extender (configurable stub)
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>0x40    search/0x80    "DOS/32A"    for MS-DOS, DOS/32A DOS extender (embedded)
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>&0x24    longle    50    
          off = pageOff + 36
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) < 0x50)
          }

          if m4 {
            // >>>>>(&0x4c.longle)    string    "\xfc\xb8WATCOM"    
            // uh oh indirect offset
            // uh oh unhandled kind

            if m5 {
              // >>>>>>&0x0    search/0x8    "3\xdbf\xb9"    \b, 32Lite compressed
              off = pageOff + 0
              // uh oh unhandled kind

            }
          }
        }
        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with for MS Windows
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with for DOS
        }

        // >>>(0x3c.longle+10)    shortle    4    for MS Windows (VxD)
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          // do something with for MS Windows (VxD)
        }

        // >>>(&0x7c.longle+38)    string    "UPX"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>&(&0x54.longle-3)    string    "UNACE"    \b, ACE self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

      }
      // >>0x3c    longle    20000000    
      off = pageOff + 60
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x20000000)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    \b, MZ for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }
        if m3 {
          // do something with \b, MZ for MS-DOS
        }

      }
    }
    // >0x2    longle    0    
    off = pageOff + 2
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }

    if m1 {
      // >>0x18    shortle    40    
      off = pageOff + 24
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) < 0x40)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    
        // uh oh indirect offset
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }

        if m3 {
          // >>>>&(0x2.shortle-514)    string    "LE"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x-2    string    "BW"    \b, MZ for MS-DOS
            off = pageOff + -2
            // uh oh unhandled kind

          }
          // >>>>&(0x2.shortle-514)    string    "LE"    \b, LE
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
            off = pageOff + 576
            // uh oh unhandled kind

          }
          // >>>>&(0x2.shortle-514)    string    "BW"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    \b, LE for MS-DOS, DOS4GW DOS extender (embedded)
            off = pageOff + 576
            // uh oh unhandled kind

            // >>>>>0x240    search/0x100    "!DOS/4G"    \b, BW collection for MS-DOS
            off = pageOff + 576
            // uh oh unhandled kind

          }
        }
      }
    }
    // >(0x4.shortle*512)    shortle    14c    \b, COFF
    // uh oh indirect offset
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x14c)
    }
    if m1 {
      // do something with \b, COFF
    }

    if m1 {
      // >>(0x8.shortle*16)    string    "go32stub"    for MS-DOS, DJGPP go32 DOS extender
      // uh oh indirect offset
      // uh oh unhandled kind

      // >>(0x8.shortle*16)    string    "emx"    
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>&0x1    string    "x"    for DOS, Win or OS/2, emx %s
        off = pageOff + 1
        // uh oh unhandled kind

      }
      // >>&(&0x42.longle-3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x26    string    "UPX"    \b, UPX compressed
        off = pageOff + 38
        // uh oh unhandled kind

      }
      // >>&0x2c    search/0xa0    ".text"    
      off = pageOff + 44
      // uh oh unhandled kind

      if m2 {
        // >>>&0xb    longle    2000    
        off = pageOff + 11
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x2000)
        }

        if m3 {
          // >>>>&0x0    longle    6000    \b, 32lite compressed
          off = pageOff + 0
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x6000)
          }
          if m4 {
            // do something with \b, 32lite compressed
          }

        }
      }
    }
    // >(0x8.shortle*16)    string    "$WdX"    \b, WDos/X DOS extender
    // uh oh indirect offset
    // uh oh unhandled kind

    // >0x35    string    "\x8e\xc0\xb9\b\x00\xf3\xa5Ju\xeb\x8eÎ\xd83\xff\xbe0\x00\x05"    \b, aPack compressed
    off = pageOff + 53
    // uh oh unhandled kind

    // >0xe7    string    "LH/2 "    Self-Extract \b, %s
    off = pageOff + 231
    // uh oh unhandled kind

    // >0x1c    string    "UC2X"    \b, UCEXE compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "WWP "    \b, WWPACK compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "RJSX"    \b, ARJ self-extracting archive
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "diet"    \b, diet compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "LZ09"    \b, LZEXE v0.90 compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "LZ91"    \b, LZEXE v0.91 compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "tz"    \b, TinyProg compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1e    string    "Copyright 1989-1990 PKWARE Inc."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind

    // >0x1e    string    "PKLITE Copr."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind

    // >0x20    search/0xe0    "aRJsfX"    \b, ARJ self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind

    // >0x20    string    "AIN"    
    off = pageOff + 32
    // uh oh unhandled kind

    if m1 {
      // >>0x23    string    "2"    \b, AIN 2.x compressed
      off = pageOff + 35
      // uh oh unhandled kind

      // >>0x23    string    "<2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind

      // >>0x23    string    ">2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind

    }
    // >0x24    string    "LHa's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x24    string    "LHA's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x24    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x24    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x20    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind

    // >0x40    string    "aPKG"    \b, aPackage self-extracting archive
    off = pageOff + 64
    // uh oh unhandled kind

    // >0x64    string    "W Collis\x00\x00"    \b, Compack compressed
    off = pageOff + 100
    // uh oh unhandled kind

    // >0x7a    string    "Windows self-extracting ZIP"    \b, ZIP self-extracting archive
    off = pageOff + 122
    // uh oh unhandled kind

    if m1 {
      // >>&0xf4    search/0x140    "\x00@\x01\x00"    
      off = pageOff + 244
      // uh oh unhandled kind

      if m2 {
        // >>>(&0x0.longle+(4))    string    "MSCF"    \b, WinHKI CAB self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

      }
    }
    // >0x666    string    "-lh5-"    \b, LHa self-extracting archive v2.13S
    off = pageOff + 1638
    // uh oh unhandled kind

    // >0x17888    string    "Rar!"    \b, RAR self-extracting archive
    off = pageOff + 96392
    // uh oh unhandled kind

    // >(0x4.shortle*512)    longle    0    
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>&(0x2.shortle-517)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x0    string    "PK\x03\x04"    \b, ZIP self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "Rar!"    \b, RAR self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x11"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x12"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x17"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x18"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x7    search/0x190    "**ACE**"    \b, ACE self-extracting archive
        off = pageOff + 7
        // uh oh unhandled kind

        // >>>&0x0    search/0x480    "UC2SFX Header"    \b, UC2 self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
    // >(0x8.shortle*16)    search/0x20    "PKSFX"    \b, ZIP self-extracting archive (PKZIP)
    // uh oh indirect offset
    // uh oh unhandled kind

    // >0xc289    string    "y\xff\x80\xffv\xff"    \b, CODEC archive v3.21
    off = pageOff + 49801
    // uh oh unhandled kind

    if m1 {
      // >>0xc2a0    shortle    1    \b, 1 file
      off = pageOff + 49824
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        // do something with \b, 1 file
      }

      // >>0xc2a0    shortle    1    \b, %u files
      off = pageOff + 49824
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x1)
      }
      if m2 {
        // do something with \b, %u files
      }

    }
  }
  // 0x0    string    "KCF"    FreeDOS KEYBoard Layout collection
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, version 0x%x
    }

    // >0x6    ubytele    0    
    off = pageOff + 6
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x7    string    ">\x00"    \b, author=%-.14s
      off = pageOff + 7
      // uh oh unhandled kind

      // >>0x7    search/0xfe    "\xff"    \b, info=
      off = pageOff + 7
      // uh oh unhandled kind

      if m2 {
        // >>>&0x0    string    "x"    \b%-.15s
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    string    "KLF"    FreeDOS KEYBoard Layout file
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, version 0x%x
    }

    // >0x5    ubytele    0    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x8    string    "x"    \b, name=%-.2s
      off = pageOff + 8
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "\xffKEYB   \x00\x00\x00\x00"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "\x00\x00\x00\x00`\x04\xf0"    MS-DOS KEYBoard Layout file
    off = pageOff + 12
    // uh oh unhandled kind

  }
  // 0x0    uquadle    ffffffff&0x7a0ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0xffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    513c00000000012    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x513c00000000012)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    32f28000ffff0016    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x32f28000ffff0016)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7f00000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x7f00000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    1600000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x1600000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    bf708c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0xbf708c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7bd08c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x7bd08c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    ubytele    8c    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0x8c)
  }

  if m0 {
    // >0x4    string    "O===="    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "MAIN"    
      off = pageOff + 5
      // uh oh unhandled kind

      if m2 {
        // >>>0x4    ubytele    d    DOS executable (COM, 0x8C-variant)
        off = pageOff + 4
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) > 0xd)
        }
        if m3 {
          // do something with DOS executable (COM, 0x8C-variant)
        }

      }
    }
  }
  // 0x0    ulongle    ffff10eb    DR-DOS executable (COM)
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0xffff10eb)
  }
  if m0 {
    // do something with DR-DOS executable (COM)
  }

  // 0x0    ushortbe    eb00&0xeb8d    
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (int64(int16(iv)) > 0xeb00)
  }

  // 0x0    bytele    eb    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0xeb)
  }

  if m0 {
    // >0x1    bytele    -1    
    off = pageOff + 1
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > -1)
    }

    if m1 {
      // >>(0x1.bytele+2)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    bytele    e9    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0xe9)
  }

  if m0 {
    // >0x1    shortle    -1    
    off = pageOff + 1
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > -1)
    }

    if m1 {
      // >>(0x1.shortle+3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
    // >0x1    shortle    -103    
    off = pageOff + 1
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) < -259)
    }

    if m1 {
      // >>(0x1.shortle+65539)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    ubytele    b8    
  off = pageOff + 0
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (uint64(iv) == 0xb8)
  }

  if m0 {
    // >0x0    string    "\xb8\xc0\a\x8e"    
    off = pageOff + 0
    // uh oh unhandled kind

    if m1 {
      // >>0x1    longle    21cd4cfe&0xfffffffe    COM executable (32-bit COMBOOT
      off = pageOff + 1
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) == 0x21cd4cfe)
      }
      if m2 {
        // do something with COM executable (32-bit COMBOOT
      }

      if m2 {
        // >>>0x1    longle    21cd4cff    \b)
        off = pageOff + 1
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cff)
        }
        if m3 {
          // do something with \b)
        }

        // >>>0x1    longle    21cd4cfe    \b, relocatable)
        off = pageOff + 1
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cfe)
        }
        if m3 {
          // do something with \b, relocatable)
        }

      }
      // >>0x1    default    COM executable for DOS
      off = pageOff + 1
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "\x81\xfc"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    "w\x02\xcd \xb9"    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x24    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
      off = pageOff + 36
      // uh oh unhandled kind

    }
  }
  // 0xfc    string    "Must have DOS version"    DR-DOS executable (COM)
  off = pageOff + 252
  // uh oh unhandled kind

  // 0x22    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 34
  // uh oh unhandled kind

  // 0x23    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 35
  // uh oh unhandled kind

  // 0x2    string    "\xcd!"    COM executable for DOS
  off = pageOff + 2
  // uh oh unhandled kind

  // 0x4    string    "\xcd!"    COM executable for DOS
  off = pageOff + 4
  // uh oh unhandled kind

  // 0x5    string    "\xcd!"    COM executable for DOS
  off = pageOff + 5
  // uh oh unhandled kind

  // 0x7    string    "\xcd!"    
  off = pageOff + 7
  // uh oh unhandled kind

  if m0 {
    // >0x0    bytele    b8    COM executable for DOS
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0xb8)
    }
    if m1 {
      // do something with COM executable for DOS
    }

  }
  // 0xa    string    "\xcd!"    
  off = pageOff + 10
  // uh oh unhandled kind

  if m0 {
    // >0x5    string    "\xcd!"    COM executable for DOS
    off = pageOff + 5
    // uh oh unhandled kind

  }
  // 0xd    string    "\xcd!"    COM executable for DOS
  off = pageOff + 13
  // uh oh unhandled kind

  // 0x12    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 18
  // uh oh unhandled kind

  // 0x17    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 23
  // uh oh unhandled kind

  // 0x1e    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 30
  // uh oh unhandled kind

  // 0x46    string    "\xcd!"    COM executable for DOS
  off = pageOff + 70
  // uh oh unhandled kind

  // 0x6    search/0xa    "\xfcW\xf3\xa5\xc3"    COM executable for MS-DOS
  off = pageOff + 6
  // uh oh unhandled kind

  // 0x6    search/0xa    "\xfcW\xf3\xa4\xc3"    COM executable for DOS
  off = pageOff + 6
  // uh oh unhandled kind

  if m0 {
    // >0x18    search/0x10    "P\xa4\xff\xd5s"    \b, aPack compressed
    off = pageOff + 24
    // uh oh unhandled kind

  }
  // 0x3c    string    "W Collis\x00\x00"    COM executable for MS-DOS, Compack compressed
  off = pageOff + 60
  // uh oh unhandled kind

  // 0x0    string    "LZ"    MS-DOS executable (built-in)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1AAFB\r\x00OM\x06\x0e+4\x01\x01\x01\xff"    AAF legacy file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      // do something with (512B sectors)
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      // do something with (4kB sectors)
    }

  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1\x01\x02\x01\r\x00\x02\x00\x00\x06\x0e+4\x03\x02\x01\x01"    AAF file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      // do something with (512B sectors)
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      // do something with (4kB sectors)
    }

  }
  // 0x820    string    "Microsoft Word 6.0 Document"    %s
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x820    string    "Documento Microsoft Word 6"    Spanish Microsoft Word 6 document data
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x840    string    "MSWordDoc"    Microsoft Word document data
  off = pageOff + 2112
  // uh oh unhandled kind

  // 0x0    longbe    31be0000    Microsoft Word Document
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x31be0000)
  }
  if m0 {
    // do something with Microsoft Word Document
  }

  // 0x0    string    "PO^Q`"    Microsoft Word 6.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x4    longle    0    
  off = pageOff + 4
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x0)
  }

  if m0 {
    // >0x0    longbe    fe320000    Microsoft Word for Macintosh 1.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe320000)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 1.0
    }

    // >0x0    longbe    fe340000    Microsoft Word for Macintosh 3.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe340000)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 3.0
    }

    // >0x0    longbe    fe37001c    Microsoft Word for Macintosh 4.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe37001c)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 4.0
    }

    // >0x0    longbe    fe370023    Microsoft Word for Macintosh 5.0
    off = pageOff + 0
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfe370023)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 5.0
    }

  }
  // 0x0    string    "ۥ-\x00\x00\x00"    Microsoft Word 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x200    string    "\xec\xa5\xc1"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind

  // 0x0    string    "ۥ-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x820    string    "Microsoft Excel 5.0 Worksheet"    %s
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x0    string    "ۥ-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x820    string    "Foglio di lavoro Microsoft Exce"    %s
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x842    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2114
  // uh oh unhandled kind

  // 0x849    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2121
  // uh oh unhandled kind

  // 0x0    string    "\t\x04\x06\x00\x00\x00\x10\x00"    Microsoft Excel Worksheet
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    longbe    1a00    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x1a00)
  }

  if m0 {
    // >0x14    ubytele    0    
    off = pageOff + 20
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x14    ubytele    20    Lotus 1-2-3
      off = pageOff + 20
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) < 0x20)
      }
      if m2 {
        // do something with Lotus 1-2-3
      }

      if m2 {
        // >>>0x4    ushortle    1000    WorKsheet, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1000)
        }
        if m3 {
          // do something with WorKsheet, version 3
        }

        // >>>0x4    ushortle    1002    WorKsheet, version 4
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1002)
        }
        if m3 {
          // do something with WorKsheet, version 4
        }

        // >>>0x4    ushortle    1003    WorKsheet, version 97
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1003)
        }
        if m3 {
          // do something with WorKsheet, version 97
        }

        // >>>0x4    ushortle    1005    WorKsheet, version 9.8 Millennium
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1005)
        }
        if m3 {
          // do something with WorKsheet, version 9.8 Millennium
        }

        // >>>0x4    ushortle    8001    FoRMatting data
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          // do something with FoRMatting data
        }

        // >>>0x4    ushortle    8007    ForMatting data, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          // do something with ForMatting data, version 3
        }

        // >>>0x4    default    unknown
        off = pageOff + 4
        // uh oh unhandled kind

        if m3 {
          // >>>>0x6    ushortle    4    worksheet
          off = pageOff + 6
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x4)
          }
          if m4 {
            // do something with worksheet
          }

          // >>>>0x6    ushortle    4    formatting data
          off = pageOff + 6
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) != 0x4)
          }
          if m4 {
            // do something with formatting data
          }

          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b, revision 0x%x
          }

        }
        // >>>0x6    ushortle    4    \b, cell range
        off = pageOff + 6
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          // do something with \b, cell range
        }

        if m3 {
          // >>>>0x8    ulongle    0    
          off = pageOff + 8
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (uint64(iv) != 0x0)
          }

          if m4 {
            // >>>>>0xa    ubytele    0    \b%d*
            off = pageOff + 10
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (int64(int8(iv)) > 0x0)
            }
            if m5 {
              // do something with \b%d*
            }

            // >>>>>0x8    ushortle    0    \b%d,
            off = pageOff + 8
            {
              iv, ok := readUint16be(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              // do something with \b%d,
            }

            // >>>>>0xb    ubytele    0    \b%d-
            off = pageOff + 11
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              // do something with \b%d-
            }

          }
          // >>>>0xe    ubytele    0    \b%d*
          off = pageOff + 14
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x0)
          }
          if m4 {
            // do something with \b%d*
          }

          // >>>>0xc    ushortle    0    \b%d,
          off = pageOff + 12
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b%d,
          }

          // >>>>0xf    ubytele    0    \b%d
          off = pageOff + 15
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b%d
          }

          // >>>>0x14    ubytele    1    \b, character set 0x%x
          off = pageOff + 20
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x1)
          }
          if m4 {
            // do something with \b, character set 0x%x
          }

          // >>>>0x15    ubytele    0    \b, flags 0x%x
          off = pageOff + 21
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b, flags 0x%x
          }

        }
        // >>>0x6    ushortle    4    
        off = pageOff + 6
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) != 0x4)
        }

        if m3 {
          // >>>>0x1e    search/0x1d    "\x00\xae"    
          off = pageOff + 30
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x4    string    ">\x00"    \b, 1st font "%s"
            off = pageOff + 4
            // uh oh unhandled kind

          }
        }
      }
    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x7    ubytele    0    
    off = pageOff + 7
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x6    ubytele    0    Lotus
      off = pageOff + 6
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }
      if m2 {
        // do something with Lotus
      }

      if m2 {
        // >>>0x4    ushortle    7    1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
        }

        // >>>0x4    ushortle    c05    1-2-3 CoNFiguration, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0xc05)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.4J
        }

        // >>>0x4    ushortle    801    1-2-3 CoNFiguration, version 1-2.1
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x801)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 1-2.1
        }

        // >>>0x4    ushortle    802    Symphony CoNFiguration
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x802)
        }
        if m3 {
          // do something with Symphony CoNFiguration
        }

        // >>>0x4    ushortle    804    1-2-3 CoNFiguration, version 2.2
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x804)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.2
        }

        // >>>0x4    ushortle    80a    1-2-3 CoNFiguration, version 2.3-2.4
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x80a)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.3-2.4
        }

        // >>>0x4    ushortle    1402    1-2-3 CoNFiguration, version 3.x
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1402)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 3.x
        }

        // >>>0x4    ushortle    1450    1-2-3 CoNFiguration, version 4.x
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1450)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 4.x
        }

        // >>>0x4    ushortle    404    1-2-3 WorKSheet, version 1
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x404)
        }
        if m3 {
          // do something with 1-2-3 WorKSheet, version 1
        }

        // >>>0x4    ushortle    405    Symphony WoRksheet, version 1.0
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x405)
        }
        if m3 {
          // do something with Symphony WoRksheet, version 1.0
        }

        // >>>0x4    ushortle    406    1-2-3/Symphony worksheet, version 2
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x406)
        }
        if m3 {
          // do something with 1-2-3/Symphony worksheet, version 2
        }

        // >>>0x4    ushortle    600    1-2-3 WorKsheet, version 1.xJ
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x600)
        }
        if m3 {
          // do something with 1-2-3 WorKsheet, version 1.xJ
        }

        // >>>0x4    ushortle    602    1-2-3 worksheet, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x602)
        }
        if m3 {
          // do something with 1-2-3 worksheet, version 2.4J
        }

        // >>>0x4    ushortle    8006    1-2-3 ForMaTting data, version 2.x
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8006)
        }
        if m3 {
          // do something with 1-2-3 ForMaTting data, version 2.x
        }

        // >>>0x4    ushortle    8007    1-2-3 FoRMatting data, version 2.0
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          // do something with 1-2-3 FoRMatting data, version 2.0
        }

        // >>>0x4    default    unknown worksheet or configuration
        off = pageOff + 4
        // uh oh unhandled kind

        if m3 {
          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b, revision 0x%x
          }

        }
        // >>>0x6    use   lotus-cells    
        off = pageOff + 6
        // uh oh unhandled kind

        // >>>(0x8.shortle+10)    use   lotus-cells    
        // uh oh indirect offset
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    string    "WordPro\x00"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "WordPro\r\xfb"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "q\xa8\x00\x00\x01\x02"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "Stirling Technologies,"    InstallShield Uninstall Script
    off = pageOff + 12
    // uh oh unhandled kind

  }
  // 0x0    string    "Nullsoft AVS Preset "    Winamp plug in
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xd7\xcdƚ"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x02\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x01\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x03\x01\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x03\x02\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x03\x03\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW5\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW6\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW7\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW8\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW9\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00\x95\x03\x05\x002R\x87\xc4@\xe5\""    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "MDIF\x1a\x00\b\x00\x00\x00\xfa&@}\x01\x00\x01\x1e\x01\x00"    MS Windows special zipped file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "BA(\x00\x00\x00.\x00\x00\x00\x00\x00\x00\x00"    Icon for MS Windows
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    longbe    100    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x100)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "PK\b\bBGI"    Borland font
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind

  }
  // 0x0    string    "pk\b\bBGI"    Borland device
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind

  }
  // 0x0    longle    4    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x4)
  }

  if m0 {
    // >0xc    longle    118    Windows Recycle Bin INFO2 file (Win98 or below)
    off = pageOff + 12
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x118)
    }
    if m1 {
      // do something with Windows Recycle Bin INFO2 file (Win98 or below)
    }

  }
  // 0x0    longle    5    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x5)
  }

  if m0 {
    // >0xc    longle    320    Windows Recycle Bin INFO2 file (Win2k - WinXP)
    off = pageOff + 12
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x320)
    }
    if m1 {
      // do something with Windows Recycle Bin INFO2 file (Win2k - WinXP)
    }

  }
  // 0x9    string    "GERBILDOC"    First Choice document
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x9    string    "GERBILDB"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x9    string    "GERBILCLIP"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x0    string    "GERBIL"    First Choice device file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x9    string    "RABBITGRAPH"    RabbitGraph file
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x0    string    "DCU1"    Borland Delphi .DCU file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "=!<spell>"    MKS Spell hash list (old format)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "=!<spell2>"    MKS Spell hash list
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    longle    8086b70    TurboC BGI file
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x8086b70)
  }
  if m0 {
    // do something with TurboC BGI file
  }

  // 0x0    longle    8084b50    TurboC Font file
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x8084b50)
  }
  if m0 {
    // do something with TurboC Font file
  }

  // 0x0    string    "TPF0"    
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "PMCC"    Windows 3.x .GRP file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x1    string    "RDC-meg"    MegaDots
  off = pageOff + 1
  // uh oh unhandled kind

  if m0 {
    // >0x8    bytele    2f    version %c
    off = pageOff + 8
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      // do something with version %c
    }

    // >0x9    bytele    2f    \b.%c file
    off = pageOff + 9
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      // do something with \b.%c file
    }

  }
  // 0x0    longle    4c    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x4c)
  }

  if m0 {
    // >0x4    longle    21401    Windows shortcut file
    off = pageOff + 4
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x21401)
    }
    if m1 {
      // do something with Windows shortcut file
    }

  }
  // 0x171    string    "MICROSOFT PIFEX\x00"    Windows Program Information File
  off = pageOff + 369
  // uh oh unhandled kind

  if m0 {
    // >0x24    string    ">\x00"    \b for %.63s
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x65    string    ">\x00"    \b, directory=%.64s
    off = pageOff + 101
    // uh oh unhandled kind

    // >0xa5    string    ">\x00"    \b, parameters=%.64s
    off = pageOff + 165
    // uh oh unhandled kind

    // >0x187    search/0xb55    "WINDOWS VMM 4.0\x00"    
    off = pageOff + 391
    // uh oh unhandled kind

    if m1 {
      // >>&0x5e    ubytele    0    
      off = pageOff + 94
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind

        // >>>&0x-1    string    ">PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind

      }
      // >>&0xf0    ubytele    0    
      off = pageOff + 240
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

        // >>>&0x-1    string    ">Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

      }
      // >>&0x110    ubytele    0    
      off = pageOff + 272
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

        // >>>&0x-1    string    ">Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

      }
    }
    // >0x187    search/0xb55    "WINDOWS NT  3.1\x00"    \b, Windows NT-style
    off = pageOff + 391
    // uh oh unhandled kind

    // >0x187    search/0xb55    "CONFIG  SYS 4.0\x00"    \b +CONFIG.SYS
    off = pageOff + 391
    // uh oh unhandled kind

    // >0x187    search/0xb55    "AUTOEXECBAT 4.0\x00"    \b +AUTOEXEC.BAT
    off = pageOff + 391
    // uh oh unhandled kind

  }
  // 0x0    longbe    c5d0d3c6    DOS EPS Binary File
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0xc5d0d3c6)
  }
  if m0 {
    // do something with DOS EPS Binary File
  }

  if m0 {
    // >0x4    longle    0    Postscript starts at byte %d
    off = pageOff + 4
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      // do something with Postscript starts at byte %d
    }

    if m1 {
      // >>0x8    longle    0    length %d
      off = pageOff + 8
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x0)
      }
      if m2 {
        // do something with length %d
      }

      if m2 {
        // >>>0xc    longle    0    Metafile starts at byte %d
        off = pageOff + 12
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          // do something with Metafile starts at byte %d
        }

        if m3 {
          // >>>>0x10    longle    0    length %d
          off = pageOff + 16
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with length %d
          }

        }
        // >>>0x14    longle    0    TIFF starts at byte %d
        off = pageOff + 20
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          // do something with TIFF starts at byte %d
        }

        if m3 {
          // >>>>0x18    longle    0    length %d
          off = pageOff + 24
          {
            iv, ok := readUint32be(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with length %d
          }

        }
      }
    }
  }
  // 0x0    shortle    223e9f78    TNEF
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (uint64(iv) == 0x223e9f78)
  }
  if m0 {
    // do something with TNEF
  }

  // 0x0    string    "NG\x00\x01"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x2    ulongle    100    Norton Guide
    off = pageOff + 2
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x100)
    }
    if m1 {
      // do something with Norton Guide
    }

    if m1 {
      // >>0x8    string    ">\x00"    "%-.40s"
      off = pageOff + 8
      // uh oh unhandled kind

      // >>0x30    string    ">\x00"    \b, %-.66s
      off = pageOff + 48
      // uh oh unhandled kind

      // >>0x72    string    ">\x00"    %-.66s
      off = pageOff + 114
      // uh oh unhandled kind

    }
  }
  // 0x0    ulongle    48443408    4DOS help file
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x48443408)
  }
  if m0 {
    // do something with 4DOS help file
  }

  if m0 {
    // >0x4    string    "x"    \b, version %-4.4s
    off = pageOff + 4
    // uh oh unhandled kind

  }
  // 0x0    uquadle    3a000000024e4c    MS Advisor help file
  off = pageOff + 0
  {
    iv, ok := readUint64be(tb, off)
    m0 = ok && (uint64(iv) == 0x3a000000024e4c)
  }
  if m0 {
    // do something with MS Advisor help file
  }

  // 0x0    string    "ITSF\x03\x00\x00\x00`\x00\x00\x00"    MS Windows HtmlHelp Data
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x2    string    "GFA-BASIC3"    GFA-BASIC 3 data
  off = pageOff + 2
  // uh oh unhandled kind

  // 0x0    string    "MSCF\x00\x00\x00\x00"    Microsoft Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x8    longle    0    \b, %u bytes
    off = pageOff + 8
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, %u bytes
    }

    // >0x1c    shortle    1    \b, 1 file
    off = pageOff + 28
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with \b, 1 file
    }

    // >0x1c    shortle    1    \b, %u files
    off = pageOff + 28
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %u files
    }

  }
  // 0x0    string    "ISc("    InstallShield Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x5    bytele    60&0xf0    version 6,
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      // do something with version 6,
    }

    // >0x5    bytele    60&0xf0    version 4/5,
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x60)
    }
    if m1 {
      // do something with version 4/5,
    }

    // >(0xc.longle+40)    longle    0    %u files
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with %u files
    }

  }
  // 0x0    string    "MSCE\x00\x00\x00\x00"    Microsoft WinCE install header
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x14    longle    0    \b, architecture-independent
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, architecture-independent
    }

    // >0x14    longle    67    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      // do something with \b, Hitachi SH3
    }

    // >0x14    longle    68    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      // do something with \b, Hitachi SH4
    }

    // >0x14    longle    a11    \b, StrongARM
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xa11)
    }
    if m1 {
      // do something with \b, StrongARM
    }

    // >0x14    longle    fa0    \b, MIPS R4000
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfa0)
    }
    if m1 {
      // do something with \b, MIPS R4000
    }

    // >0x14    longle    2713    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x2713)
    }
    if m1 {
      // do something with \b, Hitachi SH3
    }

    // >0x14    longle    2714    \b, Hitachi SH3E
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x2714)
    }
    if m1 {
      // do something with \b, Hitachi SH3E
    }

    // >0x14    longle    2715    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x2715)
    }
    if m1 {
      // do something with \b, Hitachi SH4
    }

    // >0x14    longle    11171    \b, ARM 7TDMI
    off = pageOff + 20
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x11171)
    }
    if m1 {
      // do something with \b, ARM 7TDMI
    }

    // >0x34    shortle    1    \b, 1 file
    off = pageOff + 52
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with \b, 1 file
    }

    // >0x34    shortle    1    \b, %u files
    off = pageOff + 52
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %u files
    }

    // >0x38    shortle    1    \b, 1 registry entry
    off = pageOff + 56
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with \b, 1 registry entry
    }

    // >0x38    shortle    1    \b, %u registry entries
    off = pageOff + 56
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %u registry entries
    }

  }
  // 0x0    ulongle    1    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x1)
  }

  if m0 {
    // >0x28    string    " EMF"    Windows Enhanced Metafile (EMF) image data
    off = pageOff + 40
    // uh oh unhandled kind

    if m1 {
      // >>0x2c    ulongle    0    version 0x%x
      off = pageOff + 44
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with version 0x%x
      }

    }
  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1"    Microsoft Office Document
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x222    string    "bjbj"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind

    // >0x222    string    "jbjb"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind

  }
  // 0x0    string    "\x94\xa6."    Microsoft Word Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x200    string    "R\x00o\x00o\x00t\x00 \x00E\x00n\x00t\x00r\x00y"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind

  // 0x0    string    "$RBU"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x17    string    "Dell"    %s system BIOS
    off = pageOff + 23
    // uh oh unhandled kind

    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }

    if m1 {
      // >>0x30    bytele    0    version %d.
      off = pageOff + 48
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with version %d.
      }

      // >>0x31    bytele    0    \b%d.
      off = pageOff + 49
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d.
      }

      // >>0x32    bytele    0    \b%d
      off = pageOff + 50
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d
      }

    }
    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x2)
    }

    if m1 {
      // >>0x30    string    "x"    version %.3s
      off = pageOff + 48
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "DDS |\x00\x00\x00"    Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x10    longle    0    %d x
    off = pageOff + 16
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      // do something with %d x
    }

    // >0xc    longle    0    %d,
    off = pageOff + 12
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      // do something with %d,
    }

    // >0x54    string    "x"    %.4s
    off = pageOff + 84
    // uh oh unhandled kind

  }
  // 0x0    string    "ITOLITLS"    Microsoft Reader eBook Data
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x8    longle    0    \b, version %u
    off = pageOff + 8
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, version %u
    }

  }
  // 0x0    string    "B000FF\n"    Windows Embedded CE binary image
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "MSWIM\x00\x00\x00"    Windows imaging (WIM) image
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "WLPWM\x00\x00\x00"    Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x03\x00"    Mallard BASIC program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x04\x00"    Mallard BASIC program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x03\x01"    Mallard BASIC protected program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x04\x01"    Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "MIOPEN"    Mallard BASIC Jetsam data
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "Jetsam0"    Mallard BASIC Jetsam index data
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x3    ushortle    7bb    
  off = pageOff + 3
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (int64(int16(iv)) > 0x7bb)
  }

  if m0 {
    // >0x5    ubytele    1f    
    off = pageOff + 5
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x1f)
    }

    if m1 {
      // >>0x6    ubytele    c    
      off = pageOff + 6
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (int64(int8(iv)) < 0xc)
      }

      if m2 {
        // >>>0x7    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
        off = pageOff + 7
        // uh oh unhandled kind

        if m3 {
          // >>>>0x1    ubytele    0    DOS 2.0 backup id file, sequence %d
          off = pageOff + 1
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with DOS 2.0 backup id file, sequence %d
          }

          // >>>>0x0    ubytele    ff    \b, last disk
          off = pageOff + 0
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) == 0xff)
          }
          if m4 {
            // do something with \b, last disk
          }

        }
      }
    }
  }
  // 0x53    ubytele    50    
  off = pageOff + 83
  {
    iv, ok := readUint8be(tb, off)
    m0 = ok && (int64(int8(iv)) < 0x50)
  }

  if m0 {
    // >0x54    string    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 84
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "x"    DOS 2.0 backed up file %s,
      off = pageOff + 5
      // uh oh unhandled kind

      // >>0x0    ubytele    ff    complete file
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        // do something with complete file
      }

      // >>0x0    ubytele    ff    
      off = pageOff + 0
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) != 0xff)
      }

      if m2 {
        // >>>0x1    ushortle    0    split file, sequence %d
        off = pageOff + 1
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with split file, sequence %d
        }

      }
    }
  }
  // 0x0    string    "\x8bBACKUP "    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xa    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 10
    // uh oh unhandled kind

    if m1 {
      // >>0x9    ubytele    0    DOS 3.3 backup control file, sequence %d
      off = pageOff + 9
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with DOS 3.3 backup control file, sequence %d
      }

      // >>0x8a    ubytele    ff    \b, last disk
      off = pageOff + 138
      {
        iv, ok := readUint8be(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        // do something with \b, last disk
      }

    }
  }
  return outStrings, nil
}

func IdentifyMsdosDriver(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  if m0 {
    // >0x28    search/0x7    "UPX!"    \bUPX compressed
    off = pageOff + 40
    // uh oh unhandled kind

    // >0x4    ushortle    0&0x8000    \bblock device driver
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \bblock device driver
    }

    // >0x4    ushortle    8000&0x8000    \b
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }
    if m1 {
      // do something with \b
    }

    if m1 {
      // >>0x4    ushortle    8&0x8    \bclock
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        // do something with \bclock
      }

      // >>0x4    ushortle    10&0x10    \bfast
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x10)
      }
      if m2 {
        // do something with \bfast
      }

      // >>0x4    ushortle    0&0x3    \bstandard
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        // do something with \bstandard
      }

      if m2 {
        // >>>0x4    ushortle    1&0x1    \binput
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with \binput
        }

        // >>>0x4    ushortle    3&0x3    \b/
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with \b/
        }

        // >>>0x4    ushortle    2&0x2    \boutput
        off = pageOff + 4
        {
          iv, ok := readUint16be(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with \boutput
        }

      }
      // >>0x4    ushortle    8000&0x8000    \bcharacter device driver
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x8000)
      }
      if m2 {
        // do something with \bcharacter device driver
      }

    }
    // >0x0    ubytele    0    
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x28    search/0x7    "UPX!"    
      off = pageOff + 40
      // uh oh unhandled kind

      // >>0x28    default    
      off = pageOff + 40
      // uh oh unhandled kind

      if m2 {
        // >>>0xc    ubytele    2e    \b
        off = pageOff + 12
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x2e)
        }
        if m3 {
          // do something with \b
        }

        if m3 {
          // >>>>0xa    ubytele    20    
          off = pageOff + 10
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xa    ubytele    2e    
            off = pageOff + 10
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0xa    ubytele    2a    \b%c
              off = pageOff + 10
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (uint64(iv) != 0x2a)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
          // >>>>0xb    ubytele    20    
          off = pageOff + 11
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xb    ubytele    2e    \b%c
            off = pageOff + 11
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              // do something with \b%c
            }

          }
          // >>>>0xc    ubytele    20    
          off = pageOff + 12
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xc    ubytele    39    
            off = pageOff + 12
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x39)
            }

            if m5 {
              // >>>>>>0xc    ubytele    2e    \b%c
              off = pageOff + 12
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (uint64(iv) != 0x2e)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
        }
        // >>>0xd    ubytele    20    
        off = pageOff + 13
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x20)
        }

        if m3 {
          // >>>>0xd    ubytele    2e    \b%c
          off = pageOff + 13
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (uint64(iv) != 0x2e)
          }
          if m4 {
            // do something with \b%c
          }

          // >>>>0xe    ubytele    20    
          off = pageOff + 14
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xe    ubytele    2e    \b%c
            off = pageOff + 14
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              // do something with \b%c
            }

          }
          // >>>>0xf    ubytele    20    
          off = pageOff + 15
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xf    ubytele    2e    \b%c
            off = pageOff + 15
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              // do something with \b%c
            }

          }
          // >>>>0x10    ubytele    20    
          off = pageOff + 16
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x10    ubytele    2e    
            off = pageOff + 16
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x10    ubytele    cb    \b%c
              off = pageOff + 16
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (int64(int8(iv)) < 0xcb)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
          // >>>>0x11    ubytele    20    
          off = pageOff + 17
          {
            iv, ok := readUint8be(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x11    ubytele    2e    
            off = pageOff + 17
            {
              iv, ok := readUint8be(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x11    ubytele    90    \b%c
              off = pageOff + 17
              {
                iv, ok := readUint8be(tb, off)
                m6 = ok && (int64(int8(iv)) < 0x90)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
        }
        // >>>0xc    ubytele    2f    
        off = pageOff + 12
        {
          iv, ok := readUint8be(tb, off)
          m3 = ok && (int64(int8(iv)) < 0x2f)
        }

        if m3 {
          // >>>>0x16    string    ">."    %-.6s
          off = pageOff + 22
          // uh oh unhandled kind

        }
      }
    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    2&0x2    \b,32-bit sector-
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        // do something with \b,32-bit sector-
      }

    }
    // >0x4    ushortle    40&0x40    \b,IOCTL-
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      // do something with \b,IOCTL-
    }

    // >0x4    ushortle    800&0x800    \b,close media-
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x800)
    }
    if m1 {
      // do something with \b,close media-
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    2000&0x2000    \b,until busy-
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (uint64(iv) == 0x2000)
      }
      if m2 {
        // do something with \b,until busy-
      }

    }
    // >0x4    ushortle    4000&0x4000    \b,control strings-
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x4000)
    }
    if m1 {
      // do something with \b,control strings-
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    0&0x6840    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        // do something with \bsupport
      }

    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    0&0x4842    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16be(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        // do something with \bsupport
      }

    }
    // >0x0    ubytele    0    \b)
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b)
    }

  }
  return outStrings, nil
}

func IdentifyMsdosCom(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    DOS executable (COM)
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with DOS executable (COM)
    }

    // >0x6    string    "SFX of LHarc"    \b, %s
    off = pageOff + 6
    // uh oh unhandled kind

    // >0x1fe    shortle    aa55    \b, boot code
    off = pageOff + 510
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0xaa55)
    }
    if m1 {
      // do something with \b, boot code
    }

    // >0x55    string    "UPX"    \b, UPX compressed
    off = pageOff + 85
    // uh oh unhandled kind

    // >0x4    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind

    // >0x4    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind

    // >0x20e    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 526
    // uh oh unhandled kind

  }
  return outStrings, nil
}

func IdentifyCurIcoDir(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false

  if m1 {
    if m1 {
      // >>(0x12.longle)    ulongle    0    MS Windows
      // uh oh indirect offset
      {
        iv, ok := readUint32be(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with MS Windows
      }

      if m2 {
        // >>>0x0    ulongbe    100    icon resource
        off = pageOff + 0
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          // do something with icon resource
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with - %d icon
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            // do something with \bs
          }

          // >>>>0x6    use   ico-entry    
          off = pageOff + 6
          // uh oh unhandled kind

          // >>>>0x4    ushortle    1    
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }

          if m4 {
            // >>>>>0x16    use   ico-entry    
            off = pageOff + 22
            // uh oh unhandled kind

          }
        }
        // >>>0x0    ulongbe    200    cursor resource
        off = pageOff + 0
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with cursor resource
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with - %d icon
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16be(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            // do something with \bs
          }

          // >>>>0x6    use   cur-entry    
          off = pageOff + 6
          // uh oh unhandled kind

        }
      }
    }
  }
  return outStrings, nil
}

func IdentifyCurEntry(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    0    \b, hotspot @%dx
    off = pageOff + 4
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, hotspot @%dx
    }

    // >0x6    ushortle    0    \b%d
    off = pageOff + 6
    {
      iv, ok := readUint16be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b%d
    }

  }
  return outStrings, nil
}

func IdentifyCurIcoEntry(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    \b, 256x
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, 256x
    }

    // >0x0    bytele    0    \b, %dx
    off = pageOff + 0
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      // do something with \b, %dx
    }

    // >0x1    bytele    0    \b256
    off = pageOff + 1
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b256
    }

    // >0x1    bytele    0    \b%d
    off = pageOff + 1
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      // do something with \b%d
    }

    // >0x2    ubytele    0    \b, %d colors
    off = pageOff + 2
    {
      iv, ok := readUint8be(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      // do something with \b, %d colors
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x89504e47)
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) != 0x89504e47)
    }

  }
  return outStrings, nil
}

func IdentifyMsdosDriver__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  if m0 {
    // >0x28    search/0x7    "UPX!"    \bUPX compressed
    off = pageOff + 40
    // uh oh unhandled kind

    // >0x4    ushortle    0&0x8000    \bblock device driver
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \bblock device driver
    }

    // >0x4    ushortle    8000&0x8000    \b
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }
    if m1 {
      // do something with \b
    }

    if m1 {
      // >>0x4    ushortle    8&0x8    \bclock
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        // do something with \bclock
      }

      // >>0x4    ushortle    10&0x10    \bfast
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x10)
      }
      if m2 {
        // do something with \bfast
      }

      // >>0x4    ushortle    0&0x3    \bstandard
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        // do something with \bstandard
      }

      if m2 {
        // >>>0x4    ushortle    1&0x1    \binput
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with \binput
        }

        // >>>0x4    ushortle    3&0x3    \b/
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with \b/
        }

        // >>>0x4    ushortle    2&0x2    \boutput
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with \boutput
        }

      }
      // >>0x4    ushortle    8000&0x8000    \bcharacter device driver
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x8000)
      }
      if m2 {
        // do something with \bcharacter device driver
      }

    }
    // >0x0    ubytele    0    
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x28    search/0x7    "UPX!"    
      off = pageOff + 40
      // uh oh unhandled kind

      // >>0x28    default    
      off = pageOff + 40
      // uh oh unhandled kind

      if m2 {
        // >>>0xc    ubytele    2e    \b
        off = pageOff + 12
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x2e)
        }
        if m3 {
          // do something with \b
        }

        if m3 {
          // >>>>0xa    ubytele    20    
          off = pageOff + 10
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xa    ubytele    2e    
            off = pageOff + 10
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0xa    ubytele    2a    \b%c
              off = pageOff + 10
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (uint64(iv) != 0x2a)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
          // >>>>0xb    ubytele    20    
          off = pageOff + 11
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xb    ubytele    2e    \b%c
            off = pageOff + 11
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              // do something with \b%c
            }

          }
          // >>>>0xc    ubytele    20    
          off = pageOff + 12
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xc    ubytele    39    
            off = pageOff + 12
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x39)
            }

            if m5 {
              // >>>>>>0xc    ubytele    2e    \b%c
              off = pageOff + 12
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (uint64(iv) != 0x2e)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
        }
        // >>>0xd    ubytele    20    
        off = pageOff + 13
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) > 0x20)
        }

        if m3 {
          // >>>>0xd    ubytele    2e    \b%c
          off = pageOff + 13
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) != 0x2e)
          }
          if m4 {
            // do something with \b%c
          }

          // >>>>0xe    ubytele    20    
          off = pageOff + 14
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xe    ubytele    2e    \b%c
            off = pageOff + 14
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              // do something with \b%c
            }

          }
          // >>>>0xf    ubytele    20    
          off = pageOff + 15
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0xf    ubytele    2e    \b%c
            off = pageOff + 15
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }
            if m5 {
              // do something with \b%c
            }

          }
          // >>>>0x10    ubytele    20    
          off = pageOff + 16
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x10    ubytele    2e    
            off = pageOff + 16
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x10    ubytele    cb    \b%c
              off = pageOff + 16
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (int64(int8(iv)) < 0xcb)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
          // >>>>0x11    ubytele    20    
          off = pageOff + 17
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x20)
          }

          if m4 {
            // >>>>>0x11    ubytele    2e    
            off = pageOff + 17
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) != 0x2e)
            }

            if m5 {
              // >>>>>>0x11    ubytele    90    \b%c
              off = pageOff + 17
              {
                iv, ok := readUint8le(tb, off)
                m6 = ok && (int64(int8(iv)) < 0x90)
              }
              if m6 {
                // do something with \b%c
              }

            }
          }
        }
        // >>>0xc    ubytele    2f    
        off = pageOff + 12
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) < 0x2f)
        }

        if m3 {
          // >>>>0x16    string    ">."    %-.6s
          off = pageOff + 22
          // uh oh unhandled kind

        }
      }
    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    2&0x2    \b,32-bit sector-
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        // do something with \b,32-bit sector-
      }

    }
    // >0x4    ushortle    40&0x40    \b,IOCTL-
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      // do something with \b,IOCTL-
    }

    // >0x4    ushortle    800&0x800    \b,close media-
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x800)
    }
    if m1 {
      // do something with \b,close media-
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    2000&0x2000    \b,until busy-
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x2000)
      }
      if m2 {
        // do something with \b,until busy-
      }

    }
    // >0x4    ushortle    4000&0x4000    \b,control strings-
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4000)
    }
    if m1 {
      // do something with \b,control strings-
    }

    // >0x4    ushortle    8000&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8000)
    }

    if m1 {
      // >>0x4    ushortle    0&0x6840    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        // do something with \bsupport
      }

    }
    // >0x4    ushortle    0&0x8000    
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x4    ushortle    0&0x4842    \bsupport
      off = pageOff + 4
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x0)
      }
      if m2 {
        // do something with \bsupport
      }

    }
    // >0x0    ubytele    0    \b)
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b)
    }

  }
  return outStrings, nil
}

func IdentifyMsdosCom__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    DOS executable (COM)
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with DOS executable (COM)
    }

    // >0x6    string    "SFX of LHarc"    \b, %s
    off = pageOff + 6
    // uh oh unhandled kind

    // >0x1fe    shortle    aa55    \b, boot code
    off = pageOff + 510
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xaa55)
    }
    if m1 {
      // do something with \b, boot code
    }

    // >0x55    string    "UPX"    \b, UPX compressed
    off = pageOff + 85
    // uh oh unhandled kind

    // >0x4    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind

    // >0x4    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 4
    // uh oh unhandled kind

    // >0x20e    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 526
    // uh oh unhandled kind

  }
  return outStrings, nil
}

func IdentifyCurIcoDir__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false

  if m1 {
    if m1 {
      // >>(0x12.longle)    ulongle    0    MS Windows
      // uh oh indirect offset
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with MS Windows
      }

      if m2 {
        // >>>0x0    ulongbe    100    icon resource
        off = pageOff + 0
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          // do something with icon resource
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with - %d icon
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            // do something with \bs
          }

          // >>>>0x6    use   ico-entry    
          off = pageOff + 6
          // uh oh unhandled kind

          // >>>>0x4    ushortle    1    
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }

          if m4 {
            // >>>>>0x16    use   ico-entry    
            off = pageOff + 22
            // uh oh unhandled kind

          }
        }
        // >>>0x0    ulongbe    200    cursor resource
        off = pageOff + 0
        {
          iv, ok := readUint32be(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with cursor resource
        }

        if m3 {
          // >>>>0x4    ushortle    0    - %d icon
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with - %d icon
          }

          // >>>>0x4    ushortle    1    \bs
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (int64(int16(iv)) > 0x1)
          }
          if m4 {
            // do something with \bs
          }

          // >>>>0x6    use   cur-entry    
          off = pageOff + 6
          // uh oh unhandled kind

        }
      }
    }
  }
  return outStrings, nil
}

func IdentifyCurEntry__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    0    \b, hotspot @%dx
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, hotspot @%dx
    }

    // >0x6    ushortle    0    \b%d
    off = pageOff + 6
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b%d
    }

  }
  return outStrings, nil
}

func IdentifyCurIcoEntry__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    bytele    0    \b, 256x
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, 256x
    }

    // >0x0    bytele    0    \b, %dx
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      // do something with \b, %dx
    }

    // >0x1    bytele    0    \b256
    off = pageOff + 1
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b256
    }

    // >0x1    bytele    0    \b%d
    off = pageOff + 1
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      // do something with \b%d
    }

    // >0x2    ubytele    0    \b, %d colors
    off = pageOff + 2
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }
    if m1 {
      // do something with \b, %d colors
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x89504e47)
    }

    // >(0xc.longle)    ulongbe    89504e47    
    // uh oh indirect offset
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) != 0x89504e47)
    }

  }
  return outStrings, nil
}

func Identify__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false
  m4 := false
  m5 := false
  m6 := false

  // 0x0    string    "\u007fELF"    ELF
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    bytele    0    invalid class
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with invalid class
    }

    // >0x4    bytele    1    32-bit
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with 32-bit
    }

    // >0x4    bytele    2    64-bit
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with 64-bit
    }

    // >0x5    bytele    0    invalid byte order
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with invalid byte order
    }

    // >0x5    bytele    1    LSB
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with LSB
    }

    if m1 {
      // >>0x0    use   elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x5    bytele    2    MSB
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with MSB
    }

    if m1 {
      // >>0x0    use   \^elf-le    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x4    bytele    80    
    off = pageOff + 4
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x80)
    }

    if m1 {
      // >>0x8    string    ">\x00"    (%s)
      off = pageOff + 8
      // uh oh unhandled kind

    }
    // >0x8    string    "\x00"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    0    (SYSV)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with (SYSV)
      }

      // >>0x7    bytele    1    (HP-UX)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        // do something with (HP-UX)
      }

      // >>0x7    bytele    2    (NetBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }
      if m2 {
        // do something with (NetBSD)
      }

      // >>0x7    bytele    3    (GNU/Linux)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x3)
      }
      if m2 {
        // do something with (GNU/Linux)
      }

      // >>0x7    bytele    4    (GNU/Hurd)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x4)
      }
      if m2 {
        // do something with (GNU/Hurd)
      }

      // >>0x7    bytele    5    (86Open)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x5)
      }
      if m2 {
        // do something with (86Open)
      }

      // >>0x7    bytele    6    (Solaris)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x6)
      }
      if m2 {
        // do something with (Solaris)
      }

      // >>0x7    bytele    7    (Monterey)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x7)
      }
      if m2 {
        // do something with (Monterey)
      }

      // >>0x7    bytele    8    (IRIX)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x8)
      }
      if m2 {
        // do something with (IRIX)
      }

      // >>0x7    bytele    9    (FreeBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x9)
      }
      if m2 {
        // do something with (FreeBSD)
      }

      // >>0x7    bytele    a    (Tru64)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xa)
      }
      if m2 {
        // do something with (Tru64)
      }

      // >>0x7    bytele    b    (Novell Modesto)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xb)
      }
      if m2 {
        // do something with (Novell Modesto)
      }

      // >>0x7    bytele    c    (OpenBSD)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xc)
      }
      if m2 {
        // do something with (OpenBSD)
      }

    }
    // >0x8    string    "\x02"    
    off = pageOff + 8
    // uh oh unhandled kind

    if m1 {
      // >>0x7    bytele    d    (OpenVMS)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xd)
      }
      if m2 {
        // do something with (OpenVMS)
      }

      // >>0x7    bytele    61    (ARM)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x61)
      }
      if m2 {
        // do something with (ARM)
      }

      // >>0x7    bytele    ff    (embedded)
      off = pageOff + 7
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        // do something with (embedded)
      }

    }
  }
  // 0x0    string    "@"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1    string    " echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

    // >0x1    string    "echo off"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

    // >0x1    string    "rem"    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

    // >0x1    string    "set "    DOS batch file text
    off = pageOff + 1
    // uh oh unhandled kind

  }
  // 0x64    search/0xffff    "rxfuncadd"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x64    search/0xffff    "say"    
  off = pageOff + 100
  // uh oh unhandled kind

  // 0x0    shortle    166    MS Windows COFF MIPS R4000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x166)
  }
  if m0 {
    // do something with MS Windows COFF MIPS R4000 object file
  }

  // 0x0    shortle    184    MS Windows COFF Alpha object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x184)
  }
  if m0 {
    // do something with MS Windows COFF Alpha object file
  }

  // 0x0    shortle    268    MS Windows COFF Motorola 68000 object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x268)
  }
  if m0 {
    // do something with MS Windows COFF Motorola 68000 object file
  }

  // 0x0    shortle    1f0    MS Windows COFF PowerPC object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x1f0)
  }
  if m0 {
    // do something with MS Windows COFF PowerPC object file
  }

  // 0x0    shortle    290    MS Windows COFF PA-RISC object file
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x290)
  }
  if m0 {
    // do something with MS Windows COFF PA-RISC object file
  }

  // 0x0    string    "MZ"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x18    shortle    40    MS-DOS executable
    off = pageOff + 24
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) < 0x40)
    }
    if m1 {
      // do something with MS-DOS executable
    }

    // >0x18    shortle    3f    
    off = pageOff + 24
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x3f)
    }

    if m1 {
      // >>(0x3c.longle)    string    "PE\x00\x00"    PE
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+24)    shortle    10b    \b32 executable
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }
        if m3 {
          // do something with \b32 executable
        }

        // >>>(0x3c.longle+24)    shortle    20b    \b32+ executable
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }
        if m3 {
          // do something with \b32+ executable
        }

        // >>>(0x3c.longle+24)    shortle    107    ROM image
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x107)
        }
        if m3 {
          // do something with ROM image
        }

        // >>>(0x3c.longle+24)    default    Unknown PE signature
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with 0x%x
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x2000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          // do something with (DLL)
        }

        // >>>(0x3c.longle+92)    shortle    1    (native)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with (native)
        }

        // >>>(0x3c.longle+92)    shortle    2    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with (GUI)
        }

        // >>>(0x3c.longle+92)    shortle    3    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with (console)
        }

        // >>>(0x3c.longle+92)    shortle    7    (POSIX)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          // do something with (POSIX)
        }

        // >>>(0x3c.longle+92)    shortle    9    (Windows CE)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x9)
        }
        if m3 {
          // do something with (Windows CE)
        }

        // >>>(0x3c.longle+92)    shortle    a    (EFI application)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xa)
        }
        if m3 {
          // do something with (EFI application)
        }

        // >>>(0x3c.longle+92)    shortle    b    (EFI boot service driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xb)
        }
        if m3 {
          // do something with (EFI boot service driver)
        }

        // >>>(0x3c.longle+92)    shortle    c    (EFI runtime driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xc)
        }
        if m3 {
          // do something with (EFI runtime driver)
        }

        // >>>(0x3c.longle+92)    shortle    d    (EFI ROM)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xd)
        }
        if m3 {
          // do something with (EFI ROM)
        }

        // >>>(0x3c.longle+92)    shortle    e    (XBOX)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xe)
        }
        if m3 {
          // do something with (XBOX)
        }

        // >>>(0x3c.longle+92)    shortle    f    (Windows boot application)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xf)
        }
        if m3 {
          // do something with (Windows boot application)
        }

        // >>>(0x3c.longle+92)    default    (Unknown subsystem
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x0    shortle    0    0x%x)
          off = pageOff + 0
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with 0x%x)
          }

        }
        // >>>(0x3c.longle+4)    shortle    14c    Intel 80386
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x14c)
        }
        if m3 {
          // do something with Intel 80386
        }

        // >>>(0x3c.longle+4)    shortle    166    MIPS R4000
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x166)
        }
        if m3 {
          // do something with MIPS R4000
        }

        // >>>(0x3c.longle+4)    shortle    168    MIPS R10000
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x168)
        }
        if m3 {
          // do something with MIPS R10000
        }

        // >>>(0x3c.longle+4)    shortle    184    Alpha
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x184)
        }
        if m3 {
          // do something with Alpha
        }

        // >>>(0x3c.longle+4)    shortle    1a2    Hitachi SH3
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1a2)
        }
        if m3 {
          // do something with Hitachi SH3
        }

        // >>>(0x3c.longle+4)    shortle    1a6    Hitachi SH4
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1a6)
        }
        if m3 {
          // do something with Hitachi SH4
        }

        // >>>(0x3c.longle+4)    shortle    1c0    ARM
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1c0)
        }
        if m3 {
          // do something with ARM
        }

        // >>>(0x3c.longle+4)    shortle    1c2    ARM Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1c2)
        }
        if m3 {
          // do something with ARM Thumb
        }

        // >>>(0x3c.longle+4)    shortle    1c4    ARMv7 Thumb
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1c4)
        }
        if m3 {
          // do something with ARMv7 Thumb
        }

        // >>>(0x3c.longle+4)    shortle    1f0    PowerPC
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1f0)
        }
        if m3 {
          // do something with PowerPC
        }

        // >>>(0x3c.longle+4)    shortle    200    Intel Itanium
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with Intel Itanium
        }

        // >>>(0x3c.longle+4)    shortle    266    MIPS16
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x266)
        }
        if m3 {
          // do something with MIPS16
        }

        // >>>(0x3c.longle+4)    shortle    268    Motorola 68000
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x268)
        }
        if m3 {
          // do something with Motorola 68000
        }

        // >>>(0x3c.longle+4)    shortle    290    PA-RISC
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x290)
        }
        if m3 {
          // do something with PA-RISC
        }

        // >>>(0x3c.longle+4)    shortle    366    MIPSIV
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x366)
        }
        if m3 {
          // do something with MIPSIV
        }

        // >>>(0x3c.longle+4)    shortle    466    MIPS16 with FPU
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x466)
        }
        if m3 {
          // do something with MIPS16 with FPU
        }

        // >>>(0x3c.longle+4)    shortle    ebc    EFI byte code
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xebc)
        }
        if m3 {
          // do something with EFI byte code
        }

        // >>>(0x3c.longle+4)    shortle    8664    x86-64
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8664)
        }
        if m3 {
          // do something with x86-64
        }

        // >>>(0x3c.longle+4)    shortle    c0ee    MSIL
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xc0ee)
        }
        if m3 {
          // do something with MSIL
        }

        // >>>(0x3c.longle+4)    default    Unknown processor type
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x0    shortle    0    0x%x
          off = pageOff + 0
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with 0x%x
          }

        }
        // >>>(0x3c.longle+22)    shortle    0&0x200    (stripped to external PDB)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          // do something with (stripped to external PDB)
        }

        // >>>(0x3c.longle+22)    shortle    0&0x1000    system file
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x0)
        }
        if m3 {
          // do something with system file
        }

        // >>>(0x3c.longle+24)    shortle    10b    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x10b)
        }

        if m3 {
          // >>>>(0x3c.longle+232)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with Mono/.Net assembly
          }

        }
        // >>>(0x3c.longle+24)    shortle    20b    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x20b)
        }

        if m3 {
          // >>>>(0x3c.longle+248)    longle    0    Mono/.Net assembly
          // uh oh indirect offset
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with Mono/.Net assembly
          }

        }
        // >>>(0x8.shortle*16)    string    "32STUB"    \b, 32rtm DOS extender
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x8.shortle*16)    string    "32STUB"    \b, for MS Windows
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    string    "UPX0"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    search/0x140    "PEC2"    \b, PECompact2 compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    search/0x140    "UPX2"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0x10.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".idata"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xe.longle+(-4))    string    "PK\x03\x04"    \b, ZIP self-extracting archive (Info-Zip)
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xe.longle+(-4))    string    "ZZ0"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xe.longle+(-4))    string    "ZZ1"    \b, ZZip self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".rsrc"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle+(-4))    string    "a\\\x04\x05"    \b, WinHKI self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xf.longle+(-4))    string    "Rar!"    \b, RAR self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xf.longle+(-4))    search/0x3000    "MSCF"    \b, InstallShield self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

          // >>>>(&0xf.longle+(-4))    search/0x20    "Nullsoft"    \b, Nullsoft Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".data"    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(&0xf.longle)    string    "WEXTRACT"    \b, MS CAB-Installer self-extracting archive
          // uh oh indirect offset
          // uh oh unhandled kind

        }
        // >>>(0x3c.longle+248)    search/0x140    ".petite\x00"    \b, Petite compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(0x3c.longle+247)    bytele    0    
          // uh oh indirect offset
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }

          if m4 {
            // >>>>>(&0x104.longle+(-4))    string    "=!sfx!"    \b, ACE self-extracting archive
            // uh oh indirect offset
            // uh oh unhandled kind

          }
        }
        // >>>(0x3c.longle+248)    search/0x140    ".WISE"    \b, WISE installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+248)    search/0x140    ".dz\x00\x00\x00"    \b, Dzip self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>&(0x3c.longle+248)    search/0x100    "_winzip_"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>&(0x3c.longle+248)    search/0x100    "SharedD"    \b, Microsoft Installer self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>0x30    string    "Inno"    \b, InnoSetup self-extracting archive
        off = pageOff + 48
        // uh oh unhandled kind

      }
      // >>(0x3c.longle)    string    "PE\x00\x00"    MS-DOS executable
      // uh oh indirect offset
      // uh oh unhandled kind

      // >>(0x3c.longle)    string    "NE"    \b, NE
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+54)    bytele    1    for OS/2 1.x
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with for OS/2 1.x
        }

        // >>>(0x3c.longle+54)    bytele    2    for MS Windows 3.x
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with for MS Windows 3.x
        }

        // >>>(0x3c.longle+54)    bytele    3    for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with for MS-DOS
        }

        // >>>(0x3c.longle+54)    bytele    4    for Windows 386
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          // do something with for Windows 386
        }

        // >>>(0x3c.longle+54)    bytele    5    for Borland Operating System Services
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x5)
        }
        if m3 {
          // do something with for Borland Operating System Services
        }

        // >>>(0x3c.longle+54)    default    
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>(0x3c.longle+54)    bytele    0    (unknown OS %x)
          // uh oh indirect offset
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with (unknown OS %x)
          }

        }
        // >>>(0x3c.longle+54)    bytele    81    for MS-DOS, Phar Lap DOS extender
        // uh oh indirect offset
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (uint64(iv) == 0x81)
        }
        if m3 {
          // do something with for MS-DOS, Phar Lap DOS extender
        }

        // >>>(0x3c.longle+12)    shortle    8002&0x8003    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8002)
        }
        if m3 {
          // do something with (DLL)
        }

        // >>>(0x3c.longle+12)    shortle    8001&0x8003    (driver)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          // do something with (driver)
        }

        // >>>&(&0x24.shortle-1)    string    "ARJSFX"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>(0x3c.longle+112)    search/0x80    "WinZip(R) Self-Extractor"    \b, ZIP self-extracting archive (WinZip)
        // uh oh indirect offset
        // uh oh unhandled kind

      }
      // >>(0x3c.longle)    string    "LX\x00\x00"    \b, LX
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) < 0x1)
        }
        if m3 {
          // do something with (unknown OS)
        }

        // >>>(0x3c.longle+10)    shortle    1    for OS/2
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with for OS/2
        }

        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with for MS Windows
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with for DOS
        }

        // >>>(0x3c.longle+10)    shortle    3    (unknown OS)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (int64(int16(iv)) > 0x3)
        }
        if m3 {
          // do something with (unknown OS)
        }

        // >>>(0x3c.longle+16)    longle    8000&0x28000    (DLL)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x8000)
        }
        if m3 {
          // do something with (DLL)
        }

        // >>>(0x3c.longle+16)    longle    0&0x20000    (device driver)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          // do something with (device driver)
        }

        // >>>(0x3c.longle+16)    longle    300&0x300    (GUI)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x300)
        }
        if m3 {
          // do something with (GUI)
        }

        // >>>(0x3c.longle+16)    longle    300&0x28300    (console)
        // uh oh indirect offset
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x300)
        }
        if m3 {
          // do something with (console)
        }

        // >>>(0x3c.longle+8)    shortle    1    i80286
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with i80286
        }

        // >>>(0x3c.longle+8)    shortle    2    i80386
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with i80386
        }

        // >>>(0x3c.longle+8)    shortle    3    i80486
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with i80486
        }

        // >>>(0x8.shortle*16)    string    "emx"    \b, emx
        // uh oh indirect offset
        // uh oh unhandled kind

        if m3 {
          // >>>>&0x1    string    "x"    %s
          off = pageOff + 1
          // uh oh unhandled kind

        }
        // >>>&(&0x54.longle-3)    string    "arjsfx"    \b, ARJ self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

      }
      // >>(0x3c.longle)    string    "W3"    \b, W3 for MS Windows
      // uh oh indirect offset
      // uh oh unhandled kind

      // >>(0x3c.longle)    string    "LE\x00\x00"    \b, LE executable
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>(0x3c.longle+10)    shortle    1    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }

        if m3 {
          // >>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind

          // >>>>0x240    search/0x200    "WATCOM C/C++"    for MS-DOS, DOS4GW DOS extender
          off = pageOff + 576
          // uh oh unhandled kind

          // >>>>0x440    search/0x100    "CauseWay DOS Extender"    for MS-DOS, CauseWay DOS extender
          off = pageOff + 1088
          // uh oh unhandled kind

          // >>>>0x40    search/0x40    "PMODE/W"    for MS-DOS, PMODE/W DOS extender
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>0x40    search/0x40    "STUB/32A"    for MS-DOS, DOS/32A DOS extender (stub)
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>0x40    search/0x80    "STUB/32C"    for MS-DOS, DOS/32A DOS extender (configurable stub)
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>0x40    search/0x80    "DOS/32A"    for MS-DOS, DOS/32A DOS extender (embedded)
          off = pageOff + 64
          // uh oh unhandled kind

          // >>>>&0x24    longle    50    
          off = pageOff + 36
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) < 0x50)
          }

          if m4 {
            // >>>>>(&0x4c.longle)    string    "\xfc\xb8WATCOM"    
            // uh oh indirect offset
            // uh oh unhandled kind

            if m5 {
              // >>>>>>&0x0    search/0x8    "3\xdbf\xb9"    \b, 32Lite compressed
              off = pageOff + 0
              // uh oh unhandled kind

            }
          }
        }
        // >>>(0x3c.longle+10)    shortle    2    for MS Windows
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with for MS Windows
        }

        // >>>(0x3c.longle+10)    shortle    3    for DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x3)
        }
        if m3 {
          // do something with for DOS
        }

        // >>>(0x3c.longle+10)    shortle    4    for MS Windows (VxD)
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          // do something with for MS Windows (VxD)
        }

        // >>>(&0x7c.longle+38)    string    "UPX"    \b, UPX compressed
        // uh oh indirect offset
        // uh oh unhandled kind

        // >>>&(&0x54.longle-3)    string    "UNACE"    \b, ACE self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

      }
      // >>0x3c    longle    20000000    
      off = pageOff + 60
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x20000000)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    \b, MZ for MS-DOS
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }
        if m3 {
          // do something with \b, MZ for MS-DOS
        }

      }
    }
    // >0x2    longle    0    
    off = pageOff + 2
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) != 0x0)
    }

    if m1 {
      // >>0x18    shortle    40    
      off = pageOff + 24
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) < 0x40)
      }

      if m2 {
        // >>>(0x4.shortle*512)    shortle    14c    
        // uh oh indirect offset
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) != 0x14c)
        }

        if m3 {
          // >>>>&(0x2.shortle-514)    string    "LE"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x-2    string    "BW"    \b, MZ for MS-DOS
            off = pageOff + -2
            // uh oh unhandled kind

          }
          // >>>>&(0x2.shortle-514)    string    "LE"    \b, LE
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    for MS-DOS, DOS4GW DOS extender
            off = pageOff + 576
            // uh oh unhandled kind

          }
          // >>>>&(0x2.shortle-514)    string    "BW"    
          // uh oh indirect offset
          // uh oh unhandled kind

          if m4 {
            // >>>>>0x240    search/0x100    "DOS/4G"    \b, LE for MS-DOS, DOS4GW DOS extender (embedded)
            off = pageOff + 576
            // uh oh unhandled kind

            // >>>>>0x240    search/0x100    "!DOS/4G"    \b, BW collection for MS-DOS
            off = pageOff + 576
            // uh oh unhandled kind

          }
        }
      }
    }
    // >(0x4.shortle*512)    shortle    14c    \b, COFF
    // uh oh indirect offset
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x14c)
    }
    if m1 {
      // do something with \b, COFF
    }

    if m1 {
      // >>(0x8.shortle*16)    string    "go32stub"    for MS-DOS, DJGPP go32 DOS extender
      // uh oh indirect offset
      // uh oh unhandled kind

      // >>(0x8.shortle*16)    string    "emx"    
      // uh oh indirect offset
      // uh oh unhandled kind

      if m2 {
        // >>>&0x1    string    "x"    for DOS, Win or OS/2, emx %s
        off = pageOff + 1
        // uh oh unhandled kind

      }
      // >>&(&0x42.longle-3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x26    string    "UPX"    \b, UPX compressed
        off = pageOff + 38
        // uh oh unhandled kind

      }
      // >>&0x2c    search/0xa0    ".text"    
      off = pageOff + 44
      // uh oh unhandled kind

      if m2 {
        // >>>&0xb    longle    2000    
        off = pageOff + 11
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) < 0x2000)
        }

        if m3 {
          // >>>>&0x0    longle    6000    \b, 32lite compressed
          off = pageOff + 0
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x6000)
          }
          if m4 {
            // do something with \b, 32lite compressed
          }

        }
      }
    }
    // >(0x8.shortle*16)    string    "$WdX"    \b, WDos/X DOS extender
    // uh oh indirect offset
    // uh oh unhandled kind

    // >0x35    string    "\x8e\xc0\xb9\b\x00\xf3\xa5Ju\xeb\x8eÎ\xd83\xff\xbe0\x00\x05"    \b, aPack compressed
    off = pageOff + 53
    // uh oh unhandled kind

    // >0xe7    string    "LH/2 "    Self-Extract \b, %s
    off = pageOff + 231
    // uh oh unhandled kind

    // >0x1c    string    "UC2X"    \b, UCEXE compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "WWP "    \b, WWPACK compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "RJSX"    \b, ARJ self-extracting archive
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "diet"    \b, diet compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "LZ09"    \b, LZEXE v0.90 compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "LZ91"    \b, LZEXE v0.91 compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1c    string    "tz"    \b, TinyProg compressed
    off = pageOff + 28
    // uh oh unhandled kind

    // >0x1e    string    "Copyright 1989-1990 PKWARE Inc."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind

    // >0x1e    string    "PKLITE Copr."    Self-extracting PKZIP archive
    off = pageOff + 30
    // uh oh unhandled kind

    // >0x20    search/0xe0    "aRJsfX"    \b, ARJ self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind

    // >0x20    string    "AIN"    
    off = pageOff + 32
    // uh oh unhandled kind

    if m1 {
      // >>0x23    string    "2"    \b, AIN 2.x compressed
      off = pageOff + 35
      // uh oh unhandled kind

      // >>0x23    string    "<2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind

      // >>0x23    string    ">2"    \b, AIN 1.x compressed
      off = pageOff + 35
      // uh oh unhandled kind

    }
    // >0x24    string    "LHa's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x24    string    "LHA's SFX"    \b, LHa self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x24    string    " $ARX"    \b, ARX self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x24    string    " $LHarc"    \b, LHarc self-extracting archive
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x20    string    "SFX by LARC"    \b, LARC self-extracting archive
    off = pageOff + 32
    // uh oh unhandled kind

    // >0x40    string    "aPKG"    \b, aPackage self-extracting archive
    off = pageOff + 64
    // uh oh unhandled kind

    // >0x64    string    "W Collis\x00\x00"    \b, Compack compressed
    off = pageOff + 100
    // uh oh unhandled kind

    // >0x7a    string    "Windows self-extracting ZIP"    \b, ZIP self-extracting archive
    off = pageOff + 122
    // uh oh unhandled kind

    if m1 {
      // >>&0xf4    search/0x140    "\x00@\x01\x00"    
      off = pageOff + 244
      // uh oh unhandled kind

      if m2 {
        // >>>(&0x0.longle+(4))    string    "MSCF"    \b, WinHKI CAB self-extracting archive
        // uh oh indirect offset
        // uh oh unhandled kind

      }
    }
    // >0x666    string    "-lh5-"    \b, LHa self-extracting archive v2.13S
    off = pageOff + 1638
    // uh oh unhandled kind

    // >0x17888    string    "Rar!"    \b, RAR self-extracting archive
    off = pageOff + 96392
    // uh oh unhandled kind

    // >(0x4.shortle*512)    longle    0    
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>&(0x2.shortle-517)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>&0x0    string    "PK\x03\x04"    \b, ZIP self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "Rar!"    \b, RAR self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x11"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x12"    \b, AIN 2.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x17"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x0    string    "=!\x18"    \b, AIN 1.x self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

        // >>>&0x7    search/0x190    "**ACE**"    \b, ACE self-extracting archive
        off = pageOff + 7
        // uh oh unhandled kind

        // >>>&0x0    search/0x480    "UC2SFX Header"    \b, UC2 self-extracting archive
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
    // >(0x8.shortle*16)    search/0x20    "PKSFX"    \b, ZIP self-extracting archive (PKZIP)
    // uh oh indirect offset
    // uh oh unhandled kind

    // >0xc289    string    "y\xff\x80\xffv\xff"    \b, CODEC archive v3.21
    off = pageOff + 49801
    // uh oh unhandled kind

    if m1 {
      // >>0xc2a0    shortle    1    \b, 1 file
      off = pageOff + 49824
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }
      if m2 {
        // do something with \b, 1 file
      }

      // >>0xc2a0    shortle    1    \b, %u files
      off = pageOff + 49824
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (int64(int16(iv)) > 0x1)
      }
      if m2 {
        // do something with \b, %u files
      }

    }
  }
  // 0x0    string    "KCF"    FreeDOS KEYBoard Layout collection
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, version 0x%x
    }

    // >0x6    ubytele    0    
    off = pageOff + 6
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x7    string    ">\x00"    \b, author=%-.14s
      off = pageOff + 7
      // uh oh unhandled kind

      // >>0x7    search/0xfe    "\xff"    \b, info=
      off = pageOff + 7
      // uh oh unhandled kind

      if m2 {
        // >>>&0x0    string    "x"    \b%-.15s
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    string    "KLF"    FreeDOS KEYBoard Layout file
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x3    ushortle    0    \b, version 0x%x
    off = pageOff + 3
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, version 0x%x
    }

    // >0x5    ubytele    0    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x8    string    "x"    \b, name=%-.2s
      off = pageOff + 8
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "\xffKEYB   \x00\x00\x00\x00"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "\x00\x00\x00\x00`\x04\xf0"    MS-DOS KEYBoard Layout file
    off = pageOff + 12
    // uh oh unhandled kind

  }
  // 0x0    uquadle    ffffffff&0x7a0ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0xffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    513c00000000012    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x513c00000000012)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    32f28000ffff0016    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x32f28000ffff0016)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7f00000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x7f00000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    1600000000ffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x1600000000ffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    bf708c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0xbf708c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    uquadle    7bd08c2ffffffff    
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x7bd08c2ffffffff)
  }

  if m0 {
    // >0x0    use   msdos-driver    
    off = pageOff + 0
    // uh oh unhandled kind

  }
  // 0x0    ubytele    8c    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0x8c)
  }

  if m0 {
    // >0x4    string    "O===="    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "MAIN"    
      off = pageOff + 5
      // uh oh unhandled kind

      if m2 {
        // >>>0x4    ubytele    d    DOS executable (COM, 0x8C-variant)
        off = pageOff + 4
        {
          iv, ok := readUint8le(tb, off)
          m3 = ok && (int64(int8(iv)) > 0xd)
        }
        if m3 {
          // do something with DOS executable (COM, 0x8C-variant)
        }

      }
    }
  }
  // 0x0    ulongle    ffff10eb    DR-DOS executable (COM)
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0xffff10eb)
  }
  if m0 {
    // do something with DR-DOS executable (COM)
  }

  // 0x0    ushortbe    eb00&0xeb8d    
  off = pageOff + 0
  {
    iv, ok := readUint16be(tb, off)
    m0 = ok && (int64(int16(iv)) > 0xeb00)
  }

  // 0x0    bytele    eb    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0xeb)
  }

  if m0 {
    // >0x1    bytele    -1    
    off = pageOff + 1
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > -1)
    }

    if m1 {
      // >>(0x1.bytele+2)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    bytele    e9    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0xe9)
  }

  if m0 {
    // >0x1    shortle    -1    
    off = pageOff + 1
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > -1)
    }

    if m1 {
      // >>(0x1.shortle+3)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
    // >0x1    shortle    -103    
    off = pageOff + 1
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) < -259)
    }

    if m1 {
      // >>(0x1.shortle+65539)    bytele    0    
      // uh oh indirect offset
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      if m2 {
        // >>>0x0    use   msdos-com    
        off = pageOff + 0
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    ubytele    b8    
  off = pageOff + 0
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (uint64(iv) == 0xb8)
  }

  if m0 {
    // >0x0    string    "\xb8\xc0\a\x8e"    
    off = pageOff + 0
    // uh oh unhandled kind

    if m1 {
      // >>0x1    longle    21cd4cfe&0xfffffffe    COM executable (32-bit COMBOOT
      off = pageOff + 1
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) == 0x21cd4cfe)
      }
      if m2 {
        // do something with COM executable (32-bit COMBOOT
      }

      if m2 {
        // >>>0x1    longle    21cd4cff    \b)
        off = pageOff + 1
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cff)
        }
        if m3 {
          // do something with \b)
        }

        // >>>0x1    longle    21cd4cfe    \b, relocatable)
        off = pageOff + 1
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x21cd4cfe)
        }
        if m3 {
          // do something with \b, relocatable)
        }

      }
      // >>0x1    default    COM executable for DOS
      off = pageOff + 1
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "\x81\xfc"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    "w\x02\xcd \xb9"    
    off = pageOff + 4
    // uh oh unhandled kind

    if m1 {
      // >>0x24    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
      off = pageOff + 36
      // uh oh unhandled kind

    }
  }
  // 0xfc    string    "Must have DOS version"    DR-DOS executable (COM)
  off = pageOff + 252
  // uh oh unhandled kind

  // 0x22    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 34
  // uh oh unhandled kind

  // 0x23    string    "UPX!"    FREE-DOS executable (COM), UPX compressed
  off = pageOff + 35
  // uh oh unhandled kind

  // 0x2    string    "\xcd!"    COM executable for DOS
  off = pageOff + 2
  // uh oh unhandled kind

  // 0x4    string    "\xcd!"    COM executable for DOS
  off = pageOff + 4
  // uh oh unhandled kind

  // 0x5    string    "\xcd!"    COM executable for DOS
  off = pageOff + 5
  // uh oh unhandled kind

  // 0x7    string    "\xcd!"    
  off = pageOff + 7
  // uh oh unhandled kind

  if m0 {
    // >0x0    bytele    b8    COM executable for DOS
    off = pageOff + 0
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0xb8)
    }
    if m1 {
      // do something with COM executable for DOS
    }

  }
  // 0xa    string    "\xcd!"    
  off = pageOff + 10
  // uh oh unhandled kind

  if m0 {
    // >0x5    string    "\xcd!"    COM executable for DOS
    off = pageOff + 5
    // uh oh unhandled kind

  }
  // 0xd    string    "\xcd!"    COM executable for DOS
  off = pageOff + 13
  // uh oh unhandled kind

  // 0x12    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 18
  // uh oh unhandled kind

  // 0x17    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 23
  // uh oh unhandled kind

  // 0x1e    string    "\xcd!"    COM executable for MS-DOS
  off = pageOff + 30
  // uh oh unhandled kind

  // 0x46    string    "\xcd!"    COM executable for DOS
  off = pageOff + 70
  // uh oh unhandled kind

  // 0x6    search/0xa    "\xfcW\xf3\xa5\xc3"    COM executable for MS-DOS
  off = pageOff + 6
  // uh oh unhandled kind

  // 0x6    search/0xa    "\xfcW\xf3\xa4\xc3"    COM executable for DOS
  off = pageOff + 6
  // uh oh unhandled kind

  if m0 {
    // >0x18    search/0x10    "P\xa4\xff\xd5s"    \b, aPack compressed
    off = pageOff + 24
    // uh oh unhandled kind

  }
  // 0x3c    string    "W Collis\x00\x00"    COM executable for MS-DOS, Compack compressed
  off = pageOff + 60
  // uh oh unhandled kind

  // 0x0    string    "LZ"    MS-DOS executable (built-in)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1AAFB\r\x00OM\x06\x0e+4\x01\x01\x01\xff"    AAF legacy file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      // do something with (512B sectors)
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      // do something with (4kB sectors)
    }

  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1\x01\x02\x01\r\x00\x02\x00\x00\x06\x0e+4\x03\x02\x01\x01"    AAF file using MS Structured Storage
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x1e    bytele    9    (512B sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      // do something with (512B sectors)
    }

    // >0x1e    bytele    c    (4kB sectors)
    off = pageOff + 30
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xc)
    }
    if m1 {
      // do something with (4kB sectors)
    }

  }
  // 0x820    string    "Microsoft Word 6.0 Document"    %s
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x820    string    "Documento Microsoft Word 6"    Spanish Microsoft Word 6 document data
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x840    string    "MSWordDoc"    Microsoft Word document data
  off = pageOff + 2112
  // uh oh unhandled kind

  // 0x0    longbe    31be0000    Microsoft Word Document
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x31be0000)
  }
  if m0 {
    // do something with Microsoft Word Document
  }

  // 0x0    string    "PO^Q`"    Microsoft Word 6.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x4    longle    0    
  off = pageOff + 4
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x0)
  }

  if m0 {
    // >0x0    longbe    fe320000    Microsoft Word for Macintosh 1.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe320000)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 1.0
    }

    // >0x0    longbe    fe340000    Microsoft Word for Macintosh 3.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe340000)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 3.0
    }

    // >0x0    longbe    fe37001c    Microsoft Word for Macintosh 4.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe37001c)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 4.0
    }

    // >0x0    longbe    fe370023    Microsoft Word for Macintosh 5.0
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0xfe370023)
    }
    if m1 {
      // do something with Microsoft Word for Macintosh 5.0
    }

  }
  // 0x0    string    "ۥ-\x00\x00\x00"    Microsoft Word 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x200    string    "\xec\xa5\xc1"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind

  // 0x0    string    "ۥ-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x820    string    "Microsoft Excel 5.0 Worksheet"    %s
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x0    string    "ۥ-\x00"    Microsoft WinWord 2.0 Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x820    string    "Foglio di lavoro Microsoft Exce"    %s
  off = pageOff + 2080
  // uh oh unhandled kind

  // 0x842    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2114
  // uh oh unhandled kind

  // 0x849    string    "Biff5"    Microsoft Excel 5.0 Worksheet
  off = pageOff + 2121
  // uh oh unhandled kind

  // 0x0    string    "\t\x04\x06\x00\x00\x00\x10\x00"    Microsoft Excel Worksheet
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    longbe    1a00    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x1a00)
  }

  if m0 {
    // >0x14    ubytele    0    
    off = pageOff + 20
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x0)
    }

    if m1 {
      // >>0x14    ubytele    20    Lotus 1-2-3
      off = pageOff + 20
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) < 0x20)
      }
      if m2 {
        // do something with Lotus 1-2-3
      }

      if m2 {
        // >>>0x4    ushortle    1000    WorKsheet, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1000)
        }
        if m3 {
          // do something with WorKsheet, version 3
        }

        // >>>0x4    ushortle    1002    WorKsheet, version 4
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1002)
        }
        if m3 {
          // do something with WorKsheet, version 4
        }

        // >>>0x4    ushortle    1003    WorKsheet, version 97
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1003)
        }
        if m3 {
          // do something with WorKsheet, version 97
        }

        // >>>0x4    ushortle    1005    WorKsheet, version 9.8 Millennium
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1005)
        }
        if m3 {
          // do something with WorKsheet, version 9.8 Millennium
        }

        // >>>0x4    ushortle    8001    FoRMatting data
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8001)
        }
        if m3 {
          // do something with FoRMatting data
        }

        // >>>0x4    ushortle    8007    ForMatting data, version 3
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          // do something with ForMatting data, version 3
        }

        // >>>0x4    default    unknown
        off = pageOff + 4
        // uh oh unhandled kind

        if m3 {
          // >>>>0x6    ushortle    4    worksheet
          off = pageOff + 6
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x4)
          }
          if m4 {
            // do something with worksheet
          }

          // >>>>0x6    ushortle    4    formatting data
          off = pageOff + 6
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) != 0x4)
          }
          if m4 {
            // do something with formatting data
          }

          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b, revision 0x%x
          }

        }
        // >>>0x6    ushortle    4    \b, cell range
        off = pageOff + 6
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x4)
        }
        if m3 {
          // do something with \b, cell range
        }

        if m3 {
          // >>>>0x8    ulongle    0    
          off = pageOff + 8
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (uint64(iv) != 0x0)
          }

          if m4 {
            // >>>>>0xa    ubytele    0    \b%d*
            off = pageOff + 10
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (int64(int8(iv)) > 0x0)
            }
            if m5 {
              // do something with \b%d*
            }

            // >>>>>0x8    ushortle    0    \b%d,
            off = pageOff + 8
            {
              iv, ok := readUint16le(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              // do something with \b%d,
            }

            // >>>>>0xb    ubytele    0    \b%d-
            off = pageOff + 11
            {
              iv, ok := readUint8le(tb, off)
              m5 = ok && (uint64(iv) == 0x0)
            }
            if m5 {
              // do something with \b%d-
            }

          }
          // >>>>0xe    ubytele    0    \b%d*
          off = pageOff + 14
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x0)
          }
          if m4 {
            // do something with \b%d*
          }

          // >>>>0xc    ushortle    0    \b%d,
          off = pageOff + 12
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b%d,
          }

          // >>>>0xf    ubytele    0    \b%d
          off = pageOff + 15
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b%d
          }

          // >>>>0x14    ubytele    1    \b, character set 0x%x
          off = pageOff + 20
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (int64(int8(iv)) > 0x1)
          }
          if m4 {
            // do something with \b, character set 0x%x
          }

          // >>>>0x15    ubytele    0    \b, flags 0x%x
          off = pageOff + 21
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b, flags 0x%x
          }

        }
        // >>>0x6    ushortle    4    
        off = pageOff + 6
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) != 0x4)
        }

        if m3 {
          // >>>>0x1e    search/0x1d    "\x00\xae"    
          off = pageOff + 30
          // uh oh unhandled kind

          if m4 {
            // >>>>>&0x4    string    ">\x00"    \b, 1st font "%s"
            off = pageOff + 4
            // uh oh unhandled kind

          }
        }
      }
    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x7    ubytele    0    
    off = pageOff + 7
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x6    ubytele    0    Lotus
      off = pageOff + 6
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }
      if m2 {
        // do something with Lotus
      }

      if m2 {
        // >>>0x4    ushortle    7    1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x7)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.x (PGRAPH.CNF)
        }

        // >>>0x4    ushortle    c05    1-2-3 CoNFiguration, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0xc05)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.4J
        }

        // >>>0x4    ushortle    801    1-2-3 CoNFiguration, version 1-2.1
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x801)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 1-2.1
        }

        // >>>0x4    ushortle    802    Symphony CoNFiguration
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x802)
        }
        if m3 {
          // do something with Symphony CoNFiguration
        }

        // >>>0x4    ushortle    804    1-2-3 CoNFiguration, version 2.2
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x804)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.2
        }

        // >>>0x4    ushortle    80a    1-2-3 CoNFiguration, version 2.3-2.4
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x80a)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 2.3-2.4
        }

        // >>>0x4    ushortle    1402    1-2-3 CoNFiguration, version 3.x
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1402)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 3.x
        }

        // >>>0x4    ushortle    1450    1-2-3 CoNFiguration, version 4.x
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x1450)
        }
        if m3 {
          // do something with 1-2-3 CoNFiguration, version 4.x
        }

        // >>>0x4    ushortle    404    1-2-3 WorKSheet, version 1
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x404)
        }
        if m3 {
          // do something with 1-2-3 WorKSheet, version 1
        }

        // >>>0x4    ushortle    405    Symphony WoRksheet, version 1.0
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x405)
        }
        if m3 {
          // do something with Symphony WoRksheet, version 1.0
        }

        // >>>0x4    ushortle    406    1-2-3/Symphony worksheet, version 2
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x406)
        }
        if m3 {
          // do something with 1-2-3/Symphony worksheet, version 2
        }

        // >>>0x4    ushortle    600    1-2-3 WorKsheet, version 1.xJ
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x600)
        }
        if m3 {
          // do something with 1-2-3 WorKsheet, version 1.xJ
        }

        // >>>0x4    ushortle    602    1-2-3 worksheet, version 2.4J
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x602)
        }
        if m3 {
          // do something with 1-2-3 worksheet, version 2.4J
        }

        // >>>0x4    ushortle    8006    1-2-3 ForMaTting data, version 2.x
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8006)
        }
        if m3 {
          // do something with 1-2-3 ForMaTting data, version 2.x
        }

        // >>>0x4    ushortle    8007    1-2-3 FoRMatting data, version 2.0
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x8007)
        }
        if m3 {
          // do something with 1-2-3 FoRMatting data, version 2.0
        }

        // >>>0x4    default    unknown worksheet or configuration
        off = pageOff + 4
        // uh oh unhandled kind

        if m3 {
          // >>>>0x4    ushortle    0    \b, revision 0x%x
          off = pageOff + 4
          {
            iv, ok := readUint16le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with \b, revision 0x%x
          }

        }
        // >>>0x6    use   lotus-cells    
        off = pageOff + 6
        // uh oh unhandled kind

        // >>>(0x8.shortle+10)    use   lotus-cells    
        // uh oh indirect offset
        // uh oh unhandled kind

      }
    }
  }
  // 0x0    string    "WordPro\x00"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "WordPro\r\xfb"    Lotus WordPro
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "q\xa8\x00\x00\x01\x02"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xc    string    "Stirling Technologies,"    InstallShield Uninstall Script
    off = pageOff + 12
    // uh oh unhandled kind

  }
  // 0x0    string    "Nullsoft AVS Preset "    Winamp plug in
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xd7\xcdƚ"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x02\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x01\x00\t\x00"    ms-windows metafont .wmf
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x03\x01\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x03\x02\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x03\x03\x01\x048\x01\x00\x00"    tz3 ms-works file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW5\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW6\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW7\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW8\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00?\x03\x05\x003\x9fW9\x17\xb6i4\x05%A\x9b\x11\x02"    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\x89\x00\x95\x03\x05\x002R\x87\xc4@\xe5\""    PGP sig
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "MDIF\x1a\x00\b\x00\x00\x00\xfa&@}\x01\x00\x01\x1e\x01\x00"    MS Windows special zipped file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "BA(\x00\x00\x00.\x00\x00\x00\x00\x00\x00\x00"    Icon for MS Windows
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    longbe    100    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x100)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    bytele    0    
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }

      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    longbe    200    
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0x200)
  }

  if m0 {
    // >0x9    bytele    0    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
    // >0x9    ubytele    ff    
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0xff)
    }

    if m1 {
      // >>0x0    use   cur-ico-dir    
      off = pageOff + 0
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "PK\b\bBGI"    Borland font
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind

  }
  // 0x0    string    "pk\b\bBGI"    Borland device
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x4    string    ">\x00"    %s
    off = pageOff + 4
    // uh oh unhandled kind

  }
  // 0x0    longle    4    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x4)
  }

  if m0 {
    // >0xc    longle    118    Windows Recycle Bin INFO2 file (Win98 or below)
    off = pageOff + 12
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x118)
    }
    if m1 {
      // do something with Windows Recycle Bin INFO2 file (Win98 or below)
    }

  }
  // 0x0    longle    5    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x5)
  }

  if m0 {
    // >0xc    longle    320    Windows Recycle Bin INFO2 file (Win2k - WinXP)
    off = pageOff + 12
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x320)
    }
    if m1 {
      // do something with Windows Recycle Bin INFO2 file (Win2k - WinXP)
    }

  }
  // 0x9    string    "GERBILDOC"    First Choice document
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x9    string    "GERBILDB"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x9    string    "GERBILCLIP"    First Choice database
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x0    string    "GERBIL"    First Choice device file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x9    string    "RABBITGRAPH"    RabbitGraph file
  off = pageOff + 9
  // uh oh unhandled kind

  // 0x0    string    "DCU1"    Borland Delphi .DCU file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "=!<spell>"    MKS Spell hash list (old format)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "=!<spell2>"    MKS Spell hash list
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    longle    8086b70    TurboC BGI file
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x8086b70)
  }
  if m0 {
    // do something with TurboC BGI file
  }

  // 0x0    longle    8084b50    TurboC Font file
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x8084b50)
  }
  if m0 {
    // do something with TurboC Font file
  }

  // 0x0    string    "TPF0"    
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "PMCC"    Windows 3.x .GRP file
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x1    string    "RDC-meg"    MegaDots
  off = pageOff + 1
  // uh oh unhandled kind

  if m0 {
    // >0x8    bytele    2f    version %c
    off = pageOff + 8
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      // do something with version %c
    }

    // >0x9    bytele    2f    \b.%c file
    off = pageOff + 9
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) > 0x2f)
    }
    if m1 {
      // do something with \b.%c file
    }

  }
  // 0x0    longle    4c    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x4c)
  }

  if m0 {
    // >0x4    longle    21401    Windows shortcut file
    off = pageOff + 4
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x21401)
    }
    if m1 {
      // do something with Windows shortcut file
    }

  }
  // 0x171    string    "MICROSOFT PIFEX\x00"    Windows Program Information File
  off = pageOff + 369
  // uh oh unhandled kind

  if m0 {
    // >0x24    string    ">\x00"    \b for %.63s
    off = pageOff + 36
    // uh oh unhandled kind

    // >0x65    string    ">\x00"    \b, directory=%.64s
    off = pageOff + 101
    // uh oh unhandled kind

    // >0xa5    string    ">\x00"    \b, parameters=%.64s
    off = pageOff + 165
    // uh oh unhandled kind

    // >0x187    search/0xb55    "WINDOWS VMM 4.0\x00"    
    off = pageOff + 391
    // uh oh unhandled kind

    if m1 {
      // >>&0x5e    ubytele    0    
      off = pageOff + 94
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind

        // >>>&0x-1    string    ">PIFMGR.DLL"    \b, icon=%s
        off = pageOff + -1
        // uh oh unhandled kind

      }
      // >>&0xf0    ubytele    0    
      off = pageOff + 240
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

        // >>>&0x-1    string    ">Terminal"    \b, font=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

      }
      // >>&0x110    ubytele    0    
      off = pageOff + 272
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) > 0x0)
      }

      if m2 {
        // >>>&0x-1    string    "<Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

        // >>>&0x-1    string    ">Lucida Console"    \b, TrueTypeFont=%.32s
        off = pageOff + -1
        // uh oh unhandled kind

      }
    }
    // >0x187    search/0xb55    "WINDOWS NT  3.1\x00"    \b, Windows NT-style
    off = pageOff + 391
    // uh oh unhandled kind

    // >0x187    search/0xb55    "CONFIG  SYS 4.0\x00"    \b +CONFIG.SYS
    off = pageOff + 391
    // uh oh unhandled kind

    // >0x187    search/0xb55    "AUTOEXECBAT 4.0\x00"    \b +AUTOEXEC.BAT
    off = pageOff + 391
    // uh oh unhandled kind

  }
  // 0x0    longbe    c5d0d3c6    DOS EPS Binary File
  off = pageOff + 0
  {
    iv, ok := readUint32be(tb, off)
    m0 = ok && (uint64(iv) == 0xc5d0d3c6)
  }
  if m0 {
    // do something with DOS EPS Binary File
  }

  if m0 {
    // >0x4    longle    0    Postscript starts at byte %d
    off = pageOff + 4
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      // do something with Postscript starts at byte %d
    }

    if m1 {
      // >>0x8    longle    0    length %d
      off = pageOff + 8
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (int64(int32(iv)) > 0x0)
      }
      if m2 {
        // do something with length %d
      }

      if m2 {
        // >>>0xc    longle    0    Metafile starts at byte %d
        off = pageOff + 12
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          // do something with Metafile starts at byte %d
        }

        if m3 {
          // >>>>0x10    longle    0    length %d
          off = pageOff + 16
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with length %d
          }

        }
        // >>>0x14    longle    0    TIFF starts at byte %d
        off = pageOff + 20
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (int64(int32(iv)) > 0x0)
        }
        if m3 {
          // do something with TIFF starts at byte %d
        }

        if m3 {
          // >>>>0x18    longle    0    length %d
          off = pageOff + 24
          {
            iv, ok := readUint32le(tb, off)
            m4 = ok && (int64(int32(iv)) > 0x0)
          }
          if m4 {
            // do something with length %d
          }

        }
      }
    }
  }
  // 0x0    shortle    223e9f78    TNEF
  off = pageOff + 0
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (uint64(iv) == 0x223e9f78)
  }
  if m0 {
    // do something with TNEF
  }

  // 0x0    string    "NG\x00\x01"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x2    ulongle    100    Norton Guide
    off = pageOff + 2
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x100)
    }
    if m1 {
      // do something with Norton Guide
    }

    if m1 {
      // >>0x8    string    ">\x00"    "%-.40s"
      off = pageOff + 8
      // uh oh unhandled kind

      // >>0x30    string    ">\x00"    \b, %-.66s
      off = pageOff + 48
      // uh oh unhandled kind

      // >>0x72    string    ">\x00"    %-.66s
      off = pageOff + 114
      // uh oh unhandled kind

    }
  }
  // 0x0    ulongle    48443408    4DOS help file
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x48443408)
  }
  if m0 {
    // do something with 4DOS help file
  }

  if m0 {
    // >0x4    string    "x"    \b, version %-4.4s
    off = pageOff + 4
    // uh oh unhandled kind

  }
  // 0x0    uquadle    3a000000024e4c    MS Advisor help file
  off = pageOff + 0
  {
    iv, ok := readUint64le(tb, off)
    m0 = ok && (uint64(iv) == 0x3a000000024e4c)
  }
  if m0 {
    // do something with MS Advisor help file
  }

  // 0x0    string    "ITSF\x03\x00\x00\x00`\x00\x00\x00"    MS Windows HtmlHelp Data
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x2    string    "GFA-BASIC3"    GFA-BASIC 3 data
  off = pageOff + 2
  // uh oh unhandled kind

  // 0x0    string    "MSCF\x00\x00\x00\x00"    Microsoft Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x8    longle    0    \b, %u bytes
    off = pageOff + 8
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, %u bytes
    }

    // >0x1c    shortle    1    \b, 1 file
    off = pageOff + 28
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with \b, 1 file
    }

    // >0x1c    shortle    1    \b, %u files
    off = pageOff + 28
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %u files
    }

  }
  // 0x0    string    "ISc("    InstallShield Cabinet archive data
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x5    bytele    60&0xf0    version 6,
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      // do something with version 6,
    }

    // >0x5    bytele    60&0xf0    version 4/5,
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) != 0x60)
    }
    if m1 {
      // do something with version 4/5,
    }

    // >(0xc.longle+40)    longle    0    %u files
    // uh oh indirect offset
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with %u files
    }

  }
  // 0x0    string    "MSCE\x00\x00\x00\x00"    Microsoft WinCE install header
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x14    longle    0    \b, architecture-independent
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, architecture-independent
    }

    // >0x14    longle    67    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      // do something with \b, Hitachi SH3
    }

    // >0x14    longle    68    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      // do something with \b, Hitachi SH4
    }

    // >0x14    longle    a11    \b, StrongARM
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xa11)
    }
    if m1 {
      // do something with \b, StrongARM
    }

    // >0x14    longle    fa0    \b, MIPS R4000
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0xfa0)
    }
    if m1 {
      // do something with \b, MIPS R4000
    }

    // >0x14    longle    2713    \b, Hitachi SH3
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x2713)
    }
    if m1 {
      // do something with \b, Hitachi SH3
    }

    // >0x14    longle    2714    \b, Hitachi SH3E
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x2714)
    }
    if m1 {
      // do something with \b, Hitachi SH3E
    }

    // >0x14    longle    2715    \b, Hitachi SH4
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x2715)
    }
    if m1 {
      // do something with \b, Hitachi SH4
    }

    // >0x14    longle    11171    \b, ARM 7TDMI
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x11171)
    }
    if m1 {
      // do something with \b, ARM 7TDMI
    }

    // >0x34    shortle    1    \b, 1 file
    off = pageOff + 52
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with \b, 1 file
    }

    // >0x34    shortle    1    \b, %u files
    off = pageOff + 52
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %u files
    }

    // >0x38    shortle    1    \b, 1 registry entry
    off = pageOff + 56
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with \b, 1 registry entry
    }

    // >0x38    shortle    1    \b, %u registry entries
    off = pageOff + 56
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %u registry entries
    }

  }
  // 0x0    ulongle    1    
  off = pageOff + 0
  {
    iv, ok := readUint32le(tb, off)
    m0 = ok && (uint64(iv) == 0x1)
  }

  if m0 {
    // >0x28    string    " EMF"    Windows Enhanced Metafile (EMF) image data
    off = pageOff + 40
    // uh oh unhandled kind

    if m1 {
      // >>0x2c    ulongle    0    version 0x%x
      off = pageOff + 44
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with version 0x%x
      }

    }
  }
  // 0x0    string    "\xd0\xcf\x11\u0871\x1a\xe1"    Microsoft Office Document
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x222    string    "bjbj"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind

    // >0x222    string    "jbjb"    Microsoft Word Document
    off = pageOff + 546
    // uh oh unhandled kind

  }
  // 0x0    string    "\x94\xa6."    Microsoft Word Document
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x200    string    "R\x00o\x00o\x00t\x00 \x00E\x00n\x00t\x00r\x00y"    Microsoft Word Document
  off = pageOff + 512
  // uh oh unhandled kind

  // 0x0    string    "$RBU"    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x17    string    "Dell"    %s system BIOS
    off = pageOff + 23
    // uh oh unhandled kind

    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }

    if m1 {
      // >>0x30    bytele    0    version %d.
      off = pageOff + 48
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with version %d.
      }

      // >>0x31    bytele    0    \b%d.
      off = pageOff + 49
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d.
      }

      // >>0x32    bytele    0    \b%d
      off = pageOff + 50
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d
      }

    }
    // >0x5    bytele    2    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x2)
    }

    if m1 {
      // >>0x30    string    "x"    version %.3s
      off = pageOff + 48
      // uh oh unhandled kind

    }
  }
  // 0x0    string    "DDS |\x00\x00\x00"    Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x10    longle    0    %d x
    off = pageOff + 16
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      // do something with %d x
    }

    // >0xc    longle    0    %d,
    off = pageOff + 12
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (int64(int32(iv)) > 0x0)
    }
    if m1 {
      // do something with %d,
    }

    // >0x54    string    "x"    %.4s
    off = pageOff + 84
    // uh oh unhandled kind

  }
  // 0x0    string    "ITOLITLS"    Microsoft Reader eBook Data
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0x8    longle    0    \b, version %u
    off = pageOff + 8
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with \b, version %u
    }

  }
  // 0x0    string    "B000FF\n"    Windows Embedded CE binary image
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "MSWIM\x00\x00\x00"    Windows imaging (WIM) image
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "WLPWM\x00\x00\x00"    Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x03\x00"    Mallard BASIC program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x04\x00"    Mallard BASIC program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x03\x01"    Mallard BASIC protected program data (v1.11)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "\xfc\x04\x01"    Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "MIOPEN"    Mallard BASIC Jetsam data
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x0    string    "Jetsam0"    Mallard BASIC Jetsam index data
  off = pageOff + 0
  // uh oh unhandled kind

  // 0x3    ushortle    7bb    
  off = pageOff + 3
  {
    iv, ok := readUint16le(tb, off)
    m0 = ok && (int64(int16(iv)) > 0x7bb)
  }

  if m0 {
    // >0x5    ubytele    1f    
    off = pageOff + 5
    {
      iv, ok := readUint8le(tb, off)
      m1 = ok && (int64(int8(iv)) < 0x1f)
    }

    if m1 {
      // >>0x6    ubytele    c    
      off = pageOff + 6
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (int64(int8(iv)) < 0xc)
      }

      if m2 {
        // >>>0x7    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
        off = pageOff + 7
        // uh oh unhandled kind

        if m3 {
          // >>>>0x1    ubytele    0    DOS 2.0 backup id file, sequence %d
          off = pageOff + 1
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0x0)
          }
          if m4 {
            // do something with DOS 2.0 backup id file, sequence %d
          }

          // >>>>0x0    ubytele    ff    \b, last disk
          off = pageOff + 0
          {
            iv, ok := readUint8le(tb, off)
            m4 = ok && (uint64(iv) == 0xff)
          }
          if m4 {
            // do something with \b, last disk
          }

        }
      }
    }
  }
  // 0x53    ubytele    50    
  off = pageOff + 83
  {
    iv, ok := readUint8le(tb, off)
    m0 = ok && (int64(int8(iv)) < 0x50)
  }

  if m0 {
    // >0x54    string    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 84
    // uh oh unhandled kind

    if m1 {
      // >>0x5    string    "x"    DOS 2.0 backed up file %s,
      off = pageOff + 5
      // uh oh unhandled kind

      // >>0x0    ubytele    ff    complete file
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        // do something with complete file
      }

      // >>0x0    ubytele    ff    
      off = pageOff + 0
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) != 0xff)
      }

      if m2 {
        // >>>0x1    ushortle    0    split file, sequence %d
        off = pageOff + 1
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with split file, sequence %d
        }

      }
    }
  }
  // 0x0    string    "\x8bBACKUP "    
  off = pageOff + 0
  // uh oh unhandled kind

  if m0 {
    // >0xa    string    "\x00\x00\x00\x00\x00\x00\x00\x00"    
    off = pageOff + 10
    // uh oh unhandled kind

    if m1 {
      // >>0x9    ubytele    0    DOS 3.3 backup control file, sequence %d
      off = pageOff + 9
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with DOS 3.3 backup control file, sequence %d
      }

      // >>0x8a    ubytele    ff    \b, last disk
      off = pageOff + 138
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0xff)
      }
      if m2 {
        // do something with \b, last disk
      }

    }
  }
  return outStrings, nil
}

func IdentifyLotusCells__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x0    ulongbe    6000800    \b, cell range
    off = pageOff + 0
    {
      iv, ok := readUint32be(tb, off)
      m1 = ok && (uint64(iv) == 0x6000800)
    }
    if m1 {
      // do something with \b, cell range
    }

    if m1 {
      // >>0x4    ulongle    0    
      off = pageOff + 4
      {
        iv, ok := readUint32le(tb, off)
        m2 = ok && (uint64(iv) != 0x0)
      }

      if m2 {
        // >>>0x4    ushortle    0    \b%d,
        off = pageOff + 4
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with \b%d,
        }

        // >>>0x6    ushortle    0    \b%d-
        off = pageOff + 6
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with \b%d-
        }

      }
      // >>0x8    ushortle    0    \b%d,
      off = pageOff + 8
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d,
      }

      // >>0xa    ushortle    0    \b%d
      off = pageOff + 10
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with \b%d
      }

    }
  }
  return outStrings, nil
}

func IdentifyIcoEntry__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false

  if m0 {
    // >0x0    use   cur-ico-entry    
    off = pageOff + 0
    // uh oh unhandled kind

    // >0x4    ushortle    1    \b, %d planes
    off = pageOff + 4
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %d planes
    }

    // >0x6    ushortle    1    \b, %d bits/pixel
    off = pageOff + 6
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (int64(int16(iv)) > 0x1)
    }
    if m1 {
      // do something with \b, %d bits/pixel
    }

  }
  return outStrings, nil
}

func IdentifyElfLe__Swapped(tb []byte, pageOff int64) ([]string, error) {
  var outStrings []string
  var off int64
  var err error
  var ok bool
  m0 := false
  m1 := false
  m2 := false
  m3 := false

  if m0 {
    // >0x10    shortle    0    no file type,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with no file type,
    }

    // >0x10    shortle    1    relocatable,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with relocatable,
    }

    // >0x10    shortle    2    executable,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with executable,
    }

    // >0x10    shortle    3    shared object,
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      // do something with shared object,
    }

    // >0x10    shortle    4    core file
    off = pageOff + 16
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      // do something with core file
    }

    // >0x12    clear    
    off = pageOff + 18
    // uh oh unhandled kind

    // >0x12    shortle    0    no machine,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with no machine,
    }

    // >0x12    shortle    1    AT&T WE32100,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with AT&T WE32100,
    }

    // >0x12    shortle    2    SPARC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2)
    }
    if m1 {
      // do something with SPARC,
    }

    // >0x12    shortle    3    Intel 80386,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3)
    }
    if m1 {
      // do something with Intel 80386,
    }

    // >0x12    shortle    4    Motorola m68k,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4)
    }
    if m1 {
      // do something with Motorola m68k,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0    68020,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with 68020,
        }

      }
    }
    // >0x12    shortle    5    Motorola m88k,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5)
    }
    if m1 {
      // do something with Motorola m88k,
    }

    // >0x12    shortle    6    Intel 80486,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6)
    }
    if m1 {
      // do something with Intel 80486,
    }

    // >0x12    shortle    7    Intel 80860,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x7)
    }
    if m1 {
      // do something with Intel 80860,
    }

    // >0x12    shortle    8    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }
    if m1 {
      // do something with MIPS,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    a    MIPS,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      // do something with MIPS,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

    }
    // >0x12    shortle    8    
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8)
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    0&0xf0000000    MIPS-I
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with MIPS-I
        }

        // >>>0x24    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          // do something with MIPS-II
        }

        // >>>0x24    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          // do something with MIPS-III
        }

        // >>>0x24    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          // do something with MIPS-IV
        }

        // >>>0x24    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          // do something with MIPS-V
        }

        // >>>0x24    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          // do something with MIPS32
        }

        // >>>0x24    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          // do something with MIPS64
        }

        // >>>0x24    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          // do something with MIPS32 rel2
        }

        // >>>0x24    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          // do something with MIPS64 rel2
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    0&0xf0000000    MIPS-I
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with MIPS-I
        }

        // >>>0x30    longle    10000000&0xf0000000    MIPS-II
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x10000000)
        }
        if m3 {
          // do something with MIPS-II
        }

        // >>>0x30    longle    20000000&0xf0000000    MIPS-III
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x20000000)
        }
        if m3 {
          // do something with MIPS-III
        }

        // >>>0x30    longle    30000000&0xf0000000    MIPS-IV
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x30000000)
        }
        if m3 {
          // do something with MIPS-IV
        }

        // >>>0x30    longle    40000000&0xf0000000    MIPS-V
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x40000000)
        }
        if m3 {
          // do something with MIPS-V
        }

        // >>>0x30    longle    50000000&0xf0000000    MIPS32
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x50000000)
        }
        if m3 {
          // do something with MIPS32
        }

        // >>>0x30    longle    60000000&0xf0000000    MIPS64
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x60000000)
        }
        if m3 {
          // do something with MIPS64
        }

        // >>>0x30    longle    70000000&0xf0000000    MIPS32 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x70000000)
        }
        if m3 {
          // do something with MIPS32 rel2
        }

        // >>>0x30    longle    80000000&0xf0000000    MIPS64 rel2
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x80000000)
        }
        if m3 {
          // do something with MIPS64 rel2
        }

      }
    }
    // >0x12    shortle    9    Amdahl,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9)
    }
    if m1 {
      // do something with Amdahl,
    }

    // >0x12    shortle    a    MIPS (deprecated),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa)
    }
    if m1 {
      // do something with MIPS (deprecated),
    }

    // >0x12    shortle    b    RS6000,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb)
    }
    if m1 {
      // do something with RS6000,
    }

    // >0x12    shortle    f    PA-RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xf)
    }
    if m1 {
      // do something with PA-RISC,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x26    shortle    214    2.0
        off = pageOff + 38
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          // do something with 2.0
        }

      }
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x32    shortle    214    2.0
        off = pageOff + 50
        {
          iv, ok := readUint16le(tb, off)
          m3 = ok && (uint64(iv) == 0x214)
        }
        if m3 {
          // do something with 2.0
        }

      }
    }
    // >0x12    shortle    10    nCUBE,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x10)
    }
    if m1 {
      // do something with nCUBE,
    }

    // >0x12    shortle    11    Fujitsu VPP500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x11)
    }
    if m1 {
      // do something with Fujitsu VPP500,
    }

    // >0x12    shortle    12    SPARC32PLUS,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x12)
    }
    if m1 {
      // do something with SPARC32PLUS,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    100&0xffff00    V8+ Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x100)
        }
        if m3 {
          // do something with V8+ Required,
        }

        // >>>0x24    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with Sun UltraSPARC1 Extensions Required,
        }

        // >>>0x24    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          // do something with HaL R1 Extensions Required,
        }

        // >>>0x24    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          // do something with Sun UltraSPARC3 Extensions Required,
        }

      }
    }
    // >0x12    shortle    13    Intel 80960,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x13)
    }
    if m1 {
      // do something with Intel 80960,
    }

    // >0x12    shortle    14    PowerPC or cisco 4500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x14)
    }
    if m1 {
      // do something with PowerPC or cisco 4500,
    }

    // >0x12    shortle    15    64-bit PowerPC or cisco 7500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x15)
    }
    if m1 {
      // do something with 64-bit PowerPC or cisco 7500,
    }

    // >0x12    shortle    16    IBM S/390,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x16)
    }
    if m1 {
      // do something with IBM S/390,
    }

    // >0x12    shortle    17    Cell SPU,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x17)
    }
    if m1 {
      // do something with Cell SPU,
    }

    // >0x12    shortle    18    cisco SVIP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x18)
    }
    if m1 {
      // do something with cisco SVIP,
    }

    // >0x12    shortle    19    cisco 7200,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x19)
    }
    if m1 {
      // do something with cisco 7200,
    }

    // >0x12    shortle    24    NEC V800 or cisco 12000,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x24)
    }
    if m1 {
      // do something with NEC V800 or cisco 12000,
    }

    // >0x12    shortle    25    Fujitsu FR20,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x25)
    }
    if m1 {
      // do something with Fujitsu FR20,
    }

    // >0x12    shortle    26    TRW RH-32,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x26)
    }
    if m1 {
      // do something with TRW RH-32,
    }

    // >0x12    shortle    27    Motorola RCE,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x27)
    }
    if m1 {
      // do something with Motorola RCE,
    }

    // >0x12    shortle    28    ARM,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x28)
    }
    if m1 {
      // do something with ARM,
    }

    if m1 {
      // >>0x4    bytele    1    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x1)
      }

      if m2 {
        // >>>0x24    longle    4000000&0xff000000    EABI4
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x4000000)
        }
        if m3 {
          // do something with EABI4
        }

        // >>>0x24    longle    5000000&0xff000000    EABI5
        off = pageOff + 36
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x5000000)
        }
        if m3 {
          // do something with EABI5
        }

      }
    }
    // >0x12    shortle    29    Alpha,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x29)
    }
    if m1 {
      // do something with Alpha,
    }

    // >0x12    shortle    2a    Renesas SH,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2a)
    }
    if m1 {
      // do something with Renesas SH,
    }

    // >0x12    shortle    2b    SPARC V9,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2b)
    }
    if m1 {
      // do something with SPARC V9,
    }

    if m1 {
      // >>0x4    bytele    2    
      off = pageOff + 4
      {
        iv, ok := readUint8le(tb, off)
        m2 = ok && (uint64(iv) == 0x2)
      }

      if m2 {
        // >>>0x30    longle    200&0xffff00    Sun UltraSPARC1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x200)
        }
        if m3 {
          // do something with Sun UltraSPARC1 Extensions Required,
        }

        // >>>0x30    longle    400&0xffff00    HaL R1 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x400)
        }
        if m3 {
          // do something with HaL R1 Extensions Required,
        }

        // >>>0x30    longle    800&0xffff00    Sun UltraSPARC3 Extensions Required,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x800)
        }
        if m3 {
          // do something with Sun UltraSPARC3 Extensions Required,
        }

        // >>>0x30    longle    0&0x3    total store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x0)
        }
        if m3 {
          // do something with total store ordering,
        }

        // >>>0x30    longle    1&0x3    partial store ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x1)
        }
        if m3 {
          // do something with partial store ordering,
        }

        // >>>0x30    longle    2&0x3    relaxed memory ordering,
        off = pageOff + 48
        {
          iv, ok := readUint32le(tb, off)
          m3 = ok && (uint64(iv) == 0x2)
        }
        if m3 {
          // do something with relaxed memory ordering,
        }

      }
    }
    // >0x12    shortle    2c    Siemens Tricore Embedded Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2c)
    }
    if m1 {
      // do something with Siemens Tricore Embedded Processor,
    }

    // >0x12    shortle    2d    Argonaut RISC Core, Argonaut Technologies Inc.,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2d)
    }
    if m1 {
      // do something with Argonaut RISC Core, Argonaut Technologies Inc.,
    }

    // >0x12    shortle    2e    Renesas H8/300,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2e)
    }
    if m1 {
      // do something with Renesas H8/300,
    }

    // >0x12    shortle    2f    Renesas H8/300H,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2f)
    }
    if m1 {
      // do something with Renesas H8/300H,
    }

    // >0x12    shortle    30    Renesas H8S,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x30)
    }
    if m1 {
      // do something with Renesas H8S,
    }

    // >0x12    shortle    31    Renesas H8/500,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x31)
    }
    if m1 {
      // do something with Renesas H8/500,
    }

    // >0x12    shortle    32    IA-64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x32)
    }
    if m1 {
      // do something with IA-64,
    }

    // >0x12    shortle    33    Stanford MIPS-X,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x33)
    }
    if m1 {
      // do something with Stanford MIPS-X,
    }

    // >0x12    shortle    34    Motorola Coldfire,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x34)
    }
    if m1 {
      // do something with Motorola Coldfire,
    }

    // >0x12    shortle    35    Motorola M68HC12,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x35)
    }
    if m1 {
      // do something with Motorola M68HC12,
    }

    // >0x12    shortle    36    Fujitsu MMA,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x36)
    }
    if m1 {
      // do something with Fujitsu MMA,
    }

    // >0x12    shortle    37    Siemens PCP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x37)
    }
    if m1 {
      // do something with Siemens PCP,
    }

    // >0x12    shortle    38    Sony nCPU,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x38)
    }
    if m1 {
      // do something with Sony nCPU,
    }

    // >0x12    shortle    39    Denso NDR1,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x39)
    }
    if m1 {
      // do something with Denso NDR1,
    }

    // >0x12    shortle    3a    Start*Core,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3a)
    }
    if m1 {
      // do something with Start*Core,
    }

    // >0x12    shortle    3b    Toyota ME16,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3b)
    }
    if m1 {
      // do something with Toyota ME16,
    }

    // >0x12    shortle    3c    ST100,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3c)
    }
    if m1 {
      // do something with ST100,
    }

    // >0x12    shortle    3d    Tinyj emb.,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3d)
    }
    if m1 {
      // do something with Tinyj emb.,
    }

    // >0x12    shortle    3e    x86-64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3e)
    }
    if m1 {
      // do something with x86-64,
    }

    // >0x12    shortle    3f    Sony DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3f)
    }
    if m1 {
      // do something with Sony DSP,
    }

    // >0x12    shortle    40    DEC PDP-10,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x40)
    }
    if m1 {
      // do something with DEC PDP-10,
    }

    // >0x12    shortle    41    DEC PDP-11,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x41)
    }
    if m1 {
      // do something with DEC PDP-11,
    }

    // >0x12    shortle    42    FX66,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x42)
    }
    if m1 {
      // do something with FX66,
    }

    // >0x12    shortle    43    ST9+ 8/16 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x43)
    }
    if m1 {
      // do something with ST9+ 8/16 bit,
    }

    // >0x12    shortle    44    ST7 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x44)
    }
    if m1 {
      // do something with ST7 8 bit,
    }

    // >0x12    shortle    45    MC68HC16,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x45)
    }
    if m1 {
      // do something with MC68HC16,
    }

    // >0x12    shortle    46    MC68HC11,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x46)
    }
    if m1 {
      // do something with MC68HC11,
    }

    // >0x12    shortle    47    MC68HC08,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x47)
    }
    if m1 {
      // do something with MC68HC08,
    }

    // >0x12    shortle    48    MC68HC05,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x48)
    }
    if m1 {
      // do something with MC68HC05,
    }

    // >0x12    shortle    49    SGI SVx or Cray NV1,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x49)
    }
    if m1 {
      // do something with SGI SVx or Cray NV1,
    }

    // >0x12    shortle    4a    ST19 8 bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4a)
    }
    if m1 {
      // do something with ST19 8 bit,
    }

    // >0x12    shortle    4b    Digital VAX,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4b)
    }
    if m1 {
      // do something with Digital VAX,
    }

    // >0x12    shortle    4c    Axis cris,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4c)
    }
    if m1 {
      // do something with Axis cris,
    }

    // >0x12    shortle    4d    Infineon 32-bit embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4d)
    }
    if m1 {
      // do something with Infineon 32-bit embedded,
    }

    // >0x12    shortle    4e    Element 14 64-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4e)
    }
    if m1 {
      // do something with Element 14 64-bit DSP,
    }

    // >0x12    shortle    4f    LSI Logic 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4f)
    }
    if m1 {
      // do something with LSI Logic 16-bit DSP,
    }

    // >0x12    shortle    50    MMIX,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x50)
    }
    if m1 {
      // do something with MMIX,
    }

    // >0x12    shortle    51    Harvard machine-independent,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x51)
    }
    if m1 {
      // do something with Harvard machine-independent,
    }

    // >0x12    shortle    52    SiTera Prism,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x52)
    }
    if m1 {
      // do something with SiTera Prism,
    }

    // >0x12    shortle    53    Atmel AVR 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x53)
    }
    if m1 {
      // do something with Atmel AVR 8-bit,
    }

    // >0x12    shortle    54    Fujitsu FR30,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x54)
    }
    if m1 {
      // do something with Fujitsu FR30,
    }

    // >0x12    shortle    55    Mitsubishi D10V,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x55)
    }
    if m1 {
      // do something with Mitsubishi D10V,
    }

    // >0x12    shortle    56    Mitsubishi D30V,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x56)
    }
    if m1 {
      // do something with Mitsubishi D30V,
    }

    // >0x12    shortle    57    NEC v850,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x57)
    }
    if m1 {
      // do something with NEC v850,
    }

    // >0x12    shortle    58    Renesas M32R,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x58)
    }
    if m1 {
      // do something with Renesas M32R,
    }

    // >0x12    shortle    59    Matsushita MN10300,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x59)
    }
    if m1 {
      // do something with Matsushita MN10300,
    }

    // >0x12    shortle    5a    Matsushita MN10200,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5a)
    }
    if m1 {
      // do something with Matsushita MN10200,
    }

    // >0x12    shortle    5b    picoJava,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5b)
    }
    if m1 {
      // do something with picoJava,
    }

    // >0x12    shortle    5c    OpenRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5c)
    }
    if m1 {
      // do something with OpenRISC,
    }

    // >0x12    shortle    5d    ARC Cores Tangent-A5,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5d)
    }
    if m1 {
      // do something with ARC Cores Tangent-A5,
    }

    // >0x12    shortle    5e    Tensilica Xtensa,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5e)
    }
    if m1 {
      // do something with Tensilica Xtensa,
    }

    // >0x12    shortle    5f    Alphamosaic VideoCore,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5f)
    }
    if m1 {
      // do something with Alphamosaic VideoCore,
    }

    // >0x12    shortle    60    Thompson Multimedia,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x60)
    }
    if m1 {
      // do something with Thompson Multimedia,
    }

    // >0x12    shortle    61    NatSemi 32k,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x61)
    }
    if m1 {
      // do something with NatSemi 32k,
    }

    // >0x12    shortle    62    Tenor Network TPC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x62)
    }
    if m1 {
      // do something with Tenor Network TPC,
    }

    // >0x12    shortle    63    Trebia SNP 1000,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x63)
    }
    if m1 {
      // do something with Trebia SNP 1000,
    }

    // >0x12    shortle    64    STMicroelectronics ST200,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x64)
    }
    if m1 {
      // do something with STMicroelectronics ST200,
    }

    // >0x12    shortle    65    Ubicom IP2022,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x65)
    }
    if m1 {
      // do something with Ubicom IP2022,
    }

    // >0x12    shortle    66    MAX Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x66)
    }
    if m1 {
      // do something with MAX Processor,
    }

    // >0x12    shortle    67    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x67)
    }
    if m1 {
      // do something with NatSemi CompactRISC,
    }

    // >0x12    shortle    68    Fujitsu F2MC16,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x68)
    }
    if m1 {
      // do something with Fujitsu F2MC16,
    }

    // >0x12    shortle    69    TI msp430,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x69)
    }
    if m1 {
      // do something with TI msp430,
    }

    // >0x12    shortle    6a    Analog Devices Blackfin,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6a)
    }
    if m1 {
      // do something with Analog Devices Blackfin,
    }

    // >0x12    shortle    6b    S1C33 Family of Seiko Epson,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6b)
    }
    if m1 {
      // do something with S1C33 Family of Seiko Epson,
    }

    // >0x12    shortle    6c    Sharp embedded,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6c)
    }
    if m1 {
      // do something with Sharp embedded,
    }

    // >0x12    shortle    6d    Arca RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6d)
    }
    if m1 {
      // do something with Arca RISC,
    }

    // >0x12    shortle    6e    PKU-Unity Ltd.,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6e)
    }
    if m1 {
      // do something with PKU-Unity Ltd.,
    }

    // >0x12    shortle    6f    eXcess: 16/32/64-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x6f)
    }
    if m1 {
      // do something with eXcess: 16/32/64-bit,
    }

    // >0x12    shortle    70    Icera Deep Execution Processor,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x70)
    }
    if m1 {
      // do something with Icera Deep Execution Processor,
    }

    // >0x12    shortle    71    Altera Nios II,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x71)
    }
    if m1 {
      // do something with Altera Nios II,
    }

    // >0x12    shortle    72    NatSemi CRX,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x72)
    }
    if m1 {
      // do something with NatSemi CRX,
    }

    // >0x12    shortle    73    Motorola XGATE,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x73)
    }
    if m1 {
      // do something with Motorola XGATE,
    }

    // >0x12    shortle    74    Infineon C16x/XC16x,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x74)
    }
    if m1 {
      // do something with Infineon C16x/XC16x,
    }

    // >0x12    shortle    75    Renesas M16C series,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x75)
    }
    if m1 {
      // do something with Renesas M16C series,
    }

    // >0x12    shortle    76    Microchip dsPIC30F,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x76)
    }
    if m1 {
      // do something with Microchip dsPIC30F,
    }

    // >0x12    shortle    77    Freescale RISC core,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x77)
    }
    if m1 {
      // do something with Freescale RISC core,
    }

    // >0x12    shortle    78    Renesas M32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x78)
    }
    if m1 {
      // do something with Renesas M32C series,
    }

    // >0x12    shortle    83    Altium TSK3000 core,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x83)
    }
    if m1 {
      // do something with Altium TSK3000 core,
    }

    // >0x12    shortle    84    Freescale RS08,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x84)
    }
    if m1 {
      // do something with Freescale RS08,
    }

    // >0x12    shortle    86    Cyan Technology eCOG2,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x86)
    }
    if m1 {
      // do something with Cyan Technology eCOG2,
    }

    // >0x12    shortle    87    Sunplus S+core7 RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x87)
    }
    if m1 {
      // do something with Sunplus S+core7 RISC,
    }

    // >0x12    shortle    88    New Japan Radio (NJR) 24-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x88)
    }
    if m1 {
      // do something with New Japan Radio (NJR) 24-bit DSP,
    }

    // >0x12    shortle    89    Broadcom VideoCore III,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x89)
    }
    if m1 {
      // do something with Broadcom VideoCore III,
    }

    // >0x12    shortle    8a    LatticeMico32,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8a)
    }
    if m1 {
      // do something with LatticeMico32,
    }

    // >0x12    shortle    8b    Seiko Epson C17 family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8b)
    }
    if m1 {
      // do something with Seiko Epson C17 family,
    }

    // >0x12    shortle    8c    TI TMS320C6000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8c)
    }
    if m1 {
      // do something with TI TMS320C6000 DSP family,
    }

    // >0x12    shortle    8d    TI TMS320C2000 DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8d)
    }
    if m1 {
      // do something with TI TMS320C2000 DSP family,
    }

    // >0x12    shortle    8e    TI TMS320C55x DSP family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8e)
    }
    if m1 {
      // do something with TI TMS320C55x DSP family,
    }

    // >0x12    shortle    a0    STMicroelectronics 64bit VLIW DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa0)
    }
    if m1 {
      // do something with STMicroelectronics 64bit VLIW DSP,
    }

    // >0x12    shortle    a1    Cypress M8C,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa1)
    }
    if m1 {
      // do something with Cypress M8C,
    }

    // >0x12    shortle    a2    Renesas R32C series,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa2)
    }
    if m1 {
      // do something with Renesas R32C series,
    }

    // >0x12    shortle    a3    NXP TriMedia family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa3)
    }
    if m1 {
      // do something with NXP TriMedia family,
    }

    // >0x12    shortle    a4    QUALCOMM DSP6,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa4)
    }
    if m1 {
      // do something with QUALCOMM DSP6,
    }

    // >0x12    shortle    a5    Intel 8051 and variants,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa5)
    }
    if m1 {
      // do something with Intel 8051 and variants,
    }

    // >0x12    shortle    a6    STMicroelectronics STxP7x family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa6)
    }
    if m1 {
      // do something with STMicroelectronics STxP7x family,
    }

    // >0x12    shortle    a7    Andes embedded RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa7)
    }
    if m1 {
      // do something with Andes embedded RISC,
    }

    // >0x12    shortle    a8    Cyan eCOG1X family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa8)
    }
    if m1 {
      // do something with Cyan eCOG1X family,
    }

    // >0x12    shortle    a9    Dallas MAXQ30,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa9)
    }
    if m1 {
      // do something with Dallas MAXQ30,
    }

    // >0x12    shortle    aa    New Japan Radio (NJR) 16-bit DSP,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xaa)
    }
    if m1 {
      // do something with New Japan Radio (NJR) 16-bit DSP,
    }

    // >0x12    shortle    ab    M2000 Reconfigurable RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xab)
    }
    if m1 {
      // do something with M2000 Reconfigurable RISC,
    }

    // >0x12    shortle    ac    Cray NV2 vector architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xac)
    }
    if m1 {
      // do something with Cray NV2 vector architecture,
    }

    // >0x12    shortle    ad    Renesas RX family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xad)
    }
    if m1 {
      // do something with Renesas RX family,
    }

    // >0x12    shortle    ae    META,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xae)
    }
    if m1 {
      // do something with META,
    }

    // >0x12    shortle    af    MCST Elbrus,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xaf)
    }
    if m1 {
      // do something with MCST Elbrus,
    }

    // >0x12    shortle    b0    Cyan Technology eCOG16 family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb0)
    }
    if m1 {
      // do something with Cyan Technology eCOG16 family,
    }

    // >0x12    shortle    b1    NatSemi CompactRISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb1)
    }
    if m1 {
      // do something with NatSemi CompactRISC,
    }

    // >0x12    shortle    b2    Freescale Extended Time Processing Unit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb2)
    }
    if m1 {
      // do something with Freescale Extended Time Processing Unit,
    }

    // >0x12    shortle    b3    Infineon SLE9X,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb3)
    }
    if m1 {
      // do something with Infineon SLE9X,
    }

    // >0x12    shortle    b4    Intel L1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb4)
    }
    if m1 {
      // do something with Intel L1OM,
    }

    // >0x12    shortle    b5    Intel K1OM,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb5)
    }
    if m1 {
      // do something with Intel K1OM,
    }

    // >0x12    shortle    b7    ARM aarch64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb7)
    }
    if m1 {
      // do something with ARM aarch64,
    }

    // >0x12    shortle    b9    Atmel 32-bit family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xb9)
    }
    if m1 {
      // do something with Atmel 32-bit family,
    }

    // >0x12    shortle    ba    STMicroeletronics STM8 8-bit,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xba)
    }
    if m1 {
      // do something with STMicroeletronics STM8 8-bit,
    }

    // >0x12    shortle    bb    Tilera TILE64,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbb)
    }
    if m1 {
      // do something with Tilera TILE64,
    }

    // >0x12    shortle    bc    Tilera TILEPro,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbc)
    }
    if m1 {
      // do something with Tilera TILEPro,
    }

    // >0x12    shortle    bd    Xilinx MicroBlaze 32-bit RISC,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbd)
    }
    if m1 {
      // do something with Xilinx MicroBlaze 32-bit RISC,
    }

    // >0x12    shortle    be    NVIDIA CUDA architecture,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbe)
    }
    if m1 {
      // do something with NVIDIA CUDA architecture,
    }

    // >0x12    shortle    bf    Tilera TILE-Gx,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbf)
    }
    if m1 {
      // do something with Tilera TILE-Gx,
    }

    // >0x12    shortle    c5    Renesas RL78 family,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xc5)
    }
    if m1 {
      // do something with Renesas RL78 family,
    }

    // >0x12    shortle    c7    Renesas 78K0R,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xc7)
    }
    if m1 {
      // do something with Renesas 78K0R,
    }

    // >0x12    shortle    1057    AVR (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1057)
    }
    if m1 {
      // do something with AVR (unofficial),
    }

    // >0x12    shortle    1059    MSP430 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1059)
    }
    if m1 {
      // do something with MSP430 (unofficial),
    }

    // >0x12    shortle    1223    Adapteva Epiphany (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x1223)
    }
    if m1 {
      // do something with Adapteva Epiphany (unofficial),
    }

    // >0x12    shortle    2530    Morpho MT (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x2530)
    }
    if m1 {
      // do something with Morpho MT (unofficial),
    }

    // >0x12    shortle    3330    FR30 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3330)
    }
    if m1 {
      // do something with FR30 (unofficial),
    }

    // >0x12    shortle    3426    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x3426)
    }
    if m1 {
      // do something with OpenRISC (obsolete),
    }

    // >0x12    shortle    4688    Infineon C166 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x4688)
    }
    if m1 {
      // do something with Infineon C166 (unofficial),
    }

    // >0x12    shortle    5441    Cygnus FRV (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5441)
    }
    if m1 {
      // do something with Cygnus FRV (unofficial),
    }

    // >0x12    shortle    5aa5    DLX (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x5aa5)
    }
    if m1 {
      // do something with DLX (unofficial),
    }

    // >0x12    shortle    7650    Cygnus D10V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x7650)
    }
    if m1 {
      // do something with Cygnus D10V (unofficial),
    }

    // >0x12    shortle    7676    Cygnus D30V (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x7676)
    }
    if m1 {
      // do something with Cygnus D30V (unofficial),
    }

    // >0x12    shortle    8217    Ubicom IP2xxx (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8217)
    }
    if m1 {
      // do something with Ubicom IP2xxx (unofficial),
    }

    // >0x12    shortle    8472    OpenRISC (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x8472)
    }
    if m1 {
      // do something with OpenRISC (obsolete),
    }

    // >0x12    shortle    9025    Cygnus PowerPC (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9025)
    }
    if m1 {
      // do something with Cygnus PowerPC (unofficial),
    }

    // >0x12    shortle    9026    Alpha (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9026)
    }
    if m1 {
      // do something with Alpha (unofficial),
    }

    // >0x12    shortle    9041    Cygnus M32R (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9041)
    }
    if m1 {
      // do something with Cygnus M32R (unofficial),
    }

    // >0x12    shortle    9080    Cygnus V850 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0x9080)
    }
    if m1 {
      // do something with Cygnus V850 (unofficial),
    }

    // >0x12    shortle    a390    IBM S/390 (obsolete),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xa390)
    }
    if m1 {
      // do something with IBM S/390 (obsolete),
    }

    // >0x12    shortle    abc7    Old Xtensa (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xabc7)
    }
    if m1 {
      // do something with Old Xtensa (unofficial),
    }

    // >0x12    shortle    ad45    xstormy16 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xad45)
    }
    if m1 {
      // do something with xstormy16 (unofficial),
    }

    // >0x12    shortle    baab    Old MicroBlaze (unofficial),,
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbaab)
    }
    if m1 {
      // do something with Old MicroBlaze (unofficial),,
    }

    // >0x12    shortle    beef    Cygnus MN10300 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xbeef)
    }
    if m1 {
      // do something with Cygnus MN10300 (unofficial),
    }

    // >0x12    shortle    dead    Cygnus MN10200 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xdead)
    }
    if m1 {
      // do something with Cygnus MN10200 (unofficial),
    }

    // >0x12    shortle    f00d    Toshiba MeP (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xf00d)
    }
    if m1 {
      // do something with Toshiba MeP (unofficial),
    }

    // >0x12    shortle    feb0    Renesas M32C (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfeb0)
    }
    if m1 {
      // do something with Renesas M32C (unofficial),
    }

    // >0x12    shortle    feba    Vitesse IQ2000 (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfeba)
    }
    if m1 {
      // do something with Vitesse IQ2000 (unofficial),
    }

    // >0x12    shortle    febb    NIOS (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfebb)
    }
    if m1 {
      // do something with NIOS (unofficial),
    }

    // >0x12    shortle    feed    Moxie (unofficial),
    off = pageOff + 18
    {
      iv, ok := readUint16le(tb, off)
      m1 = ok && (uint64(iv) == 0xfeed)
    }
    if m1 {
      // do something with Moxie (unofficial),
    }

    // >0x12    default    
    off = pageOff + 18
    // uh oh unhandled kind

    if m1 {
      // >>0x12    shortle    0    *unknown arch 0x%x*
      off = pageOff + 18
      {
        iv, ok := readUint16le(tb, off)
        m2 = ok && (uint64(iv) == 0x0)
      }
      if m2 {
        // do something with *unknown arch 0x%x*
      }

    }
    // >0x14    longle    0    invalid version
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x0)
    }
    if m1 {
      // do something with invalid version
    }

    // >0x14    longle    1    version 1
    off = pageOff + 20
    {
      iv, ok := readUint32le(tb, off)
      m1 = ok && (uint64(iv) == 0x1)
    }
    if m1 {
      // do something with version 1
    }

  }
  return outStrings, nil
}

