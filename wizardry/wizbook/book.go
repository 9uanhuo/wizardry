// this file has been generated by github.com/fasterthanlime/wizardry
// from a set of magic rules. you probably don't want to edit it by hand

package wizbook

import (
  "fmt"
  "encoding/binary"
  "github.com/fasterthanlime/wizardry/wizardry"
)

// silence import errors, if we don't use string/search etc.
var _ wizardry.StringTestFlags
var _ fmt.State
var le binary.ByteOrder = binary.LittleEndian
var be binary.ByteOrder = binary.BigEndian
type i8 int8
type u8 uint8
type i16 int16
type u16 uint16
type i32 int32
type u32 uint32
type i64 int64
type u64 uint64

func readU8le(tb []byte, off i64) (u8, bool) {
  if i64(len(tb)) < off+1 {
    return 0, false
  }
  pi := u8(tb[off])
  return u8(pi), true
}

func readU8be(tb []byte, off i64) (u8, bool) {
  if i64(len(tb)) < off+1 {
    return 0, false
  }
  pi := u8(tb[off])
  return u8(pi), true
}

func readU16le(tb []byte, off i64) (u16, bool) {
  if i64(len(tb)) < off+2 {
    return 0, false
  }
  pi := le.Uint16(tb[off:])
  return u16(pi), true
}

func readU16be(tb []byte, off i64) (u16, bool) {
  if i64(len(tb)) < off+2 {
    return 0, false
  }
  pi := be.Uint16(tb[off:])
  return u16(pi), true
}

func readU32le(tb []byte, off i64) (u32, bool) {
  if i64(len(tb)) < off+4 {
    return 0, false
  }
  pi := le.Uint32(tb[off:])
  return u32(pi), true
}

func readU32be(tb []byte, off i64) (u32, bool) {
  if i64(len(tb)) < off+4 {
    return 0, false
  }
  pi := be.Uint32(tb[off:])
  return u32(pi), true
}

func readU64le(tb []byte, off i64) (u64, bool) {
  if i64(len(tb)) < off+8 {
    return 0, false
  }
  pi := le.Uint64(tb[off:])
  return u64(pi), true
}

func readU64be(tb []byte, off i64) (u64, bool) {
  if i64(len(tb)) < off+8 {
    return 0, false
  }
  pi := be.Uint64(tb[off:])
  return u64(pi), true
}

func Identify(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f0 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f9 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  gof = off + ml
  out = append(out, "JAR compressed with pack200,")
  goto s9
s9:
  goto end
f9:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f12 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  gof = off + ml
  out = append(out, "JAR compressed with pack200,")
  goto s12
s12:
  goto end
f12:
  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f15 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  gof = off + ml
  goto s15
s15:
  goto end
f15:
  // 0	string/wt	#!\ /bin/sh		POSIX shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f26 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/sh\t\tPOSIX shell script text executable")
  gof = off + ml
  out = append(out, "POSIX shell script text executable")
  goto s26
s26:
  goto end
f26:
  // 0	string/wb	#!\ /bin/sh		POSIX shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f27 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/sh\t\tPOSIX shell script executable (binary data)")
  gof = off + ml
  out = append(out, "POSIX shell script executable (binary data)")
  goto s27
s27:
  goto end
f27:
  // 0	string/wt	#!\ /bin/csh		C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f28 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/csh\t\tC shell script text executable")
  gof = off + ml
  out = append(out, "C shell script text executable")
  goto s28
s28:
  goto end
f28:
  // 0	string/wt	#!\ /bin/ksh		Korn shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f29 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/ksh\t\tKorn shell script text executable")
  gof = off + ml
  out = append(out, "Korn shell script text executable")
  goto s29
s29:
  goto end
f29:
  // 0	string/wb	#!\ /bin/ksh		Korn shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f30 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/ksh\t\tKorn shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Korn shell script executable (binary data)")
  goto s30
s30:
  goto end
f30:
  // 0	string/wt 	#!\ /bin/tcsh		Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f31 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /bin/tcsh\t\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s31
s31:
  goto end
f31:
  // 0	string/wt	#!\ /usr/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f32 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/tcsh\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s32
s32:
  goto end
f32:
  // 0	string/wt 	#!\ /usr/local/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f33 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /usr/local/tcsh\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s33
s33:
  goto end
f33:
  // 0	string/wt	#!\ /usr/local/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f34 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/tcsh\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s34
s34:
  goto end
f34:
  // 0	string/wt	#!\ /bin/zsh		Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f35 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/zsh\t\tPaul Falstad's zsh script text executable")
  gof = off + ml
  out = append(out, "Paul Falstad's zsh script text executable")
  goto s35
s35:
  goto end
f35:
  // 0	string/wt	#!\ /usr/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f36 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/zsh\tPaul Falstad's zsh script text executable")
  gof = off + ml
  out = append(out, "Paul Falstad's zsh script text executable")
  goto s36
s36:
  goto end
f36:
  // 0	string/wt	#!\ /usr/local/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f37 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/zsh\tPaul Falstad's zsh script text executable")
  gof = off + ml
  out = append(out, "Paul Falstad's zsh script text executable")
  goto s37
s37:
  goto end
f37:
  // 0	string/wt	#!\ /usr/local/bin/ash	Neil Brown's ash script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f38 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ash\tNeil Brown's ash script text executable")
  gof = off + ml
  out = append(out, "Neil Brown's ash script text executable")
  goto s38
s38:
  goto end
f38:
  // 0	string/wt	#!\ /usr/local/bin/ae	Neil Brown's ae script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f39 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ae\tNeil Brown's ae script text executable")
  gof = off + ml
  out = append(out, "Neil Brown's ae script text executable")
  goto s39
s39:
  goto end
f39:
  // 0	string/wt	#!\ /bin/nawk		new awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f40 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/nawk\t\tnew awk script text executable")
  gof = off + ml
  out = append(out, "new awk script text executable")
  goto s40
s40:
  goto end
f40:
  // 0	string/wt	#!\ /usr/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f41 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/nawk\tnew awk script text executable")
  gof = off + ml
  out = append(out, "new awk script text executable")
  goto s41
s41:
  goto end
f41:
  // 0	string/wt	#!\ /usr/local/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f42 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/nawk\tnew awk script text executable")
  gof = off + ml
  out = append(out, "new awk script text executable")
  goto s42
s42:
  goto end
f42:
  // 0	string/wt	#!\ /bin/gawk		GNU awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f43 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/gawk\t\tGNU awk script text executable")
  gof = off + ml
  out = append(out, "GNU awk script text executable")
  goto s43
s43:
  goto end
f43:
  // 0	string/wt	#!\ /usr/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f44 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/gawk\tGNU awk script text executable")
  gof = off + ml
  out = append(out, "GNU awk script text executable")
  goto s44
s44:
  goto end
f44:
  // 0	string/wt	#!\ /usr/local/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f45 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/gawk\tGNU awk script text executable")
  gof = off + ml
  out = append(out, "GNU awk script text executable")
  goto s45
s45:
  goto end
f45:
  // 0	string/wt	#!\ /bin/awk		awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f46 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/awk\t\tawk script text executable")
  gof = off + ml
  out = append(out, "awk script text executable")
  goto s46
s46:
  goto end
f46:
  // 0	string/wt	#!\ /usr/bin/awk	awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f47 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/awk\tawk script text executable")
  gof = off + ml
  out = append(out, "awk script text executable")
  goto s47
s47:
  goto end
f47:
  // 0	string/wt	#!\ /bin/rc	Plan 9 rc shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f48 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/rc\tPlan 9 rc shell script text executable")
  gof = off + ml
  out = append(out, "Plan 9 rc shell script text executable")
  goto s48
s48:
  goto end
f48:
  // 0	string/wt	#!\ /bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f49 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s49
s49:
  goto end
f49:
  // 0	string/wb	#!\ /bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f50 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s50
s50:
  goto end
f50:
  // 0	string/wt	#!\ /usr/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f51 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s51
s51:
  goto end
f51:
  // 0	string/wb	#!\ /usr/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f52 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/bin/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s52
s52:
  goto end
f52:
  // 0	string/wt	#!\ /usr/local/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f53 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s53
s53:
  goto end
f53:
  // 0	string/wb	#!\ /usr/local/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f54 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s54
s54:
  goto end
f54:
  // 0	string/wt	#!\ /usr/local/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f55 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s55
s55:
  goto end
f55:
  // 0	string/wb	#!\ /usr/local/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f56 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bin/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s56
s56:
  goto end
f56:
  // 0	search/1/c	=<?php			PHP script text
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?php"))
  if ml < 0 { goto f57 }
  ml += 0x6
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/c\t=<?php\t\t\tPHP script text")
  gof = off + ml
  out = append(out, "PHP script text")
  goto s57
s57:
  goto end
f57:
  // 0	search/1	=<?\n			PHP script text
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\n"))
  if ml < 0 { goto f58 }
  ml += 0x4
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\n\t\t\tPHP script text")
  gof = off + ml
  out = append(out, "PHP script text")
  goto s58
s58:
  goto end
f58:
  // 0	search/1	=<?\r			PHP script text
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\r"))
  if ml < 0 { goto f59 }
  ml += 0x4
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\r\t\t\tPHP script text")
  gof = off + ml
  out = append(out, "PHP script text")
  goto s59
s59:
  goto end
f59:
  // 0	search/1/w	#!\ /usr/local/bin/php	PHP script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/local/bin/php"))
  if ml < 0 { goto f60 }
  ml += 0x15
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/local/bin/php\tPHP script text executable")
  gof = off + ml
  out = append(out, "PHP script text executable")
  goto s60
s60:
  goto end
f60:
  // 0	search/1/w	#!\ /usr/bin/php	PHP script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/bin/php"))
  if ml < 0 { goto f61 }
  ml += 0xf
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/bin/php\tPHP script text executable")
  gof = off + ml
  out = append(out, "PHP script text executable")
  goto s61
s61:
  goto end
f61:
  // 0	string	=<?php\ /*\ Smarty\ version	Smarty compiled template
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x3c, 0x3f, 0x70, 0x68, 0x70, 0x20, 0x2f, 0x2a, 0x20, 0x53, 0x6d, 0x61, 0x72, 0x74, 0x79, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f62 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t=<?php\\ /*\\ Smarty\\ version\tSmarty compiled template")
  gof = off + ml
  out = append(out, "Smarty compiled template")
  goto s62
s62:
  goto end
f62:
  // 0	string		Zend\x00		PHP script Zend Optimizer data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x65, 0x6e, 0x64, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f63 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tZend\\x00\t\tPHP script Zend Optimizer data")
  gof = off + ml
  out = append(out, "PHP script Zend Optimizer data")
  goto s63
s63:
  goto end
f63:
  // 0	string/t	$!			DCL command file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f64 }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t$!\t\t\tDCL command file")
  gof = off + ml
  out = append(out, "DCL command file")
  goto s64
s64:
  goto end
f64:
  // 0	string		#!/usr/bin/pdmenu	Pdmenu configuration file text
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x70, 0x64, 0x6d, 0x65, 0x6e, 0x75}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f65 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t#!/usr/bin/pdmenu\tPdmenu configuration file text")
  gof = off + ml
  out = append(out, "Pdmenu configuration file text")
  goto s65
s65:
  goto end
f65:
  // 0	string		\177ELF		ELF
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x7f, 0x45, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f66 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t\\177ELF\t\tELF")
  gof = off + ml
  out = append(out, "ELF")
  goto s66
s66:
  goto end
f66:
  // 0	lelong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f95 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong&0xfffffffe\t0xfeedface\tMach-O")
  gof = off + ml
  out = append(out, "Mach-O")
  goto s95
s95:
  goto end
f95:
  // 0	belong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f97 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong&0xfffffffe\t0xfeedface\tMach-O")
  gof = off + ml
  out = append(out, "Mach-O")
  goto s97
s97:
  goto end
f97:
  // 0	string/t	@
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x40}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f99 }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t@")
  gof = off + ml
  goto s99
s99:
  goto end
f99:
  // 100	search/0xffff   rxfuncadd
  off = pageOff + 0x64
  ml = i64(wizardry.SearchTest(tb, int(off), 0xffff, "rxfuncadd"))
  if ml < 0 { goto f104 }
  ml += 0x9
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   rxfuncadd")
  gof = off + ml
  goto s104
s104:
  goto end
f104:
  // 100	search/0xffff   say
  off = pageOff + 0x64
  ml = i64(wizardry.SearchTest(tb, int(off), 0xffff, "say"))
  if ml < 0 { goto f105 }
  ml += 0x3
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   say")
  gof = off + ml
  goto s105
s105:
  goto end
f105:
  // 0	leshort		0x166	MS Windows COFF MIPS R4000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x166)) { goto f106 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x166\tMS Windows COFF MIPS R4000 object file")
  gof = off + ml
  out = append(out, "MS Windows COFF MIPS R4000 object file")
  goto s106
s106:
  goto end
f106:
  // 0	leshort		0x184	MS Windows COFF Alpha object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x184)) { goto f107 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x184\tMS Windows COFF Alpha object file")
  gof = off + ml
  out = append(out, "MS Windows COFF Alpha object file")
  goto s107
s107:
  goto end
f107:
  // 0	leshort		0x268	MS Windows COFF Motorola 68000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x268)) { goto f108 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x268\tMS Windows COFF Motorola 68000 object file")
  gof = off + ml
  out = append(out, "MS Windows COFF Motorola 68000 object file")
  goto s108
s108:
  goto end
f108:
  // 0	leshort		0x1f0	MS Windows COFF PowerPC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x1f0)) { goto f109 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x1f0\tMS Windows COFF PowerPC object file")
  gof = off + ml
  out = append(out, "MS Windows COFF PowerPC object file")
  goto s109
s109:
  goto end
f109:
  // 0	leshort		0x290	MS Windows COFF PA-RISC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x290)) { goto f110 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x290\tMS Windows COFF PA-RISC object file")
  gof = off + ml
  out = append(out, "MS Windows COFF PA-RISC object file")
  goto s110
s110:
  goto end
f110:
  // 0	string/b	MZ
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f111 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMZ")
  gof = off + ml
  goto s111
s111:
  goto end
f111:
  // 0	string/b	KCF		FreeDOS KEYBoard Layout collection
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x43, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f298 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKCF\t\tFreeDOS KEYBoard Layout collection")
  gof = off + ml
  out = append(out, "FreeDOS KEYBoard Layout collection")
  goto s298
s298:
  goto end
f298:
  // 0	string/b	KLF		FreeDOS KEYBoard Layout file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f304 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKLF\t\tFreeDOS KEYBoard Layout file")
  gof = off + ml
  out = append(out, "FreeDOS KEYBoard Layout file")
  goto s304
s304:
  goto end
f304:
  // 0	string	\xffKEYB\ \ \ \0\0\0\0
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xff, 0x4b, 0x45, 0x59, 0x42, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f308 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xffKEYB\\ \\ \\ \\0\\0\\0\\0")
  gof = off + ml
  goto s308
s308:
  goto end
f308:
  // 0	ulequad&0x07a0ffffffff		0xffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv)&0x7a0ffffffff == 0xffffffff)) { goto f310 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad&0x07a0ffffffff\t\t0xffffffff")
  gof = off + ml
  goto s310
s310:
  goto end
f310:
  // 0	ulequad				0x0513c00000000012
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x513c00000000012)) { goto f312 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0513c00000000012")
  gof = off + ml
  goto s312
s312:
  goto end
f312:
  // 0	ulequad				0x32f28000ffff0016
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x32f28000ffff0016)) { goto f314 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x32f28000ffff0016")
  gof = off + ml
  goto s314
s314:
  goto end
f314:
  // 0	ulequad				0x007f00000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x7f00000000ffff)) { goto f316 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x007f00000000ffff")
  gof = off + ml
  goto s316
s316:
  goto end
f316:
  // 0	ulequad				0x001600000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x1600000000ffff)) { goto f318 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x001600000000ffff")
  gof = off + ml
  goto s318
s318:
  goto end
f318:
  // 0	ulequad				0x0bf708c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0xbf708c2ffffffff)) { goto f320 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0bf708c2ffffffff")
  gof = off + ml
  goto s320
s320:
  goto end
f320:
  // 0	ulequad				0x07bd08c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x7bd08c2ffffffff)) { goto f322 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x07bd08c2ffffffff")
  gof = off + ml
  goto s322
s322:
  goto end
f322:
  // 0	ubyte		0x8c
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0x8c)) { goto f324 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0x8c")
  gof = off + ml
  goto s324
s324:
  goto end
f324:
  // 0	ulelong		0xffff10eb	DR-DOS executable (COM)
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xffff10eb)) { goto f328 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tulelong\t\t0xffff10eb\tDR-DOS executable (COM)")
  gof = off + ml
  out = append(out, "DR-DOS executable (COM)")
  goto s328
s328:
  goto end
f328:
  // 0	ubeshort&0xeb8d	>0xeb00
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv))&0xeb8d > 0xeb00)) { goto f329 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tubeshort&0xeb8d\t>0xeb00")
  gof = off + ml
  goto s329
s329:
  goto end
f329:
  // 0	        byte	0xeb
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xeb)) { goto f330 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0\t        byte\t0xeb")
  gof = off + ml
  goto s330
s330:
  goto end
f330:
  // 0           byte    0xe9
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xe9)) { goto f334 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0           byte    0xe9")
  gof = off + ml
  goto s334
s334:
  goto end
f334:
  // 0	ubyte		0xb8
  off = pageOff + 0x0
  {
    iv, ok := readU8le(tb, off)
    if !(ok && (u64(iv) == 0xb8)) { goto f341 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0xb8")
  gof = off + ml
  goto s341
s341:
  goto end
f341:
  // 0	string/b	\x81\xfc
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x81, 0xfc}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f347 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x81\\xfc")
  gof = off + ml
  goto s347
s347:
  goto end
f347:
  // 252	string Must\ have\ DOS\ version DR-DOS executable (COM)
  off = pageOff + 0xfc
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x75, 0x73, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f350 }
  fmt.Printf("matched rule: %s\n", "252\tstring Must\\ have\\ DOS\\ version DR-DOS executable (COM)")
  gof = off + ml
  out = append(out, "DR-DOS executable (COM)")
  goto s350
s350:
  goto end
f350:
  // 34	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x22
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f351 }
  fmt.Printf("matched rule: %s\n", "34\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  gof = off + ml
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto s351
s351:
  goto end
f351:
  // 35	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x23
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f352 }
  fmt.Printf("matched rule: %s\n", "35\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  gof = off + ml
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto s352
s352:
  goto end
f352:
  // 2	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x2
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f353 }
  fmt.Printf("matched rule: %s\n", "2\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s353
s353:
  goto end
f353:
  // 4	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x4
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f354 }
  fmt.Printf("matched rule: %s\n", "4\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s354
s354:
  goto end
f354:
  // 5	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x5
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f355 }
  fmt.Printf("matched rule: %s\n", "5\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s355
s355:
  goto end
f355:
  // 7	string	\xcd\x21
  off = pageOff + 0x7
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f356 }
  fmt.Printf("matched rule: %s\n", "7\tstring\t\\xcd\\x21")
  gof = off + ml
  goto s356
s356:
  goto end
f356:
  // 10	string	\xcd\x21
  off = pageOff + 0xa
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f358 }
  fmt.Printf("matched rule: %s\n", "10\tstring\t\\xcd\\x21")
  gof = off + ml
  goto s358
s358:
  goto end
f358:
  // 13	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0xd
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f360 }
  fmt.Printf("matched rule: %s\n", "13\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s360
s360:
  goto end
f360:
  // 18	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x12
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f361 }
  fmt.Printf("matched rule: %s\n", "18\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s361
s361:
  goto end
f361:
  // 23	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x17
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f362 }
  fmt.Printf("matched rule: %s\n", "23\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s362
s362:
  goto end
f362:
  // 30	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x1e
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f363 }
  fmt.Printf("matched rule: %s\n", "30\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s363
s363:
  goto end
f363:
  // 70	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x46
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f364 }
  fmt.Printf("matched rule: %s\n", "70\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s364
s364:
  goto end
f364:
  // 0x6	search/0xa	\xfc\x57\xf3\xa5\xc3	COM executable for MS-DOS
  off = pageOff + 0x6
  ml = i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa5\xc3"))
  if ml < 0 { goto f365 }
  ml += 0x5
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa5\\xc3\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s365
s365:
  goto end
f365:
  // 0x6	search/0xa	\xfc\x57\xf3\xa4\xc3	COM executable for DOS
  off = pageOff + 0x6
  ml = i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa4\xc3"))
  if ml < 0 { goto f366 }
  ml += 0x5
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa4\\xc3\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s366
s366:
  goto end
f366:
  // 0x3c	string		W\ Collis\0\0		COM executable for MS-DOS, Compack compressed
  off = pageOff + 0x3c
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f368 }
  fmt.Printf("matched rule: %s\n", "0x3c\tstring\t\tW\\ Collis\\0\\0\t\tCOM executable for MS-DOS, Compack compressed")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS, Compack compressed")
  goto s368
s368:
  goto end
f368:
  // 0	string/b	LZ		MS-DOS executable (built-in)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f369 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tLZ\t\tMS-DOS executable (built-in)")
  gof = off + ml
  out = append(out, "MS-DOS executable (built-in)")
  goto s369
s369:
  goto end
f369:
  // 0	string/b	\320\317\021\340\241\261\032\341AAFB\015\000OM\006\016\053\064\001\001\001\377			AAF legacy file using MS Structured Storage
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x41, 0x41, 0x46, 0x42, 0xd, 0x0, 0x4f, 0x4d, 0x6, 0xe, 0x2b, 0x34, 0x1, 0x1, 0x1, 0xff}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f370 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341AAFB\\015\\000OM\\006\\016\\053\\064\\001\\001\\001\\377\t\t\tAAF legacy file using MS Structured Storage")
  gof = off + ml
  out = append(out, "AAF legacy file using MS Structured Storage")
  goto s370
s370:
  goto end
f370:
  // 0	string/b	\320\317\021\340\241\261\032\341\001\002\001\015\000\002\000\000\006\016\053\064\003\002\001\001			AAF file using MS Structured Storage
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x1, 0x2, 0x1, 0xd, 0x0, 0x2, 0x0, 0x0, 0x6, 0xe, 0x2b, 0x34, 0x3, 0x2, 0x1, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f373 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\\001\\002\\001\\015\\000\\002\\000\\000\\006\\016\\053\\064\\003\\002\\001\\001\t\t\tAAF file using MS Structured Storage")
  gof = off + ml
  out = append(out, "AAF file using MS Structured Storage")
  goto s373
s373:
  goto end
f373:
  // 2080	string	Microsoft\ Word\ 6.0\ Document	%s
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36, 0x2e, 0x30, 0x20, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f376 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Word\\ 6.0\\ Document\t%s")
  gof = off + ml
  out = append(out, "%s")
  goto s376
s376:
  goto end
f376:
  // 2080	string	Documento\ Microsoft\ Word\ 6 Spanish Microsoft Word 6 document data
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f377 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tDocumento\\ Microsoft\\ Word\\ 6 Spanish Microsoft Word 6 document data")
  gof = off + ml
  out = append(out, "Spanish Microsoft Word 6 document data")
  goto s377
s377:
  goto end
f377:
  // 2112	string	MSWordDoc			Microsoft Word document data
  off = pageOff + 0x840
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x6f, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f378 }
  fmt.Printf("matched rule: %s\n", "2112\tstring\tMSWordDoc\t\t\tMicrosoft Word document data")
  gof = off + ml
  out = append(out, "Microsoft Word document data")
  goto s378
s378:
  goto end
f378:
  // 0	belong	0x31be0000			Microsoft Word Document
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x31be0000)) { goto f379 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x31be0000\t\t\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s379
s379:
  goto end
f379:
  // 0	string/b	PO^Q`				Microsoft Word 6.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4f, 0x5e, 0x51, 0x60}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f380 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPO^Q`\t\t\t\tMicrosoft Word 6.0 Document")
  gof = off + ml
  out = append(out, "Microsoft Word 6.0 Document")
  goto s380
s380:
  goto end
f380:
  // 4   long        0
  off = pageOff + 0x4
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f381 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "4   long        0")
  gof = off + ml
  goto s381
s381:
  goto end
f381:
  // 0	string/b	\333\245-\0\0\0			Microsoft Word 2.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f386 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\333\\245-\\0\\0\\0\t\t\tMicrosoft Word 2.0 Document")
  gof = off + ml
  out = append(out, "Microsoft Word 2.0 Document")
  goto s386
s386:
  goto end
f386:
  // 512	string/b	\354\245\301			Microsoft Word Document
  off = pageOff + 0x200
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xec, 0xa5, 0xc1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f387 }
  fmt.Printf("matched rule: %s\n", "512\tstring/b\t\\354\\245\\301\t\t\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s387
s387:
  goto end
f387:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f388 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  gof = off + ml
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto s388
s388:
  goto end
f388:
  // 2080	string	Microsoft\ Excel\ 5.0\ Worksheet	%s
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65, 0x6c, 0x20, 0x35, 0x2e, 0x30, 0x20, 0x57, 0x6f, 0x72, 0x6b, 0x73, 0x68, 0x65, 0x65, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f389 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Excel\\ 5.0\\ Worksheet\t%s")
  gof = off + ml
  out = append(out, "%s")
  goto s389
s389:
  goto end
f389:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f390 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  gof = off + ml
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto s390
s390:
  goto end
f390:
  // 2080	string	Foglio\ di\ lavoro\ Microsoft\ Exce	%s
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x46, 0x6f, 0x67, 0x6c, 0x69, 0x6f, 0x20, 0x64, 0x69, 0x20, 0x6c, 0x61, 0x76, 0x6f, 0x72, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f391 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tFoglio\\ di\\ lavoro\\ Microsoft\\ Exce\t%s")
  gof = off + ml
  out = append(out, "%s")
  goto s391
s391:
  goto end
f391:
  // 2114	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x842
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f392 }
  fmt.Printf("matched rule: %s\n", "2114\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  gof = off + ml
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto s392
s392:
  goto end
f392:
  // 2121	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x849
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f393 }
  fmt.Printf("matched rule: %s\n", "2121\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  gof = off + ml
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto s393
s393:
  goto end
f393:
  // 0	string/b	\x09\x04\x06\x00\x00\x00\x10\x00	Microsoft Excel Worksheet
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x9, 0x4, 0x6, 0x0, 0x0, 0x0, 0x10, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f394 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x09\\x04\\x06\\x00\\x00\\x00\\x10\\x00\tMicrosoft Excel Worksheet")
  gof = off + ml
  out = append(out, "Microsoft Excel Worksheet")
  goto s394
s394:
  goto end
f394:
  // 0	belong	0x00001a00
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1a00)) { goto f395 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00001a00")
  gof = off + ml
  goto s395
s395:
  goto end
f395:
  // 0	belong	0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f421 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00000200")
  gof = off + ml
  goto s421
s421:
  goto end
f421:
  // 0	string/b		WordPro\0	Lotus WordPro
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f443 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\0\tLotus WordPro")
  gof = off + ml
  out = append(out, "Lotus WordPro")
  goto s443
s443:
  goto end
f443:
  // 0	string/b		WordPro\r\373	Lotus WordPro
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0xd, 0xfb}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f444 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\r\\373\tLotus WordPro")
  gof = off + ml
  out = append(out, "Lotus WordPro")
  goto s444
s444:
  goto end
f444:
  // 0		string		\x71\xa8\x00\x00\x01\x02
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x71, 0xa8, 0x0, 0x0, 0x1, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f445 }
  fmt.Printf("matched rule: %s\n", "0\t\tstring\t\t\\x71\\xa8\\x00\\x00\\x01\\x02")
  gof = off + ml
  goto s445
s445:
  goto end
f445:
  // 0	string/b	Nullsoft\ AVS\ Preset\ 	Winamp plug in
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x75, 0x6c, 0x6c, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x41, 0x56, 0x53, 0x20, 0x50, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f447 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tNullsoft\\ AVS\\ Preset\\ \tWinamp plug in")
  gof = off + ml
  out = append(out, "Winamp plug in")
  goto s447
s447:
  goto end
f447:
  // 0	string/b	\327\315\306\232	ms-windows metafont .wmf
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd7, 0xcd, 0xc6, 0x9a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f448 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\327\\315\\306\\232\tms-windows metafont .wmf")
  gof = off + ml
  out = append(out, "ms-windows metafont .wmf")
  goto s448
s448:
  goto end
f448:
  // 0	string/b	\002\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x2, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f449 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\002\\000\\011\\000\tms-windows metafont .wmf")
  gof = off + ml
  out = append(out, "ms-windows metafont .wmf")
  goto s449
s449:
  goto end
f449:
  // 0	string/b	\001\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x1, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f450 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\001\\000\\011\\000\tms-windows metafont .wmf")
  gof = off + ml
  out = append(out, "ms-windows metafont .wmf")
  goto s450
s450:
  goto end
f450:
  // 0	string/b	\003\001\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x1, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f451 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\001\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  gof = off + ml
  out = append(out, "tz3 ms-works file")
  goto s451
s451:
  goto end
f451:
  // 0	string/b	\003\002\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x2, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f452 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\002\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  gof = off + ml
  out = append(out, "tz3 ms-works file")
  goto s452
s452:
  goto end
f452:
  // 0	string/b	\003\003\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x3, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f453 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\003\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  gof = off + ml
  out = append(out, "tz3 ms-works file")
  goto s453
s453:
  goto end
f453:
  // 0 string \211\000\077\003\005\000\063\237\127\065\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x35, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f454 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\065\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s454
s454:
  goto end
f454:
  // 0 string \211\000\077\003\005\000\063\237\127\066\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x36, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f455 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\066\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s455
s455:
  goto end
f455:
  // 0 string \211\000\077\003\005\000\063\237\127\067\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x37, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f456 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\067\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s456
s456:
  goto end
f456:
  // 0 string \211\000\077\003\005\000\063\237\127\070\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x38, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f457 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\070\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s457
s457:
  goto end
f457:
  // 0 string \211\000\077\003\005\000\063\237\127\071\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x39, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f458 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\071\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s458
s458:
  goto end
f458:
  // 0 string \211\000\225\003\005\000\062\122\207\304\100\345\042 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x95, 0x3, 0x5, 0x0, 0x32, 0x52, 0x87, 0xc4, 0x40, 0xe5, 0x22}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f459 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\225\\003\\005\\000\\062\\122\\207\\304\\100\\345\\042 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s459
s459:
  goto end
f459:
  // 0	string/b	MDIF\032\000\010\000\000\000\372\046\100\175\001\000\001\036\001\000 MS Windows special zipped file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x44, 0x49, 0x46, 0x1a, 0x0, 0x8, 0x0, 0x0, 0x0, 0xfa, 0x26, 0x40, 0x7d, 0x1, 0x0, 0x1, 0x1e, 0x1, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f460 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMDIF\\032\\000\\010\\000\\000\\000\\372\\046\\100\\175\\001\\000\\001\\036\\001\\000 MS Windows special zipped file")
  gof = off + ml
  out = append(out, "MS Windows special zipped file")
  goto s460
s460:
  goto end
f460:
  // 0	string/b	\102\101\050\000\000\000\056\000\000\000\000\000\000\000	Icon for MS Windows
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x41, 0x28, 0x0, 0x0, 0x0, 0x2e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f461 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\102\\101\\050\\000\\000\\000\\056\\000\\000\\000\\000\\000\\000\\000\tIcon for MS Windows")
  gof = off + ml
  out = append(out, "Icon for MS Windows")
  goto s461
s461:
  goto end
f461:
  // 0   belong  0x00000100
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f462 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000100")
  gof = off + ml
  goto s462
s462:
  goto end
f462:
  // 0   belong  0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f469 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000200")
  gof = off + ml
  goto s469
s469:
  goto end
f469:
  // 0	string/b	PK\010\010BGI	Borland font
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f474 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPK\\010\\010BGI\tBorland font")
  gof = off + ml
  out = append(out, "Borland font")
  goto s474
s474:
  goto end
f474:
  // 0	string/b	pk\010\010BGI	Borland device
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x70, 0x6b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f476 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tpk\\010\\010BGI\tBorland device")
  gof = off + ml
  out = append(out, "Borland device")
  goto s476
s476:
  goto end
f476:
  // 0	lelong		0x00000004
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f478 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000004")
  gof = off + ml
  goto s478
s478:
  goto end
f478:
  // 0	lelong		0x00000005
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f480 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000005")
  gof = off + ml
  goto s480
s480:
  goto end
f480:
  // 9	string		GERBILDOC	First Choice document
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x4f, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f482 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDOC\tFirst Choice document")
  gof = off + ml
  out = append(out, "First Choice document")
  goto s482
s482:
  goto end
f482:
  // 9	string		GERBILDB	First Choice database
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f483 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDB\tFirst Choice database")
  gof = off + ml
  out = append(out, "First Choice database")
  goto s483
s483:
  goto end
f483:
  // 9	string		GERBILCLIP	First Choice database
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x43, 0x4c, 0x49, 0x50}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f484 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILCLIP\tFirst Choice database")
  gof = off + ml
  out = append(out, "First Choice database")
  goto s484
s484:
  goto end
f484:
  // 0	string		GERBIL		First Choice device file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f485 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tGERBIL\t\tFirst Choice device file")
  gof = off + ml
  out = append(out, "First Choice device file")
  goto s485
s485:
  goto end
f485:
  // 9	string		RABBITGRAPH	RabbitGraph file
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x41, 0x42, 0x42, 0x49, 0x54, 0x47, 0x52, 0x41, 0x50, 0x48}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f486 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tRABBITGRAPH\tRabbitGraph file")
  gof = off + ml
  out = append(out, "RabbitGraph file")
  goto s486
s486:
  goto end
f486:
  // 0	string		DCU1		Borland Delphi .DCU file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x43, 0x55, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f487 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tDCU1\t\tBorland Delphi .DCU file")
  gof = off + ml
  out = append(out, "Borland Delphi .DCU file")
  goto s487
s487:
  goto end
f487:
  // 0	string		=!<spell>	MKS Spell hash list (old format)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f488 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell>\tMKS Spell hash list (old format)")
  gof = off + ml
  out = append(out, "MKS Spell hash list (old format)")
  goto s488
s488:
  goto end
f488:
  // 0	string		=!<spell2>	MKS Spell hash list
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x32, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f489 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell2>\tMKS Spell hash list")
  gof = off + ml
  out = append(out, "MKS Spell hash list")
  goto s489
s489:
  goto end
f489:
  // 0	lelong		0x08086b70	TurboC BGI file
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x8086b70)) { goto f490 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08086b70\tTurboC BGI file")
  gof = off + ml
  out = append(out, "TurboC BGI file")
  goto s490
s490:
  goto end
f490:
  // 0	lelong		0x08084b50	TurboC Font file
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x8084b50)) { goto f491 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08084b50\tTurboC Font file")
  gof = off + ml
  out = append(out, "TurboC Font file")
  goto s491
s491:
  goto end
f491:
  // 0	string		TPF0
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x54, 0x50, 0x46, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f492 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tTPF0")
  gof = off + ml
  goto s492
s492:
  goto end
f492:
  // 0	string		PMCC		Windows 3.x .GRP file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4d, 0x43, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f493 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tPMCC\t\tWindows 3.x .GRP file")
  gof = off + ml
  out = append(out, "Windows 3.x .GRP file")
  goto s493
s493:
  goto end
f493:
  // 1	string		RDC-meg		MegaDots
  off = pageOff + 0x1
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x44, 0x43, 0x2d, 0x6d, 0x65, 0x67}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f494 }
  fmt.Printf("matched rule: %s\n", "1\tstring\t\tRDC-meg\t\tMegaDots")
  gof = off + ml
  out = append(out, "MegaDots")
  goto s494
s494:
  goto end
f494:
  // 0	lelong		0x4C
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x4c)) { goto f497 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x4C")
  gof = off + ml
  goto s497
s497:
  goto end
f497:
  // 0x171	string	MICROSOFT\ PIFEX\0	Windows Program Information File
  off = pageOff + 0x171
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x50, 0x49, 0x46, 0x45, 0x58, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f499 }
  fmt.Printf("matched rule: %s\n", "0x171\tstring\tMICROSOFT\\ PIFEX\\0\tWindows Program Information File")
  gof = off + ml
  out = append(out, "Windows Program Information File")
  goto s499
s499:
  goto end
f499:
  // 0	belong		0xC5D0D3C6	DOS EPS Binary File
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xc5d0d3c6)) { goto f516 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xC5D0D3C6\tDOS EPS Binary File")
  gof = off + ml
  out = append(out, "DOS EPS Binary File")
  goto s516
s516:
  goto end
f516:
  // 0	leshort		0x223e9f78	TNEF
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (u64(iv) == 0x223e9f78)) { goto f523 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x223e9f78\tTNEF")
  gof = off + ml
  out = append(out, "TNEF")
  goto s523
s523:
  goto end
f523:
  // 0	string		NG\0\001
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x47, 0x0, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f524 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tNG\\0\\001")
  gof = off + ml
  goto s524
s524:
  goto end
f524:
  // 0	ulelong	0x48443408		4DOS help file
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x48443408)) { goto f529 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tulelong\t0x48443408\t\t4DOS help file")
  gof = off + ml
  out = append(out, "4DOS help file")
  goto s529
s529:
  goto end
f529:
  // 0	ulequad	0x3a000000024e4c	MS Advisor help file
  off = pageOff + 0x0
  {
    iv, ok := readU64le(tb, off)
    if !(ok && (u64(iv) == 0x3a000000024e4c)) { goto f531 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t0x3a000000024e4c\tMS Advisor help file")
  gof = off + ml
  out = append(out, "MS Advisor help file")
  goto s531
s531:
  goto end
f531:
  // 0	string/b	ITSF\003\000\000\000\x60\000\000\000	MS Windows HtmlHelp Data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x53, 0x46, 0x3, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f532 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITSF\\003\\000\\000\\000\\x60\\000\\000\\000\tMS Windows HtmlHelp Data")
  gof = off + ml
  out = append(out, "MS Windows HtmlHelp Data")
  goto s532
s532:
  goto end
f532:
  // 2	string/b	GFA-BASIC3	GFA-BASIC 3 data
  off = pageOff + 0x2
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x46, 0x41, 0x2d, 0x42, 0x41, 0x53, 0x49, 0x43, 0x33}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f533 }
  fmt.Printf("matched rule: %s\n", "2\tstring/b\tGFA-BASIC3\tGFA-BASIC 3 data")
  gof = off + ml
  out = append(out, "GFA-BASIC 3 data")
  goto s533
s533:
  goto end
f533:
  // 0	string/b	MSCF\0\0\0\0	Microsoft Cabinet archive data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x46, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f534 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCF\\0\\0\\0\\0\tMicrosoft Cabinet archive data")
  gof = off + ml
  out = append(out, "Microsoft Cabinet archive data")
  goto s534
s534:
  goto end
f534:
  // 0	string/b	ISc(		InstallShield Cabinet archive data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x53, 0x63, 0x28}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f538 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tISc(\t\tInstallShield Cabinet archive data")
  gof = off + ml
  out = append(out, "InstallShield Cabinet archive data")
  goto s538
s538:
  goto end
f538:
  // 0	string/b	MSCE\0\0\0\0	Microsoft WinCE install header
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x45, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f542 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCE\\0\\0\\0\\0\tMicrosoft WinCE install header")
  gof = off + ml
  out = append(out, "Microsoft WinCE install header")
  goto s542
s542:
  goto end
f542:
  // 0	ulelong 1
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f556 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tulelong 1")
  gof = off + ml
  goto s556
s556:
  goto end
f556:
  // 0	string/b	\320\317\021\340\241\261\032\341	Microsoft Office Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f559 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\tMicrosoft Office Document")
  gof = off + ml
  out = append(out, "Microsoft Office Document")
  goto s559
s559:
  goto end
f559:
  // 0	string/b	\224\246\056		Microsoft Word Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x94, 0xa6, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f562 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\224\\246\\056\t\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s562
s562:
  goto end
f562:
  // 512	string	R\0o\0o\0t\0\ \0E\0n\0t\0r\0y	Microsoft Word Document
  off = pageOff + 0x200
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x0, 0x6f, 0x0, 0x6f, 0x0, 0x74, 0x0, 0x20, 0x0, 0x45, 0x0, 0x6e, 0x0, 0x74, 0x0, 0x72, 0x0, 0x79}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f563 }
  fmt.Printf("matched rule: %s\n", "512\tstring\tR\\0o\\0o\\0t\\0\\ \\0E\\0n\\0t\\0r\\0y\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s563
s563:
  goto end
f563:
  // 0	string/b $RBU
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x52, 0x42, 0x55}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f564 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b $RBU")
  gof = off + ml
  goto s564
s564:
  goto end
f564:
  // 0	string/b	DDS\040\174\000\000\000 Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x44, 0x53, 0x20, 0x7c, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f572 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tDDS\\040\\174\\000\\000\\000 Microsoft DirectDraw Surface (DDS),")
  gof = off + ml
  out = append(out, "Microsoft DirectDraw Surface (DDS),")
  goto s572
s572:
  goto end
f572:
  // 0	string/b	ITOLITLS		Microsoft Reader eBook Data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x4f, 0x4c, 0x49, 0x54, 0x4c, 0x53}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f576 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITOLITLS\t\tMicrosoft Reader eBook Data")
  gof = off + ml
  out = append(out, "Microsoft Reader eBook Data")
  goto s576
s576:
  goto end
f576:
  // 0	string/b	B000FF\n	Windows Embedded CE binary image
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x30, 0x30, 0x30, 0x46, 0x46, 0xa}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f578 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tB000FF\\n\tWindows Embedded CE binary image")
  gof = off + ml
  out = append(out, "Windows Embedded CE binary image")
  goto s578
s578:
  goto end
f578:
  // 0	string/b	MSWIM\000\000\000	Windows imaging (WIM) image
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x49, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f579 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSWIM\\000\\000\\000\tWindows imaging (WIM) image")
  gof = off + ml
  out = append(out, "Windows imaging (WIM) image")
  goto s579
s579:
  goto end
f579:
  // 0	string/b	WLPWM\000\000\000	Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x4c, 0x50, 0x57, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f580 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tWLPWM\\000\\000\\000\tWindows imaging (WIM) image, wimlib pipable format")
  gof = off + ml
  out = append(out, "Windows imaging (WIM) image, wimlib pipable format")
  goto s580
s580:
  goto end
f580:
  // 0	string	\xfc\x03\x00	Mallard BASIC program data (v1.11)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f581 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x00\tMallard BASIC program data (v1.11)")
  gof = off + ml
  out = append(out, "Mallard BASIC program data (v1.11)")
  goto s581
s581:
  goto end
f581:
  // 0	string	\xfc\x04\x00	Mallard BASIC program data (v1.29+)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f582 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x00\tMallard BASIC program data (v1.29+)")
  gof = off + ml
  out = append(out, "Mallard BASIC program data (v1.29+)")
  goto s582
s582:
  goto end
f582:
  // 0	string	\xfc\x03\x01	Mallard BASIC protected program data (v1.11)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f583 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x01\tMallard BASIC protected program data (v1.11)")
  gof = off + ml
  out = append(out, "Mallard BASIC protected program data (v1.11)")
  goto s583
s583:
  goto end
f583:
  // 0	string	\xfc\x04\x01	Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f584 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x01\tMallard BASIC protected program data (v1.29+)")
  gof = off + ml
  out = append(out, "Mallard BASIC protected program data (v1.29+)")
  goto s584
s584:
  goto end
f584:
  // 0	string	MIOPEN		Mallard BASIC Jetsam data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x4f, 0x50, 0x45, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f585 }
  fmt.Printf("matched rule: %s\n", "0\tstring\tMIOPEN\t\tMallard BASIC Jetsam data")
  gof = off + ml
  out = append(out, "Mallard BASIC Jetsam data")
  goto s585
s585:
  goto end
f585:
  // 0	string	Jetsam0		Mallard BASIC Jetsam index data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4a, 0x65, 0x74, 0x73, 0x61, 0x6d, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f586 }
  fmt.Printf("matched rule: %s\n", "0\tstring\tJetsam0\t\tMallard BASIC Jetsam index data")
  gof = off + ml
  out = append(out, "Mallard BASIC Jetsam index data")
  goto s586
s586:
  goto end
f586:
  // 0x3	ushort	>1979
  off = pageOff + 0x3
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv)) > 0x7bb)) { goto f587 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0x3\tushort\t>1979")
  gof = off + ml
  goto s587
s587:
  goto end
f587:
  // 0x53	ubyte-1	<80
  off = pageOff + 0x53
  {
    iv, ok := readU8le(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0x50)) { goto f593 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0x53\tubyte-1\t<80")
  gof = off + ml
  goto s593
s593:
  goto end
f593:
  // 0	string	\x8bBACKUP\x20
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x8b, 0x42, 0x41, 0x43, 0x4b, 0x55, 0x50, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f599 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\x8bBACKUP\\x20")
  gof = off + ml
  goto s599
s599:
  goto end
f599:
end:
  return out, nil
}

func Identify__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f0 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f9 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  gof = off + ml
  out = append(out, "JAR compressed with pack200,")
  goto s9
s9:
  goto end
f9:
  // 0	belong		0xcafed00d	JAR compressed with pack200,
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafed00d)) { goto f12 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafed00d\tJAR compressed with pack200,")
  gof = off + ml
  out = append(out, "JAR compressed with pack200,")
  goto s12
s12:
  goto end
f12:
  // 0	belong		0xcafebabe
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xcafebabe)) { goto f15 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xcafebabe")
  gof = off + ml
  goto s15
s15:
  goto end
f15:
  // 0	string/wt	#!\ /bin/sh		POSIX shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f26 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/sh\t\tPOSIX shell script text executable")
  gof = off + ml
  out = append(out, "POSIX shell script text executable")
  goto s26
s26:
  goto end
f26:
  // 0	string/wb	#!\ /bin/sh		POSIX shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f27 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/sh\t\tPOSIX shell script executable (binary data)")
  gof = off + ml
  out = append(out, "POSIX shell script executable (binary data)")
  goto s27
s27:
  goto end
f27:
  // 0	string/wt	#!\ /bin/csh		C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f28 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/csh\t\tC shell script text executable")
  gof = off + ml
  out = append(out, "C shell script text executable")
  goto s28
s28:
  goto end
f28:
  // 0	string/wt	#!\ /bin/ksh		Korn shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f29 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/ksh\t\tKorn shell script text executable")
  gof = off + ml
  out = append(out, "Korn shell script text executable")
  goto s29
s29:
  goto end
f29:
  // 0	string/wb	#!\ /bin/ksh		Korn shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6b, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f30 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/ksh\t\tKorn shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Korn shell script executable (binary data)")
  goto s30
s30:
  goto end
f30:
  // 0	string/wt 	#!\ /bin/tcsh		Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f31 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /bin/tcsh\t\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s31
s31:
  goto end
f31:
  // 0	string/wt	#!\ /usr/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f32 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/tcsh\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s32
s32:
  goto end
f32:
  // 0	string/wt 	#!\ /usr/local/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f33 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt \t#!\\ /usr/local/tcsh\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s33
s33:
  goto end
f33:
  // 0	string/wt	#!\ /usr/local/bin/tcsh	Tenex C shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x74, 0x63, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f34 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/tcsh\tTenex C shell script text executable")
  gof = off + ml
  out = append(out, "Tenex C shell script text executable")
  goto s34
s34:
  goto end
f34:
  // 0	string/wt	#!\ /bin/zsh		Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f35 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/zsh\t\tPaul Falstad's zsh script text executable")
  gof = off + ml
  out = append(out, "Paul Falstad's zsh script text executable")
  goto s35
s35:
  goto end
f35:
  // 0	string/wt	#!\ /usr/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f36 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/zsh\tPaul Falstad's zsh script text executable")
  gof = off + ml
  out = append(out, "Paul Falstad's zsh script text executable")
  goto s36
s36:
  goto end
f36:
  // 0	string/wt	#!\ /usr/local/bin/zsh	Paul Falstad's zsh script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x7a, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f37 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/zsh\tPaul Falstad's zsh script text executable")
  gof = off + ml
  out = append(out, "Paul Falstad's zsh script text executable")
  goto s37
s37:
  goto end
f37:
  // 0	string/wt	#!\ /usr/local/bin/ash	Neil Brown's ash script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f38 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ash\tNeil Brown's ash script text executable")
  gof = off + ml
  out = append(out, "Neil Brown's ash script text executable")
  goto s38
s38:
  goto end
f38:
  // 0	string/wt	#!\ /usr/local/bin/ae	Neil Brown's ae script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f39 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/ae\tNeil Brown's ae script text executable")
  gof = off + ml
  out = append(out, "Neil Brown's ae script text executable")
  goto s39
s39:
  goto end
f39:
  // 0	string/wt	#!\ /bin/nawk		new awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f40 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/nawk\t\tnew awk script text executable")
  gof = off + ml
  out = append(out, "new awk script text executable")
  goto s40
s40:
  goto end
f40:
  // 0	string/wt	#!\ /usr/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f41 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/nawk\tnew awk script text executable")
  gof = off + ml
  out = append(out, "new awk script text executable")
  goto s41
s41:
  goto end
f41:
  // 0	string/wt	#!\ /usr/local/bin/nawk	new awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x6e, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f42 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/nawk\tnew awk script text executable")
  gof = off + ml
  out = append(out, "new awk script text executable")
  goto s42
s42:
  goto end
f42:
  // 0	string/wt	#!\ /bin/gawk		GNU awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f43 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/gawk\t\tGNU awk script text executable")
  gof = off + ml
  out = append(out, "GNU awk script text executable")
  goto s43
s43:
  goto end
f43:
  // 0	string/wt	#!\ /usr/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f44 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/gawk\tGNU awk script text executable")
  gof = off + ml
  out = append(out, "GNU awk script text executable")
  goto s44
s44:
  goto end
f44:
  // 0	string/wt	#!\ /usr/local/bin/gawk	GNU awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f45 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/gawk\tGNU awk script text executable")
  gof = off + ml
  out = append(out, "GNU awk script text executable")
  goto s45
s45:
  goto end
f45:
  // 0	string/wt	#!\ /bin/awk		awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f46 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/awk\t\tawk script text executable")
  gof = off + ml
  out = append(out, "awk script text executable")
  goto s46
s46:
  goto end
f46:
  // 0	string/wt	#!\ /usr/bin/awk	awk script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x61, 0x77, 0x6b}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f47 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/awk\tawk script text executable")
  gof = off + ml
  out = append(out, "awk script text executable")
  goto s47
s47:
  goto end
f47:
  // 0	string/wt	#!\ /bin/rc	Plan 9 rc shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x72, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f48 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/rc\tPlan 9 rc shell script text executable")
  gof = off + ml
  out = append(out, "Plan 9 rc shell script text executable")
  goto s48
s48:
  goto end
f48:
  // 0	string/wt	#!\ /bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f49 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /bin/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s49
s49:
  goto end
f49:
  // 0	string/wb	#!\ /bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f50 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /bin/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s50
s50:
  goto end
f50:
  // 0	string/wt	#!\ /usr/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f51 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/bin/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s51
s51:
  goto end
f51:
  // 0	string/wb	#!\ /usr/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f52 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/bin/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s52
s52:
  goto end
f52:
  // 0	string/wt	#!\ /usr/local/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f53 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s53
s53:
  goto end
f53:
  // 0	string/wb	#!\ /usr/local/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f54 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s54
s54:
  goto end
f54:
  // 0	string/wt	#!\ /usr/local/bin/bash	Bourne-Again shell script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f55 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wt\t#!\\ /usr/local/bin/bash\tBourne-Again shell script text executable")
  gof = off + ml
  out = append(out, "Bourne-Again shell script text executable")
  goto s55
s55:
  goto end
f55:
  // 0	string/wb	#!\ /usr/local/bin/bash	Bourne-Again shell script executable (binary data)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x20, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:true, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f56 }
  fmt.Printf("matched rule: %s\n", "0\tstring/wb\t#!\\ /usr/local/bin/bash\tBourne-Again shell script executable (binary data)")
  gof = off + ml
  out = append(out, "Bourne-Again shell script executable (binary data)")
  goto s56
s56:
  goto end
f56:
  // 0	search/1/c	=<?php			PHP script text
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?php"))
  if ml < 0 { goto f57 }
  ml += 0x6
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/c\t=<?php\t\t\tPHP script text")
  gof = off + ml
  out = append(out, "PHP script text")
  goto s57
s57:
  goto end
f57:
  // 0	search/1	=<?\n			PHP script text
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\n"))
  if ml < 0 { goto f58 }
  ml += 0x4
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\n\t\t\tPHP script text")
  gof = off + ml
  out = append(out, "PHP script text")
  goto s58
s58:
  goto end
f58:
  // 0	search/1	=<?\r			PHP script text
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "=<?\r"))
  if ml < 0 { goto f59 }
  ml += 0x4
  fmt.Printf("matched rule: %s\n", "0\tsearch/1\t=<?\\r\t\t\tPHP script text")
  gof = off + ml
  out = append(out, "PHP script text")
  goto s59
s59:
  goto end
f59:
  // 0	search/1/w	#!\ /usr/local/bin/php	PHP script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/local/bin/php"))
  if ml < 0 { goto f60 }
  ml += 0x15
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/local/bin/php\tPHP script text executable")
  gof = off + ml
  out = append(out, "PHP script text executable")
  goto s60
s60:
  goto end
f60:
  // 0	search/1/w	#!\ /usr/bin/php	PHP script text executable
  off = pageOff + 0x0
  ml = i64(wizardry.SearchTest(tb, int(off), 0x1, "#! /usr/bin/php"))
  if ml < 0 { goto f61 }
  ml += 0xf
  fmt.Printf("matched rule: %s\n", "0\tsearch/1/w\t#!\\ /usr/bin/php\tPHP script text executable")
  gof = off + ml
  out = append(out, "PHP script text executable")
  goto s61
s61:
  goto end
f61:
  // 0	string	=<?php\ /*\ Smarty\ version	Smarty compiled template
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x3c, 0x3f, 0x70, 0x68, 0x70, 0x20, 0x2f, 0x2a, 0x20, 0x53, 0x6d, 0x61, 0x72, 0x74, 0x79, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f62 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t=<?php\\ /*\\ Smarty\\ version\tSmarty compiled template")
  gof = off + ml
  out = append(out, "Smarty compiled template")
  goto s62
s62:
  goto end
f62:
  // 0	string		Zend\x00		PHP script Zend Optimizer data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x5a, 0x65, 0x6e, 0x64, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f63 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tZend\\x00\t\tPHP script Zend Optimizer data")
  gof = off + ml
  out = append(out, "PHP script Zend Optimizer data")
  goto s63
s63:
  goto end
f63:
  // 0	string/t	$!			DCL command file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f64 }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t$!\t\t\tDCL command file")
  gof = off + ml
  out = append(out, "DCL command file")
  goto s64
s64:
  goto end
f64:
  // 0	string		#!/usr/bin/pdmenu	Pdmenu configuration file text
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x23, 0x21, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x70, 0x64, 0x6d, 0x65, 0x6e, 0x75}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f65 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t#!/usr/bin/pdmenu\tPdmenu configuration file text")
  gof = off + ml
  out = append(out, "Pdmenu configuration file text")
  goto s65
s65:
  goto end
f65:
  // 0	string		\177ELF		ELF
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x7f, 0x45, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f66 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t\\177ELF\t\tELF")
  gof = off + ml
  out = append(out, "ELF")
  goto s66
s66:
  goto end
f66:
  // 0	lelong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f95 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong&0xfffffffe\t0xfeedface\tMach-O")
  gof = off + ml
  out = append(out, "Mach-O")
  goto s95
s95:
  goto end
f95:
  // 0	belong&0xfffffffe	0xfeedface	Mach-O
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv)&0xfffffffe == 0xfeedface)) { goto f97 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong&0xfffffffe\t0xfeedface\tMach-O")
  gof = off + ml
  out = append(out, "Mach-O")
  goto s97
s97:
  goto end
f97:
  // 0	string/t	@
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x40}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:true, ForceBinary:false}))
  if ml < 0 { goto f99 }
  fmt.Printf("matched rule: %s\n", "0\tstring/t\t@")
  gof = off + ml
  goto s99
s99:
  goto end
f99:
  // 100	search/0xffff   rxfuncadd
  off = pageOff + 0x64
  ml = i64(wizardry.SearchTest(tb, int(off), 0xffff, "rxfuncadd"))
  if ml < 0 { goto f104 }
  ml += 0x9
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   rxfuncadd")
  gof = off + ml
  goto s104
s104:
  goto end
f104:
  // 100	search/0xffff   say
  off = pageOff + 0x64
  ml = i64(wizardry.SearchTest(tb, int(off), 0xffff, "say"))
  if ml < 0 { goto f105 }
  ml += 0x3
  fmt.Printf("matched rule: %s\n", "100\tsearch/0xffff   say")
  gof = off + ml
  goto s105
s105:
  goto end
f105:
  // 0	leshort		0x166	MS Windows COFF MIPS R4000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x166)) { goto f106 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x166\tMS Windows COFF MIPS R4000 object file")
  gof = off + ml
  out = append(out, "MS Windows COFF MIPS R4000 object file")
  goto s106
s106:
  goto end
f106:
  // 0	leshort		0x184	MS Windows COFF Alpha object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x184)) { goto f107 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x184\tMS Windows COFF Alpha object file")
  gof = off + ml
  out = append(out, "MS Windows COFF Alpha object file")
  goto s107
s107:
  goto end
f107:
  // 0	leshort		0x268	MS Windows COFF Motorola 68000 object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x268)) { goto f108 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x268\tMS Windows COFF Motorola 68000 object file")
  gof = off + ml
  out = append(out, "MS Windows COFF Motorola 68000 object file")
  goto s108
s108:
  goto end
f108:
  // 0	leshort		0x1f0	MS Windows COFF PowerPC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x1f0)) { goto f109 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x1f0\tMS Windows COFF PowerPC object file")
  gof = off + ml
  out = append(out, "MS Windows COFF PowerPC object file")
  goto s109
s109:
  goto end
f109:
  // 0	leshort		0x290	MS Windows COFF PA-RISC object file
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x290)) { goto f110 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x290\tMS Windows COFF PA-RISC object file")
  gof = off + ml
  out = append(out, "MS Windows COFF PA-RISC object file")
  goto s110
s110:
  goto end
f110:
  // 0	string/b	MZ
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f111 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMZ")
  gof = off + ml
  goto s111
s111:
  goto end
f111:
  // 0	string/b	KCF		FreeDOS KEYBoard Layout collection
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x43, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f298 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKCF\t\tFreeDOS KEYBoard Layout collection")
  gof = off + ml
  out = append(out, "FreeDOS KEYBoard Layout collection")
  goto s298
s298:
  goto end
f298:
  // 0	string/b	KLF		FreeDOS KEYBoard Layout file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4b, 0x4c, 0x46}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f304 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tKLF\t\tFreeDOS KEYBoard Layout file")
  gof = off + ml
  out = append(out, "FreeDOS KEYBoard Layout file")
  goto s304
s304:
  goto end
f304:
  // 0	string	\xffKEYB\ \ \ \0\0\0\0
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xff, 0x4b, 0x45, 0x59, 0x42, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f308 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xffKEYB\\ \\ \\ \\0\\0\\0\\0")
  gof = off + ml
  goto s308
s308:
  goto end
f308:
  // 0	ulequad&0x07a0ffffffff		0xffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv)&0x7a0ffffffff == 0xffffffff)) { goto f310 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad&0x07a0ffffffff\t\t0xffffffff")
  gof = off + ml
  goto s310
s310:
  goto end
f310:
  // 0	ulequad				0x0513c00000000012
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x513c00000000012)) { goto f312 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0513c00000000012")
  gof = off + ml
  goto s312
s312:
  goto end
f312:
  // 0	ulequad				0x32f28000ffff0016
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x32f28000ffff0016)) { goto f314 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x32f28000ffff0016")
  gof = off + ml
  goto s314
s314:
  goto end
f314:
  // 0	ulequad				0x007f00000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x7f00000000ffff)) { goto f316 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x007f00000000ffff")
  gof = off + ml
  goto s316
s316:
  goto end
f316:
  // 0	ulequad				0x001600000000ffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x1600000000ffff)) { goto f318 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x001600000000ffff")
  gof = off + ml
  goto s318
s318:
  goto end
f318:
  // 0	ulequad				0x0bf708c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0xbf708c2ffffffff)) { goto f320 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x0bf708c2ffffffff")
  gof = off + ml
  goto s320
s320:
  goto end
f320:
  // 0	ulequad				0x07bd08c2ffffffff
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x7bd08c2ffffffff)) { goto f322 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t\t\t\t0x07bd08c2ffffffff")
  gof = off + ml
  goto s322
s322:
  goto end
f322:
  // 0	ubyte		0x8c
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0x8c)) { goto f324 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0x8c")
  gof = off + ml
  goto s324
s324:
  goto end
f324:
  // 0	ulelong		0xffff10eb	DR-DOS executable (COM)
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0xffff10eb)) { goto f328 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tulelong\t\t0xffff10eb\tDR-DOS executable (COM)")
  gof = off + ml
  out = append(out, "DR-DOS executable (COM)")
  goto s328
s328:
  goto end
f328:
  // 0	ubeshort&0xeb8d	>0xeb00
  off = pageOff + 0x0
  {
    iv, ok := readU16le(tb, off)
    if !(ok && (i64(i16(iv))&0xeb8d > 0xeb00)) { goto f329 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tubeshort&0xeb8d\t>0xeb00")
  gof = off + ml
  goto s329
s329:
  goto end
f329:
  // 0	        byte	0xeb
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xeb)) { goto f330 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0\t        byte\t0xeb")
  gof = off + ml
  goto s330
s330:
  goto end
f330:
  // 0           byte    0xe9
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xe9)) { goto f334 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0           byte    0xe9")
  gof = off + ml
  goto s334
s334:
  goto end
f334:
  // 0	ubyte		0xb8
  off = pageOff + 0x0
  {
    iv, ok := readU8be(tb, off)
    if !(ok && (u64(iv) == 0xb8)) { goto f341 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0\tubyte\t\t0xb8")
  gof = off + ml
  goto s341
s341:
  goto end
f341:
  // 0	string/b	\x81\xfc
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x81, 0xfc}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f347 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x81\\xfc")
  gof = off + ml
  goto s347
s347:
  goto end
f347:
  // 252	string Must\ have\ DOS\ version DR-DOS executable (COM)
  off = pageOff + 0xfc
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x75, 0x73, 0x74, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f350 }
  fmt.Printf("matched rule: %s\n", "252\tstring Must\\ have\\ DOS\\ version DR-DOS executable (COM)")
  gof = off + ml
  out = append(out, "DR-DOS executable (COM)")
  goto s350
s350:
  goto end
f350:
  // 34	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x22
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f351 }
  fmt.Printf("matched rule: %s\n", "34\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  gof = off + ml
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto s351
s351:
  goto end
f351:
  // 35	string	UPX!			FREE-DOS executable (COM), UPX compressed
  off = pageOff + 0x23
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x55, 0x50, 0x58, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f352 }
  fmt.Printf("matched rule: %s\n", "35\tstring\tUPX!\t\t\tFREE-DOS executable (COM), UPX compressed")
  gof = off + ml
  out = append(out, "FREE-DOS executable (COM), UPX compressed")
  goto s352
s352:
  goto end
f352:
  // 2	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x2
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f353 }
  fmt.Printf("matched rule: %s\n", "2\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s353
s353:
  goto end
f353:
  // 4	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x4
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f354 }
  fmt.Printf("matched rule: %s\n", "4\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s354
s354:
  goto end
f354:
  // 5	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x5
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f355 }
  fmt.Printf("matched rule: %s\n", "5\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s355
s355:
  goto end
f355:
  // 7	string	\xcd\x21
  off = pageOff + 0x7
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f356 }
  fmt.Printf("matched rule: %s\n", "7\tstring\t\\xcd\\x21")
  gof = off + ml
  goto s356
s356:
  goto end
f356:
  // 10	string	\xcd\x21
  off = pageOff + 0xa
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f358 }
  fmt.Printf("matched rule: %s\n", "10\tstring\t\\xcd\\x21")
  gof = off + ml
  goto s358
s358:
  goto end
f358:
  // 13	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0xd
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f360 }
  fmt.Printf("matched rule: %s\n", "13\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s360
s360:
  goto end
f360:
  // 18	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x12
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f361 }
  fmt.Printf("matched rule: %s\n", "18\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s361
s361:
  goto end
f361:
  // 23	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x17
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f362 }
  fmt.Printf("matched rule: %s\n", "23\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s362
s362:
  goto end
f362:
  // 30	string	\xcd\x21		COM executable for MS-DOS
  off = pageOff + 0x1e
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f363 }
  fmt.Printf("matched rule: %s\n", "30\tstring\t\\xcd\\x21\t\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s363
s363:
  goto end
f363:
  // 70	string	\xcd\x21		COM executable for DOS
  off = pageOff + 0x46
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xcd, 0x21}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f364 }
  fmt.Printf("matched rule: %s\n", "70\tstring\t\\xcd\\x21\t\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s364
s364:
  goto end
f364:
  // 0x6	search/0xa	\xfc\x57\xf3\xa5\xc3	COM executable for MS-DOS
  off = pageOff + 0x6
  ml = i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa5\xc3"))
  if ml < 0 { goto f365 }
  ml += 0x5
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa5\\xc3\tCOM executable for MS-DOS")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS")
  goto s365
s365:
  goto end
f365:
  // 0x6	search/0xa	\xfc\x57\xf3\xa4\xc3	COM executable for DOS
  off = pageOff + 0x6
  ml = i64(wizardry.SearchTest(tb, int(off), 0xa, "\xfcW\xf3\xa4\xc3"))
  if ml < 0 { goto f366 }
  ml += 0x5
  fmt.Printf("matched rule: %s\n", "0x6\tsearch/0xa\t\\xfc\\x57\\xf3\\xa4\\xc3\tCOM executable for DOS")
  gof = off + ml
  out = append(out, "COM executable for DOS")
  goto s366
s366:
  goto end
f366:
  // 0x3c	string		W\ Collis\0\0		COM executable for MS-DOS, Compack compressed
  off = pageOff + 0x3c
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f368 }
  fmt.Printf("matched rule: %s\n", "0x3c\tstring\t\tW\\ Collis\\0\\0\t\tCOM executable for MS-DOS, Compack compressed")
  gof = off + ml
  out = append(out, "COM executable for MS-DOS, Compack compressed")
  goto s368
s368:
  goto end
f368:
  // 0	string/b	LZ		MS-DOS executable (built-in)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4c, 0x5a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f369 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tLZ\t\tMS-DOS executable (built-in)")
  gof = off + ml
  out = append(out, "MS-DOS executable (built-in)")
  goto s369
s369:
  goto end
f369:
  // 0	string/b	\320\317\021\340\241\261\032\341AAFB\015\000OM\006\016\053\064\001\001\001\377			AAF legacy file using MS Structured Storage
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x41, 0x41, 0x46, 0x42, 0xd, 0x0, 0x4f, 0x4d, 0x6, 0xe, 0x2b, 0x34, 0x1, 0x1, 0x1, 0xff}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f370 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341AAFB\\015\\000OM\\006\\016\\053\\064\\001\\001\\001\\377\t\t\tAAF legacy file using MS Structured Storage")
  gof = off + ml
  out = append(out, "AAF legacy file using MS Structured Storage")
  goto s370
s370:
  goto end
f370:
  // 0	string/b	\320\317\021\340\241\261\032\341\001\002\001\015\000\002\000\000\006\016\053\064\003\002\001\001			AAF file using MS Structured Storage
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1, 0x1, 0x2, 0x1, 0xd, 0x0, 0x2, 0x0, 0x0, 0x6, 0xe, 0x2b, 0x34, 0x3, 0x2, 0x1, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f373 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\\001\\002\\001\\015\\000\\002\\000\\000\\006\\016\\053\\064\\003\\002\\001\\001\t\t\tAAF file using MS Structured Storage")
  gof = off + ml
  out = append(out, "AAF file using MS Structured Storage")
  goto s373
s373:
  goto end
f373:
  // 2080	string	Microsoft\ Word\ 6.0\ Document	%s
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36, 0x2e, 0x30, 0x20, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f376 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Word\\ 6.0\\ Document\t%s")
  gof = off + ml
  out = append(out, "%s")
  goto s376
s376:
  goto end
f376:
  // 2080	string	Documento\ Microsoft\ Word\ 6 Spanish Microsoft Word 6 document data
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x57, 0x6f, 0x72, 0x64, 0x20, 0x36}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f377 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tDocumento\\ Microsoft\\ Word\\ 6 Spanish Microsoft Word 6 document data")
  gof = off + ml
  out = append(out, "Spanish Microsoft Word 6 document data")
  goto s377
s377:
  goto end
f377:
  // 2112	string	MSWordDoc			Microsoft Word document data
  off = pageOff + 0x840
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x6f, 0x72, 0x64, 0x44, 0x6f, 0x63}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f378 }
  fmt.Printf("matched rule: %s\n", "2112\tstring\tMSWordDoc\t\t\tMicrosoft Word document data")
  gof = off + ml
  out = append(out, "Microsoft Word document data")
  goto s378
s378:
  goto end
f378:
  // 0	belong	0x31be0000			Microsoft Word Document
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x31be0000)) { goto f379 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x31be0000\t\t\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s379
s379:
  goto end
f379:
  // 0	string/b	PO^Q`				Microsoft Word 6.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4f, 0x5e, 0x51, 0x60}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f380 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPO^Q`\t\t\t\tMicrosoft Word 6.0 Document")
  gof = off + ml
  out = append(out, "Microsoft Word 6.0 Document")
  goto s380
s380:
  goto end
f380:
  // 4   long        0
  off = pageOff + 0x4
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x0)) { goto f381 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "4   long        0")
  gof = off + ml
  goto s381
s381:
  goto end
f381:
  // 0	string/b	\333\245-\0\0\0			Microsoft Word 2.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f386 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\333\\245-\\0\\0\\0\t\t\tMicrosoft Word 2.0 Document")
  gof = off + ml
  out = append(out, "Microsoft Word 2.0 Document")
  goto s386
s386:
  goto end
f386:
  // 512	string/b	\354\245\301			Microsoft Word Document
  off = pageOff + 0x200
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xec, 0xa5, 0xc1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f387 }
  fmt.Printf("matched rule: %s\n", "512\tstring/b\t\\354\\245\\301\t\t\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s387
s387:
  goto end
f387:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f388 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  gof = off + ml
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto s388
s388:
  goto end
f388:
  // 2080	string	Microsoft\ Excel\ 5.0\ Worksheet	%s
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65, 0x6c, 0x20, 0x35, 0x2e, 0x30, 0x20, 0x57, 0x6f, 0x72, 0x6b, 0x73, 0x68, 0x65, 0x65, 0x74}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f389 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tMicrosoft\\ Excel\\ 5.0\\ Worksheet\t%s")
  gof = off + ml
  out = append(out, "%s")
  goto s389
s389:
  goto end
f389:
  // 0	string/b	\xDB\xA5\x2D\x00		Microsoft WinWord 2.0 Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xdb, 0xa5, 0x2d, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f390 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\xDB\\xA5\\x2D\\x00\t\tMicrosoft WinWord 2.0 Document")
  gof = off + ml
  out = append(out, "Microsoft WinWord 2.0 Document")
  goto s390
s390:
  goto end
f390:
  // 2080	string	Foglio\ di\ lavoro\ Microsoft\ Exce	%s
  off = pageOff + 0x820
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x46, 0x6f, 0x67, 0x6c, 0x69, 0x6f, 0x20, 0x64, 0x69, 0x20, 0x6c, 0x61, 0x76, 0x6f, 0x72, 0x6f, 0x20, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x45, 0x78, 0x63, 0x65}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f391 }
  fmt.Printf("matched rule: %s\n", "2080\tstring\tFoglio\\ di\\ lavoro\\ Microsoft\\ Exce\t%s")
  gof = off + ml
  out = append(out, "%s")
  goto s391
s391:
  goto end
f391:
  // 2114	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x842
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f392 }
  fmt.Printf("matched rule: %s\n", "2114\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  gof = off + ml
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto s392
s392:
  goto end
f392:
  // 2121	string	Biff5		Microsoft Excel 5.0 Worksheet
  off = pageOff + 0x849
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x69, 0x66, 0x66, 0x35}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f393 }
  fmt.Printf("matched rule: %s\n", "2121\tstring\tBiff5\t\tMicrosoft Excel 5.0 Worksheet")
  gof = off + ml
  out = append(out, "Microsoft Excel 5.0 Worksheet")
  goto s393
s393:
  goto end
f393:
  // 0	string/b	\x09\x04\x06\x00\x00\x00\x10\x00	Microsoft Excel Worksheet
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x9, 0x4, 0x6, 0x0, 0x0, 0x0, 0x10, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f394 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\x09\\x04\\x06\\x00\\x00\\x00\\x10\\x00\tMicrosoft Excel Worksheet")
  gof = off + ml
  out = append(out, "Microsoft Excel Worksheet")
  goto s394
s394:
  goto end
f394:
  // 0	belong	0x00001a00
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x1a00)) { goto f395 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00001a00")
  gof = off + ml
  goto s395
s395:
  goto end
f395:
  // 0	belong	0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f421 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t0x00000200")
  gof = off + ml
  goto s421
s421:
  goto end
f421:
  // 0	string/b		WordPro\0	Lotus WordPro
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f443 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\0\tLotus WordPro")
  gof = off + ml
  out = append(out, "Lotus WordPro")
  goto s443
s443:
  goto end
f443:
  // 0	string/b		WordPro\r\373	Lotus WordPro
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x6f, 0x72, 0x64, 0x50, 0x72, 0x6f, 0xd, 0xfb}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f444 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\tWordPro\\r\\373\tLotus WordPro")
  gof = off + ml
  out = append(out, "Lotus WordPro")
  goto s444
s444:
  goto end
f444:
  // 0		string		\x71\xa8\x00\x00\x01\x02
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x71, 0xa8, 0x0, 0x0, 0x1, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f445 }
  fmt.Printf("matched rule: %s\n", "0\t\tstring\t\t\\x71\\xa8\\x00\\x00\\x01\\x02")
  gof = off + ml
  goto s445
s445:
  goto end
f445:
  // 0	string/b	Nullsoft\ AVS\ Preset\ 	Winamp plug in
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x75, 0x6c, 0x6c, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x41, 0x56, 0x53, 0x20, 0x50, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f447 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tNullsoft\\ AVS\\ Preset\\ \tWinamp plug in")
  gof = off + ml
  out = append(out, "Winamp plug in")
  goto s447
s447:
  goto end
f447:
  // 0	string/b	\327\315\306\232	ms-windows metafont .wmf
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd7, 0xcd, 0xc6, 0x9a}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f448 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\327\\315\\306\\232\tms-windows metafont .wmf")
  gof = off + ml
  out = append(out, "ms-windows metafont .wmf")
  goto s448
s448:
  goto end
f448:
  // 0	string/b	\002\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x2, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f449 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\002\\000\\011\\000\tms-windows metafont .wmf")
  gof = off + ml
  out = append(out, "ms-windows metafont .wmf")
  goto s449
s449:
  goto end
f449:
  // 0	string/b	\001\000\011\000	ms-windows metafont .wmf
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x1, 0x0, 0x9, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f450 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\001\\000\\011\\000\tms-windows metafont .wmf")
  gof = off + ml
  out = append(out, "ms-windows metafont .wmf")
  goto s450
s450:
  goto end
f450:
  // 0	string/b	\003\001\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x1, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f451 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\001\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  gof = off + ml
  out = append(out, "tz3 ms-works file")
  goto s451
s451:
  goto end
f451:
  // 0	string/b	\003\002\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x2, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f452 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\002\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  gof = off + ml
  out = append(out, "tz3 ms-works file")
  goto s452
s452:
  goto end
f452:
  // 0	string/b	\003\003\001\004\070\001\000\000	tz3 ms-works file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3, 0x3, 0x1, 0x4, 0x38, 0x1, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f453 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\003\\003\\001\\004\\070\\001\\000\\000\ttz3 ms-works file")
  gof = off + ml
  out = append(out, "tz3 ms-works file")
  goto s453
s453:
  goto end
f453:
  // 0 string \211\000\077\003\005\000\063\237\127\065\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x35, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f454 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\065\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s454
s454:
  goto end
f454:
  // 0 string \211\000\077\003\005\000\063\237\127\066\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x36, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f455 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\066\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s455
s455:
  goto end
f455:
  // 0 string \211\000\077\003\005\000\063\237\127\067\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x37, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f456 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\067\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s456
s456:
  goto end
f456:
  // 0 string \211\000\077\003\005\000\063\237\127\070\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x38, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f457 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\070\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s457
s457:
  goto end
f457:
  // 0 string \211\000\077\003\005\000\063\237\127\071\027\266\151\064\005\045\101\233\021\002 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x3f, 0x3, 0x5, 0x0, 0x33, 0x9f, 0x57, 0x39, 0x17, 0xb6, 0x69, 0x34, 0x5, 0x25, 0x41, 0x9b, 0x11, 0x2}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f458 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\077\\003\\005\\000\\063\\237\\127\\071\\027\\266\\151\\064\\005\\045\\101\\233\\021\\002 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s458
s458:
  goto end
f458:
  // 0 string \211\000\225\003\005\000\062\122\207\304\100\345\042 PGP sig
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x89, 0x0, 0x95, 0x3, 0x5, 0x0, 0x32, 0x52, 0x87, 0xc4, 0x40, 0xe5, 0x22}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f459 }
  fmt.Printf("matched rule: %s\n", "0 string \\211\\000\\225\\003\\005\\000\\062\\122\\207\\304\\100\\345\\042 PGP sig")
  gof = off + ml
  out = append(out, "PGP sig")
  goto s459
s459:
  goto end
f459:
  // 0	string/b	MDIF\032\000\010\000\000\000\372\046\100\175\001\000\001\036\001\000 MS Windows special zipped file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x44, 0x49, 0x46, 0x1a, 0x0, 0x8, 0x0, 0x0, 0x0, 0xfa, 0x26, 0x40, 0x7d, 0x1, 0x0, 0x1, 0x1e, 0x1, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f460 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMDIF\\032\\000\\010\\000\\000\\000\\372\\046\\100\\175\\001\\000\\001\\036\\001\\000 MS Windows special zipped file")
  gof = off + ml
  out = append(out, "MS Windows special zipped file")
  goto s460
s460:
  goto end
f460:
  // 0	string/b	\102\101\050\000\000\000\056\000\000\000\000\000\000\000	Icon for MS Windows
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x41, 0x28, 0x0, 0x0, 0x0, 0x2e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f461 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\102\\101\\050\\000\\000\\000\\056\\000\\000\\000\\000\\000\\000\\000\tIcon for MS Windows")
  gof = off + ml
  out = append(out, "Icon for MS Windows")
  goto s461
s461:
  goto end
f461:
  // 0   belong  0x00000100
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x100)) { goto f462 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000100")
  gof = off + ml
  goto s462
s462:
  goto end
f462:
  // 0   belong  0x00000200
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0x200)) { goto f469 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0   belong  0x00000200")
  gof = off + ml
  goto s469
s469:
  goto end
f469:
  // 0	string/b	PK\010\010BGI	Borland font
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f474 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tPK\\010\\010BGI\tBorland font")
  gof = off + ml
  out = append(out, "Borland font")
  goto s474
s474:
  goto end
f474:
  // 0	string/b	pk\010\010BGI	Borland device
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x70, 0x6b, 0x8, 0x8, 0x42, 0x47, 0x49}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f476 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tpk\\010\\010BGI\tBorland device")
  gof = off + ml
  out = append(out, "Borland device")
  goto s476
s476:
  goto end
f476:
  // 0	lelong		0x00000004
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x4)) { goto f478 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000004")
  gof = off + ml
  goto s478
s478:
  goto end
f478:
  // 0	lelong		0x00000005
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x5)) { goto f480 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x00000005")
  gof = off + ml
  goto s480
s480:
  goto end
f480:
  // 9	string		GERBILDOC	First Choice document
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x4f, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f482 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDOC\tFirst Choice document")
  gof = off + ml
  out = append(out, "First Choice document")
  goto s482
s482:
  goto end
f482:
  // 9	string		GERBILDB	First Choice database
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x44, 0x42}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f483 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILDB\tFirst Choice database")
  gof = off + ml
  out = append(out, "First Choice database")
  goto s483
s483:
  goto end
f483:
  // 9	string		GERBILCLIP	First Choice database
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c, 0x43, 0x4c, 0x49, 0x50}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f484 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tGERBILCLIP\tFirst Choice database")
  gof = off + ml
  out = append(out, "First Choice database")
  goto s484
s484:
  goto end
f484:
  // 0	string		GERBIL		First Choice device file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x45, 0x52, 0x42, 0x49, 0x4c}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f485 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tGERBIL\t\tFirst Choice device file")
  gof = off + ml
  out = append(out, "First Choice device file")
  goto s485
s485:
  goto end
f485:
  // 9	string		RABBITGRAPH	RabbitGraph file
  off = pageOff + 0x9
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x41, 0x42, 0x42, 0x49, 0x54, 0x47, 0x52, 0x41, 0x50, 0x48}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f486 }
  fmt.Printf("matched rule: %s\n", "9\tstring\t\tRABBITGRAPH\tRabbitGraph file")
  gof = off + ml
  out = append(out, "RabbitGraph file")
  goto s486
s486:
  goto end
f486:
  // 0	string		DCU1		Borland Delphi .DCU file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x43, 0x55, 0x31}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f487 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tDCU1\t\tBorland Delphi .DCU file")
  gof = off + ml
  out = append(out, "Borland Delphi .DCU file")
  goto s487
s487:
  goto end
f487:
  // 0	string		=!<spell>	MKS Spell hash list (old format)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f488 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell>\tMKS Spell hash list (old format)")
  gof = off + ml
  out = append(out, "MKS Spell hash list (old format)")
  goto s488
s488:
  goto end
f488:
  // 0	string		=!<spell2>	MKS Spell hash list
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x3d, 0x21, 0x3c, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x32, 0x3e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f489 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\t=!<spell2>\tMKS Spell hash list")
  gof = off + ml
  out = append(out, "MKS Spell hash list")
  goto s489
s489:
  goto end
f489:
  // 0	lelong		0x08086b70	TurboC BGI file
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x8086b70)) { goto f490 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08086b70\tTurboC BGI file")
  gof = off + ml
  out = append(out, "TurboC BGI file")
  goto s490
s490:
  goto end
f490:
  // 0	lelong		0x08084b50	TurboC Font file
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x8084b50)) { goto f491 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x08084b50\tTurboC Font file")
  gof = off + ml
  out = append(out, "TurboC Font file")
  goto s491
s491:
  goto end
f491:
  // 0	string		TPF0
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x54, 0x50, 0x46, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f492 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tTPF0")
  gof = off + ml
  goto s492
s492:
  goto end
f492:
  // 0	string		PMCC		Windows 3.x .GRP file
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x50, 0x4d, 0x43, 0x43}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f493 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tPMCC\t\tWindows 3.x .GRP file")
  gof = off + ml
  out = append(out, "Windows 3.x .GRP file")
  goto s493
s493:
  goto end
f493:
  // 1	string		RDC-meg		MegaDots
  off = pageOff + 0x1
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x44, 0x43, 0x2d, 0x6d, 0x65, 0x67}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f494 }
  fmt.Printf("matched rule: %s\n", "1\tstring\t\tRDC-meg\t\tMegaDots")
  gof = off + ml
  out = append(out, "MegaDots")
  goto s494
s494:
  goto end
f494:
  // 0	lelong		0x4C
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x4c)) { goto f497 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tlelong\t\t0x4C")
  gof = off + ml
  goto s497
s497:
  goto end
f497:
  // 0x171	string	MICROSOFT\ PIFEX\0	Windows Program Information File
  off = pageOff + 0x171
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x43, 0x52, 0x4f, 0x53, 0x4f, 0x46, 0x54, 0x20, 0x50, 0x49, 0x46, 0x45, 0x58, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f499 }
  fmt.Printf("matched rule: %s\n", "0x171\tstring\tMICROSOFT\\ PIFEX\\0\tWindows Program Information File")
  gof = off + ml
  out = append(out, "Windows Program Information File")
  goto s499
s499:
  goto end
f499:
  // 0	belong		0xC5D0D3C6	DOS EPS Binary File
  off = pageOff + 0x0
  {
    iv, ok := readU32le(tb, off)
    if !(ok && (u64(iv) == 0xc5d0d3c6)) { goto f516 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tbelong\t\t0xC5D0D3C6\tDOS EPS Binary File")
  gof = off + ml
  out = append(out, "DOS EPS Binary File")
  goto s516
s516:
  goto end
f516:
  // 0	leshort		0x223e9f78	TNEF
  off = pageOff + 0x0
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (u64(iv) == 0x223e9f78)) { goto f523 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0\tleshort\t\t0x223e9f78\tTNEF")
  gof = off + ml
  out = append(out, "TNEF")
  goto s523
s523:
  goto end
f523:
  // 0	string		NG\0\001
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4e, 0x47, 0x0, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f524 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\tNG\\0\\001")
  gof = off + ml
  goto s524
s524:
  goto end
f524:
  // 0	ulelong	0x48443408		4DOS help file
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x48443408)) { goto f529 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tulelong\t0x48443408\t\t4DOS help file")
  gof = off + ml
  out = append(out, "4DOS help file")
  goto s529
s529:
  goto end
f529:
  // 0	ulequad	0x3a000000024e4c	MS Advisor help file
  off = pageOff + 0x0
  {
    iv, ok := readU64be(tb, off)
    if !(ok && (u64(iv) == 0x3a000000024e4c)) { goto f531 }
    ml = 8
  }
  fmt.Printf("matched rule: %s\n", "0\tulequad\t0x3a000000024e4c\tMS Advisor help file")
  gof = off + ml
  out = append(out, "MS Advisor help file")
  goto s531
s531:
  goto end
f531:
  // 0	string/b	ITSF\003\000\000\000\x60\000\000\000	MS Windows HtmlHelp Data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x53, 0x46, 0x3, 0x0, 0x0, 0x0, 0x60, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f532 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITSF\\003\\000\\000\\000\\x60\\000\\000\\000\tMS Windows HtmlHelp Data")
  gof = off + ml
  out = append(out, "MS Windows HtmlHelp Data")
  goto s532
s532:
  goto end
f532:
  // 2	string/b	GFA-BASIC3	GFA-BASIC 3 data
  off = pageOff + 0x2
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x47, 0x46, 0x41, 0x2d, 0x42, 0x41, 0x53, 0x49, 0x43, 0x33}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f533 }
  fmt.Printf("matched rule: %s\n", "2\tstring/b\tGFA-BASIC3\tGFA-BASIC 3 data")
  gof = off + ml
  out = append(out, "GFA-BASIC 3 data")
  goto s533
s533:
  goto end
f533:
  // 0	string/b	MSCF\0\0\0\0	Microsoft Cabinet archive data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x46, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f534 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCF\\0\\0\\0\\0\tMicrosoft Cabinet archive data")
  gof = off + ml
  out = append(out, "Microsoft Cabinet archive data")
  goto s534
s534:
  goto end
f534:
  // 0	string/b	ISc(		InstallShield Cabinet archive data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x53, 0x63, 0x28}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f538 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tISc(\t\tInstallShield Cabinet archive data")
  gof = off + ml
  out = append(out, "InstallShield Cabinet archive data")
  goto s538
s538:
  goto end
f538:
  // 0	string/b	MSCE\0\0\0\0	Microsoft WinCE install header
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x43, 0x45, 0x0, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f542 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSCE\\0\\0\\0\\0\tMicrosoft WinCE install header")
  gof = off + ml
  out = append(out, "Microsoft WinCE install header")
  goto s542
s542:
  goto end
f542:
  // 0	ulelong 1
  off = pageOff + 0x0
  {
    iv, ok := readU32be(tb, off)
    if !(ok && (u64(iv) == 0x1)) { goto f556 }
    ml = 4
  }
  fmt.Printf("matched rule: %s\n", "0\tulelong 1")
  gof = off + ml
  goto s556
s556:
  goto end
f556:
  // 0	string/b	\320\317\021\340\241\261\032\341	Microsoft Office Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f559 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\320\\317\\021\\340\\241\\261\\032\\341\tMicrosoft Office Document")
  gof = off + ml
  out = append(out, "Microsoft Office Document")
  goto s559
s559:
  goto end
f559:
  // 0	string/b	\224\246\056		Microsoft Word Document
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x94, 0xa6, 0x2e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f562 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\t\\224\\246\\056\t\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s562
s562:
  goto end
f562:
  // 512	string	R\0o\0o\0t\0\ \0E\0n\0t\0r\0y	Microsoft Word Document
  off = pageOff + 0x200
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x52, 0x0, 0x6f, 0x0, 0x6f, 0x0, 0x74, 0x0, 0x20, 0x0, 0x45, 0x0, 0x6e, 0x0, 0x74, 0x0, 0x72, 0x0, 0x79}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f563 }
  fmt.Printf("matched rule: %s\n", "512\tstring\tR\\0o\\0o\\0t\\0\\ \\0E\\0n\\0t\\0r\\0y\tMicrosoft Word Document")
  gof = off + ml
  out = append(out, "Microsoft Word Document")
  goto s563
s563:
  goto end
f563:
  // 0	string/b $RBU
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x24, 0x52, 0x42, 0x55}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f564 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b $RBU")
  gof = off + ml
  goto s564
s564:
  goto end
f564:
  // 0	string/b	DDS\040\174\000\000\000 Microsoft DirectDraw Surface (DDS),
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x44, 0x44, 0x53, 0x20, 0x7c, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f572 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tDDS\\040\\174\\000\\000\\000 Microsoft DirectDraw Surface (DDS),")
  gof = off + ml
  out = append(out, "Microsoft DirectDraw Surface (DDS),")
  goto s572
s572:
  goto end
f572:
  // 0	string/b	ITOLITLS		Microsoft Reader eBook Data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x49, 0x54, 0x4f, 0x4c, 0x49, 0x54, 0x4c, 0x53}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f576 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tITOLITLS\t\tMicrosoft Reader eBook Data")
  gof = off + ml
  out = append(out, "Microsoft Reader eBook Data")
  goto s576
s576:
  goto end
f576:
  // 0	string/b	B000FF\n	Windows Embedded CE binary image
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x42, 0x30, 0x30, 0x30, 0x46, 0x46, 0xa}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f578 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tB000FF\\n\tWindows Embedded CE binary image")
  gof = off + ml
  out = append(out, "Windows Embedded CE binary image")
  goto s578
s578:
  goto end
f578:
  // 0	string/b	MSWIM\000\000\000	Windows imaging (WIM) image
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x53, 0x57, 0x49, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f579 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tMSWIM\\000\\000\\000\tWindows imaging (WIM) image")
  gof = off + ml
  out = append(out, "Windows imaging (WIM) image")
  goto s579
s579:
  goto end
f579:
  // 0	string/b	WLPWM\000\000\000	Windows imaging (WIM) image, wimlib pipable format
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x57, 0x4c, 0x50, 0x57, 0x4d, 0x0, 0x0, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:true}))
  if ml < 0 { goto f580 }
  fmt.Printf("matched rule: %s\n", "0\tstring/b\tWLPWM\\000\\000\\000\tWindows imaging (WIM) image, wimlib pipable format")
  gof = off + ml
  out = append(out, "Windows imaging (WIM) image, wimlib pipable format")
  goto s580
s580:
  goto end
f580:
  // 0	string	\xfc\x03\x00	Mallard BASIC program data (v1.11)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f581 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x00\tMallard BASIC program data (v1.11)")
  gof = off + ml
  out = append(out, "Mallard BASIC program data (v1.11)")
  goto s581
s581:
  goto end
f581:
  // 0	string	\xfc\x04\x00	Mallard BASIC program data (v1.29+)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x0}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f582 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x00\tMallard BASIC program data (v1.29+)")
  gof = off + ml
  out = append(out, "Mallard BASIC program data (v1.29+)")
  goto s582
s582:
  goto end
f582:
  // 0	string	\xfc\x03\x01	Mallard BASIC protected program data (v1.11)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x3, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f583 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x03\\x01\tMallard BASIC protected program data (v1.11)")
  gof = off + ml
  out = append(out, "Mallard BASIC protected program data (v1.11)")
  goto s583
s583:
  goto end
f583:
  // 0	string	\xfc\x04\x01	Mallard BASIC protected program data (v1.29+)
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0xfc, 0x4, 0x1}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f584 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\xfc\\x04\\x01\tMallard BASIC protected program data (v1.29+)")
  gof = off + ml
  out = append(out, "Mallard BASIC protected program data (v1.29+)")
  goto s584
s584:
  goto end
f584:
  // 0	string	MIOPEN		Mallard BASIC Jetsam data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4d, 0x49, 0x4f, 0x50, 0x45, 0x4e}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f585 }
  fmt.Printf("matched rule: %s\n", "0\tstring\tMIOPEN\t\tMallard BASIC Jetsam data")
  gof = off + ml
  out = append(out, "Mallard BASIC Jetsam data")
  goto s585
s585:
  goto end
f585:
  // 0	string	Jetsam0		Mallard BASIC Jetsam index data
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x4a, 0x65, 0x74, 0x73, 0x61, 0x6d, 0x30}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f586 }
  fmt.Printf("matched rule: %s\n", "0\tstring\tJetsam0\t\tMallard BASIC Jetsam index data")
  gof = off + ml
  out = append(out, "Mallard BASIC Jetsam index data")
  goto s586
s586:
  goto end
f586:
  // 0x3	ushort	>1979
  off = pageOff + 0x3
  {
    iv, ok := readU16be(tb, off)
    if !(ok && (i64(i16(iv)) > 0x7bb)) { goto f587 }
    ml = 2
  }
  fmt.Printf("matched rule: %s\n", "0x3\tushort\t>1979")
  gof = off + ml
  goto s587
s587:
  goto end
f587:
  // 0x53	ubyte-1	<80
  off = pageOff + 0x53
  {
    iv, ok := readU8be(tb, off)
    if !(ok && ((i64(i8(iv))-0x1) < 0x50)) { goto f593 }
    ml = 1
  }
  fmt.Printf("matched rule: %s\n", "0x53\tubyte-1\t<80")
  gof = off + ml
  goto s593
s593:
  goto end
f593:
  // 0	string	\x8bBACKUP\x20
  off = pageOff + 0x0
  ml = i64(wizardry.StringTest(tb, int(off), []byte{0x8b, 0x42, 0x41, 0x43, 0x4b, 0x55, 0x50, 0x20}, wizardry.StringTestFlags{CompactWhitespace:false, OptionalBlanks:false, LowerMatchesBoth:false, UpperMatchesBoth:false, ForceText:false, ForceBinary:false}))
  if ml < 0 { goto f599 }
  fmt.Printf("matched rule: %s\n", "0\tstring\t\\x8bBACKUP\\x20")
  gof = off + ml
  goto s599
s599:
  goto end
f599:
end:
  return out, nil
}

func IdentifyCurEntry(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		cur-entry
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-entry")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyCurEntry__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		cur-entry
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-entry")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyCurIcoDir(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		cur-ico-dir
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-ico-dir")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyCurIcoDir__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		cur-ico-dir
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tcur-ico-dir")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyCurIcoEntry(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0		name		cur-ico-entry
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\t\tname\t\tcur-ico-entry")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyCurIcoEntry__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0		name		cur-ico-entry
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\t\tname\t\tcur-ico-entry")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyElfLe(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		elf-le
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\telf-le")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyElfLe__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		elf-le
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\telf-le")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyIcoEntry(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		ico-entry
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tico-entry")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyIcoEntry__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		ico-entry
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tico-entry")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyLotusCells(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		lotus-cells
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tlotus-cells")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyLotusCells__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		lotus-cells
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tlotus-cells")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMachO(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		mach-o		\b [
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o\t\t\\b [")
  gof = off + ml
  out = append(out, "\\b [")
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMachO__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		mach-o		\b [
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o\t\t\\b [")
  gof = off + ml
  out = append(out, "\\b [")
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMachOBe(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		mach-o-be
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o-be")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMachOBe__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name		mach-o-be
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\t\tmach-o-be")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMachOCpu(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name	mach-o-cpu
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\tmach-o-cpu")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMachOCpu__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0	name	mach-o-cpu
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0\tname\tmach-o-cpu")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMsdosCom(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0       name    msdos-com
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0       name    msdos-com")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMsdosCom__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0       name    msdos-com
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0       name    msdos-com")
  gof = off + ml
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMsdosDriver(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0       name    			msdos-driver		DOS executable (
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0       name    \t\t\tmsdos-driver\t\tDOS executable (")
  gof = off + ml
  out = append(out, "DOS executable (")
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

func IdentifyMsdosDriver__Swapped(tb []byte, pageOff i64) ([]string, error) {
  var out []string
  var gof i64
  gof &= gof
  var off i64
  var ml i64

  // 0       name    			msdos-driver		DOS executable (
  off = pageOff + 0x0
  // uh oh unhandled kind kind family 5
  goto f0
  fmt.Printf("matched rule: %s\n", "0       name    \t\t\tmsdos-driver\t\tDOS executable (")
  gof = off + ml
  out = append(out, "DOS executable (")
  goto s0
s0:
  goto end
f0:
end:
  return out, nil
}

